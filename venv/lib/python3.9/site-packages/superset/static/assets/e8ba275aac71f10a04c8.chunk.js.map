{"version":3,"file":"e8ba275aac71f10a04c8.chunk.js","mappings":"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","sources":["webpack://superset/../../../src/utils/color-utils.ts","webpack://superset/../../../src/utils/cpu-aggregator.js","webpack://superset/../../../src/column-layer/column-geometry.ts","webpack://superset/../../../src/column-layer/column-layer-vertex.glsl.ts","webpack://superset/../../../src/column-layer/column-layer.ts","webpack://superset/../../../src/column-layer/column-layer-fragment.glsl.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport const defaultColorRange: [number, number, number][] = [\n  [255, 255, 178],\n  [254, 217, 118],\n  [254, 178, 76],\n  [253, 141, 60],\n  [240, 59, 32],\n  [189, 0, 38]\n];\n\n// Converts a colorRange array to a flat array with 4 components per color\nexport function colorRangeToFlatArray(colorRange, normalize = false, ArrayType = Float32Array) {\n  let flatArray;\n\n  if (Number.isFinite(colorRange[0])) {\n    // its already a flat array.\n    flatArray = new ArrayType(colorRange);\n  } else {\n    // flatten it\n    flatArray = new ArrayType(colorRange.length * 4);\n    let index = 0;\n\n    for (let i = 0; i < colorRange.length; i++) {\n      const color = colorRange[i];\n      flatArray[index++] = color[0];\n      flatArray[index++] = color[1];\n      flatArray[index++] = color[2];\n      flatArray[index++] = Number.isFinite(color[3]) ? color[3] : 255;\n    }\n  }\n\n  if (normalize) {\n    for (let i = 0; i < flatArray.length; i++) {\n      flatArray[i] /= 255;\n    }\n  }\n  return flatArray;\n}\n","// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport BinSorter from './bin-sorter';\nimport {getScaleFunctionByScaleType} from './scale-utils';\nimport {getValueFunc, wrapGetValueFunc} from './aggregation-operation-utils';\n\nfunction nop() {}\n\nconst dimensionSteps = ['getBins', 'getDomain', 'getScaleFunc'];\nconst defaultDimensions = [\n  {\n    key: 'fillColor',\n    accessor: 'getFillColor',\n    pickingInfo: 'colorValue',\n    getBins: {\n      triggers: {\n        value: {\n          prop: 'getColorValue',\n          updateTrigger: 'getColorValue'\n        },\n        weight: {\n          prop: 'getColorWeight',\n          updateTrigger: 'getColorWeight'\n        },\n        aggregation: {\n          prop: 'colorAggregation'\n        },\n        filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      }\n    },\n    getDomain: {\n      triggers: {\n        lowerPercentile: {\n          prop: 'lowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'upperPercentile'\n        },\n        scaleType: {\n          prop: 'colorScaleType'\n        }\n      }\n    },\n    getScaleFunc: {\n      triggers: {\n        domain: {prop: 'colorDomain'},\n        range: {prop: 'colorRange'}\n      },\n      onSet: {\n        props: 'onSetColorDomain'\n      }\n    },\n    nullValue: [0, 0, 0, 0]\n  },\n  {\n    key: 'elevation',\n    accessor: 'getElevation',\n    pickingInfo: 'elevationValue',\n    getBins: {\n      triggers: {\n        value: {\n          prop: 'getElevationValue',\n          updateTrigger: 'getElevationValue'\n        },\n        weight: {\n          prop: 'getElevationWeight',\n          updateTrigger: 'getElevationWeight'\n        },\n        aggregation: {\n          prop: 'elevationAggregation'\n        },\n        filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      }\n    },\n    getDomain: {\n      triggers: {\n        lowerPercentile: {\n          prop: 'elevationLowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'elevationUpperPercentile'\n        },\n        scaleType: {\n          prop: 'elevationScaleType'\n        }\n      }\n    },\n    getScaleFunc: {\n      triggers: {\n        domain: {prop: 'elevationDomain'},\n        range: {prop: 'elevationRange'}\n      },\n      onSet: {\n        props: 'onSetElevationDomain'\n      }\n    },\n    nullValue: -1\n  }\n];\nconst defaultGetCellSize = props => props.cellSize;\nexport default class CPUAggregator {\n  constructor(opts) {\n    this.state = {\n      layerData: {},\n      dimensions: {\n        // color: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // },\n        // elevation: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // }\n      }\n    };\n    this.changeFlags = {};\n    this.dimensionUpdaters = {};\n\n    this._getCellSize = opts.getCellSize || defaultGetCellSize;\n    this._getAggregator = opts.getAggregator;\n    this._addDimension(opts.dimensions || defaultDimensions);\n  }\n\n  static defaultDimensions() {\n    return defaultDimensions;\n  }\n\n  updateState(opts, aggregationParams) {\n    const {oldProps, props, changeFlags} = opts;\n    this.updateGetValueFuncs(oldProps, props, changeFlags);\n    const reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);\n    let aggregationDirty = false;\n    if (changeFlags.dataChanged || reprojectNeeded) {\n      // project data into bin and aggregate wegiths per bin\n      this.getAggregatedData(props, aggregationParams);\n      aggregationDirty = true;\n    } else {\n      const dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];\n      // this here is layer\n      dimensionChanges.forEach(f => typeof f === 'function' && f());\n      aggregationDirty = true;\n    }\n    this.setState({aggregationDirty});\n\n    return this.state;\n  }\n\n  // Update private state\n  setState(updateObject) {\n    this.state = {...this.state, ...updateObject};\n  }\n\n  // Update private state.dimensions\n  setDimensionState(key, updateObject) {\n    this.setState({\n      dimensions: {\n        ...this.state.dimensions,\n        [key]: {...this.state.dimensions[key], ...updateObject}\n      }\n    });\n  }\n\n  normalizeResult(result = {}) {\n    // support previous hexagonAggregator API\n    if (result.hexagons) {\n      return {data: result.hexagons, ...result};\n    } else if (result.layerData) {\n      return {data: result.layerData, ...result};\n    }\n\n    return result;\n  }\n\n  getAggregatedData(props, aggregationParams) {\n    const aggregator = this._getAggregator(props);\n\n    const result = aggregator(props, aggregationParams);\n    this.setState({\n      layerData: this.normalizeResult(result)\n    });\n    this.changeFlags = {\n      layerData: true\n    };\n    this.getSortedBins(props);\n  }\n\n  updateGetValueFuncs(oldProps, props, changeFlags) {\n    for (const key in this.dimensionUpdaters) {\n      const {value, weight, aggregation} = this.dimensionUpdaters[key].getBins.triggers;\n      let getValue = props[value.prop];\n      const getValueChanged = this.needUpdateDimensionStep(\n        this.dimensionUpdaters[key].getBins,\n        oldProps,\n        props,\n        changeFlags\n      );\n\n      if (getValueChanged) {\n        if (getValue) {\n          getValue = wrapGetValueFunc(getValue, {data: props.data});\n        } else {\n          // If `getValue` is not provided from props, build it with aggregation and weight.\n          getValue = getValueFunc(props[aggregation.prop], props[weight.prop], {data: props.data});\n        }\n      }\n\n      if (getValue) {\n        this.setDimensionState(key, {getValue});\n      }\n    }\n  }\n\n  needsReProjectPoints(oldProps, props, changeFlags) {\n    return (\n      this._getCellSize(oldProps) !== this._getCellSize(props) ||\n      this._getAggregator(oldProps) !== this._getAggregator(props) ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition))\n    );\n  }\n\n  // Adds dimensions\n  addDimension(dimensions) {\n    this._addDimension(dimensions);\n  }\n\n  _addDimension(dimensions = []) {\n    dimensions.forEach(dimension => {\n      const {key} = dimension;\n      this.dimensionUpdaters[key] = this.getDimensionUpdaters(dimension);\n      this.state.dimensions[key] = {\n        getValue: null,\n        domain: null,\n        sortedBins: null,\n        scaleFunc: nop\n      };\n    });\n  }\n\n  getDimensionUpdaters({key, accessor, pickingInfo, getBins, getDomain, getScaleFunc, nullValue}) {\n    return {\n      key,\n      accessor,\n      pickingInfo,\n      getBins: {updater: this.getDimensionSortedBins, ...getBins},\n      getDomain: {updater: this.getDimensionValueDomain, ...getDomain},\n      getScaleFunc: {updater: this.getDimensionScale, ...getScaleFunc},\n      attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)\n    };\n  }\n\n  needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {\n    // whether need to update current dimension step\n    // dimension step is the value, domain, scaleFunction of each dimension\n    // each step is an object with properties links to layer prop and whether the prop is\n    // controlled by updateTriggers\n    // getBins: {\n    //   value: {\n    //     prop: 'getElevationValue',\n    //     updateTrigger: 'getElevationValue'\n    //   },\n    //   weight: {\n    //     prop: 'getElevationWeight',\n    //     updateTrigger: 'getElevationWeight'\n    //   },\n    //   aggregation: {\n    //     prop: 'elevationAggregation'\n    //   }\n    // }\n    return Object.values(dimensionStep.triggers).some(item => {\n      if (item.updateTrigger) {\n        // check based on updateTriggers change first\n        // if data has changed, always update value\n        return (\n          changeFlags.dataChanged ||\n          (changeFlags.updateTriggersChanged &&\n            (changeFlags.updateTriggersChanged.all ||\n              changeFlags.updateTriggersChanged[item.updateTrigger]))\n        );\n      }\n      // fallback to direct comparison\n      return oldProps[item.prop] !== props[item.prop];\n    });\n  }\n\n  getDimensionChanges(oldProps, props, changeFlags) {\n    // const {dimensionUpdaters} = this.state;\n    const updaters = [];\n\n    // get dimension to be updated\n    for (const key in this.dimensionUpdaters) {\n      // return the first triggered updater for each dimension\n      const needUpdate = dimensionSteps.find(step =>\n        this.needUpdateDimensionStep(\n          this.dimensionUpdaters[key][step],\n          oldProps,\n          props,\n          changeFlags\n        )\n      );\n\n      if (needUpdate) {\n        updaters.push(\n          this.dimensionUpdaters[key][needUpdate].updater.bind(\n            this,\n            props,\n            this.dimensionUpdaters[key]\n          )\n        );\n      }\n    }\n\n    return updaters.length ? updaters : null;\n  }\n\n  getUpdateTriggers(props) {\n    const _updateTriggers = props.updateTriggers || {};\n    const updateTriggers = {};\n\n    for (const key in this.dimensionUpdaters) {\n      const {accessor} = this.dimensionUpdaters[key];\n      // fold dimension triggers into each accessor\n      updateTriggers[accessor] = {};\n\n      dimensionSteps.forEach(step => {\n        Object.values(this.dimensionUpdaters[key][step].triggers).forEach(\n          ({prop, updateTrigger}) => {\n            if (updateTrigger) {\n              // if prop is based on updateTrigger e.g. getColorValue, getColorWeight\n              // and updateTriggers is passed in from layer prop\n              // fold the updateTriggers into accessor\n              const fromProp = _updateTriggers[updateTrigger];\n              if (typeof fromProp === 'object' && !Array.isArray(fromProp)) {\n                // if updateTrigger is an object spread it\n                Object.assign(updateTriggers[accessor], fromProp);\n              } else if (fromProp !== undefined) {\n                updateTriggers[accessor][prop] = fromProp;\n              }\n            } else {\n              // if prop is not based on updateTrigger\n              updateTriggers[accessor][prop] = props[prop];\n            }\n          }\n        );\n      });\n    }\n\n    return updateTriggers;\n  }\n\n  getSortedBins(props) {\n    for (const key in this.dimensionUpdaters) {\n      this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);\n    }\n  }\n\n  getDimensionSortedBins(props, dimensionUpdater) {\n    const {key} = dimensionUpdater;\n    const {getValue} = this.state.dimensions[key];\n\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {\n      getValue,\n      filterData: props._filterData\n    });\n    this.setDimensionState(key, {sortedBins});\n    this.getDimensionValueDomain(props, dimensionUpdater);\n  }\n\n  getDimensionValueDomain(props, dimensionUpdater) {\n    const {getDomain, key} = dimensionUpdater;\n    const {\n      triggers: {lowerPercentile, upperPercentile, scaleType}\n    } = getDomain;\n    const valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(\n      props[scaleType.prop],\n      [props[lowerPercentile.prop], props[upperPercentile.prop]]\n    );\n\n    this.setDimensionState(key, {valueDomain});\n    this.getDimensionScale(props, dimensionUpdater);\n  }\n\n  getDimensionScale(props, dimensionUpdater) {\n    const {key, getScaleFunc, getDomain} = dimensionUpdater;\n    const {domain, range} = getScaleFunc.triggers;\n    const {scaleType} = getDomain.triggers;\n    const {onSet} = getScaleFunc;\n    const dimensionRange = props[range.prop];\n    const dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n    const getScaleFunction = getScaleFunctionByScaleType(scaleType && props[scaleType.prop]);\n    const scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);\n\n    if (typeof onSet === 'object' && typeof props[onSet.props] === 'function') {\n      props[onSet.props](scaleFunc.domain());\n    }\n\n    this.setDimensionState(key, {scaleFunc});\n  }\n\n  getSubLayerDimensionAttribute(key, nullValue) {\n    return cell => {\n      const {sortedBins, scaleFunc} = this.state.dimensions[key];\n      const bin = sortedBins.binMap[cell.index];\n\n      if (bin && bin.counts === 0) {\n        // no points left in bin after filtering\n        return nullValue;\n      }\n      const cv = bin && bin.value;\n      const domain = scaleFunc.domain();\n\n      const isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];\n\n      // if cell value is outside domain, set alpha to 0\n      return isValueInDomain ? scaleFunc(cv) : nullValue;\n    };\n  }\n\n  getSubLayerAccessors(props) {\n    const accessors = {};\n    for (const key in this.dimensionUpdaters) {\n      const {accessor} = this.dimensionUpdaters[key];\n      accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);\n    }\n\n    return accessors;\n  }\n\n  getPickingInfo({info}) {\n    const isPicked = info.picked && info.index > -1;\n    let object = null;\n\n    if (isPicked) {\n      // const {sortedColorBins, sortedElevationBins} = this.state;\n\n      const cell = this.state.layerData.data[info.index];\n\n      const binInfo = {};\n      for (const key in this.dimensionUpdaters) {\n        const {pickingInfo} = this.dimensionUpdaters[key];\n        const {sortedBins} = this.state.dimensions[key];\n        const value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n        binInfo[pickingInfo] = value;\n      }\n\n      object = Object.assign(binInfo, cell, {\n        points: cell.filteredPoints || cell.points\n      });\n    }\n\n    // override object with picked cell\n    info.picked = Boolean(object);\n    info.object = object;\n\n    return info;\n  }\n\n  getAccessor(dimensionKey) {\n    if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n      return nop;\n    }\n    return this.dimensionUpdaters[dimensionKey].attributeAccessor;\n  }\n}\n","import {log, BinaryAttribute} from '@deck.gl/core';\nimport {Geometry, uid} from '@luma.gl/core';\nimport {modifyPolygonWindingDirection, WINDING} from '@math.gl/polygon';\n\ntype ColumnGeometryProps = {\n  id?: string;\n  radius: number;\n  height?: number;\n  nradial?: number;\n  vertices?: number[];\n};\n\nexport default class ColumnGeometry extends Geometry {\n  constructor(props: ColumnGeometryProps) {\n    const {id = uid('column-geometry')} = props;\n    const {indices, attributes} = tesselateColumn(props);\n    super({\n      ...props,\n      id,\n      indices,\n      attributes\n    });\n  }\n}\n\n/* eslint-disable max-statements, complexity */\nfunction tesselateColumn(props: ColumnGeometryProps): {\n  indices: Uint16Array;\n  attributes: Record<string, BinaryAttribute>;\n} {\n  const {radius, height = 1, nradial = 10} = props;\n  let {vertices} = props;\n\n  if (vertices) {\n    log.assert(vertices.length >= nradial); // `vertices` must contain at least `diskResolution` points\n    vertices = vertices.flatMap(v => [v[0], v[1]]);\n    modifyPolygonWindingDirection(vertices, WINDING.COUNTER_CLOCKWISE);\n  }\n\n  const isExtruded = height > 0;\n  const vertsAroundEdge = nradial + 1; // loop\n  const numVertices = isExtruded\n    ? vertsAroundEdge * 3 + 1 // top, side top edge, side bottom edge, one additional degenerage vertex\n    : nradial; // top\n\n  const stepAngle = (Math.PI * 2) / nradial;\n\n  // Used for wireframe\n  const indices = new Uint16Array(isExtruded ? nradial * 3 * 2 : 0); // top loop, side vertical, bottom loop\n\n  const positions = new Float32Array(numVertices * 3);\n  const normals = new Float32Array(numVertices * 3);\n\n  let i = 0;\n\n  // side tesselation: 0, 1, 2, 3, 4, 5, ...\n  //\n  // 0 - 2 - 4  ... top\n  // | / | / |\n  // 1 - 3 - 5  ... bottom\n  //\n  if (isExtruded) {\n    for (let j = 0; j < vertsAroundEdge; j++) {\n      const a = j * stepAngle;\n      const vertexIndex = j % nradial;\n      const sin = Math.sin(a);\n      const cos = Math.cos(a);\n\n      for (let k = 0; k < 2; k++) {\n        positions[i + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;\n        positions[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;\n        positions[i + 2] = (1 / 2 - k) * height;\n\n        normals[i + 0] = vertices ? vertices[vertexIndex * 2] : cos;\n        normals[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin;\n\n        i += 3;\n      }\n    }\n\n    // duplicate the last vertex to create proper degenerate triangle.\n    positions[i + 0] = positions[i - 3];\n    positions[i + 1] = positions[i - 2];\n    positions[i + 2] = positions[i - 1];\n    i += 3;\n  }\n\n  // The column geometry is rendered as a triangle strip, so\n  // in order to render sides and top in one go we need to use degenerate triangles.\n  // Duplicate last vertex of side trinagles and first vertex of the top cap to preserve winding order.\n\n  // top tesselation: 0, -1, 1, -2, 2, -3, 3, ...\n  //\n  //    0 -- 1\n  //   /      \\\n  // -1        2\n  //  |        |\n  // -2        3\n  //   \\      /\n  //   -3 -- 4\n  //\n  for (let j = isExtruded ? 0 : 1; j < vertsAroundEdge; j++) {\n    const v = Math.floor(j / 2) * Math.sign(0.5 - (j % 2));\n    const a = v * stepAngle;\n    const vertexIndex = (v + nradial) % nradial;\n    const sin = Math.sin(a);\n    const cos = Math.cos(a);\n\n    positions[i + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;\n    positions[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;\n    positions[i + 2] = height / 2;\n\n    normals[i + 2] = 1;\n\n    i += 3;\n  }\n\n  if (isExtruded) {\n    let index = 0;\n    for (let j = 0; j < nradial; j++) {\n      // top loop\n      indices[index++] = j * 2 + 0;\n      indices[index++] = j * 2 + 2;\n      // side vertical\n      indices[index++] = j * 2 + 0;\n      indices[index++] = j * 2 + 1;\n      // bottom loop\n      indices[index++] = j * 2 + 1;\n      indices[index++] = j * 2 + 3;\n    }\n  }\n\n  return {\n    indices,\n    attributes: {\n      POSITION: {size: 3, value: positions},\n      NORMAL: {size: 3, value: normals}\n    }\n  };\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `#version 300 es\n\n#define SHADER_NAME column-layer-vertex-shader\n\nin vec3 positions;\nin vec3 normals;\n\nin vec3 instancePositions;\nin float instanceElevations;\nin vec3 instancePositions64Low;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\nin float instanceStrokeWidths;\n\nin vec3 instancePickingColors;\n\n// Custom uniforms\nuniform float opacity;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\nuniform bool extruded;\nuniform bool stroked;\nuniform bool isStroke;\nuniform float coverage;\nuniform float elevationScale;\nuniform float edgeDistance;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform int radiusUnits;\nuniform int widthUnits;\n\n// Result\nout vec4 vColor;\n#ifdef FLAT_SHADING\nout vec4 position_commonspace;\n#endif\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n\n  vec4 color = isStroke ? instanceLineColors : instanceFillColors;\n  // rotate primitive position and normal\n  mat2 rotationMatrix = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n\n  // calculate elevation, if 3d not enabled set to 0\n  // cylindar gemoetry height are between -1.0 to 1.0, transform it to between 0, 1\n  float elevation = 0.0;\n  // calculate stroke offset\n  float strokeOffsetRatio = 1.0;\n\n  if (extruded) {\n    elevation = instanceElevations * (positions.z + 1.0) / 2.0 * elevationScale;\n  } else if (stroked) {\n    float widthPixels = clamp(\n      project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n      widthMinPixels, widthMaxPixels) / 2.0;\n    float halfOffset = project_pixel_size(widthPixels) / project_size(edgeDistance * coverage * radius);\n    if (isStroke) {\n      strokeOffsetRatio -= sign(positions.z) * halfOffset;\n    } else {\n      strokeOffsetRatio -= halfOffset;\n    }\n  }\n\n  // if alpha == 0.0 or z < 0.0, do not render element\n  float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);\n  float dotRadius = radius * coverage * shouldRender;\n\n  geometry.pickingColor = instancePickingColors;\n\n  // project center of column\n  vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);\n  vec3 centroidPosition64Low = instancePositions64Low;\n  vec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + offset) * dotRadius;\n  if (radiusUnits == UNIT_METERS) {\n    offset = project_size(offset);\n  }\n  vec3 pos = vec3(offset, 0.);\n  DECKGL_FILTER_SIZE(pos, geometry);\n\n  gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);\n  geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  // Light calculations\n  if (extruded && !isStroke) {\n#ifdef FLAT_SHADING\n    position_commonspace = geometry.position;\n    vColor = vec4(color.rgb, color.a * opacity);\n#else\n    vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\n    vColor = vec4(lightColor, color.a * opacity);\n#endif\n  } else {\n    vColor = vec4(color.rgb, color.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Layer,\n  project32,\n  gouraudLighting,\n  phongLighting,\n  picking,\n  UNIT,\n  LayerProps,\n  LayerDataSource,\n  UpdateParameters,\n  Unit,\n  AccessorFunction,\n  Position,\n  Accessor,\n  Color,\n  Material,\n  DefaultProps\n} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, isWebGL2, hasFeature, FEATURES} from '@luma.gl/core';\nimport ColumnGeometry from './column-geometry';\n\nimport vs from './column-layer-vertex.glsl';\nimport fs from './column-layer-fragment.glsl';\n\nconst DEFAULT_COLOR: [number, number, number, number] = [0, 0, 0, 255];\n\nconst defaultProps: DefaultProps<ColumnLayerProps> = {\n  diskResolution: {type: 'number', min: 4, value: 20},\n  vertices: null,\n  radius: {type: 'number', min: 0, value: 1000},\n  angle: {type: 'number', value: 0},\n  offset: {type: 'array', value: [0, 0]},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  elevationScale: {type: 'number', min: 0, value: 1},\n  radiusUnits: 'meters',\n  lineWidthUnits: 'meters',\n  lineWidthScale: 1,\n  lineWidthMinPixels: 0,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n\n  extruded: true,\n  wireframe: false,\n  filled: true,\n  stroked: false,\n\n  getPosition: {type: 'accessor', value: x => x.position},\n  getFillColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getLineColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getLineWidth: {type: 'accessor', value: 1},\n  getElevation: {type: 'accessor', value: 1000},\n  material: true,\n  getColor: {deprecatedFor: ['getFillColor', 'getLineColor']}\n};\n\n/** All properties supported by ColumnLayer. */\nexport type ColumnLayerProps<DataT = any> = _ColumnLayerProps<DataT> & LayerProps;\n\n/** Properties added by ColumnLayer. */\ntype _ColumnLayerProps<DataT> = {\n  data: LayerDataSource<DataT>;\n  /**\n   * The number of sides to render the disk as.\n   * @default 20\n   */\n  diskResolution?: number;\n\n  /**\n   * isk size in units specified by `radiusUnits`.\n   * @default 1000\n   */\n  radius?: number;\n\n  /**\n   * Disk rotation, counter-clockwise in degrees.\n   * @default 0\n   */\n  angle?: number;\n\n  /**\n   * Replace the default geometry (regular polygon that fits inside the unit circle) with a custom one.\n   * @default null\n   */\n  vertices: Position[] | null;\n\n  /**\n   * Disk offset from the position, relative to the radius.\n   * @default [0,0]\n   */\n  offset?: [number, number];\n\n  /**\n   * Radius multiplier, between 0 - 1\n   * @default 1\n   */\n  coverage?: number;\n\n  /**\n   * Column elevation multiplier.\n   * @default 1\n   */\n  elevationScale?: number;\n\n  /**\n   * Whether to draw a filled column (solid fill).\n   * @default true\n   */\n  filled?: boolean;\n\n  /**\n   * Whether to draw an outline around the disks.\n   * @default false\n   */\n  stroked?: boolean;\n\n  /**\n   * Whether to extrude the columns. If set to `false`, all columns will be rendered as flat polygons.\n   * @default true\n   */\n  extruded?: boolean;\n\n  /**\n   * Whether to generate a line wireframe of the column.\n   * @default false\n   */\n  wireframe?: boolean;\n\n  /**\n   * If `true`, the vertical surfaces of the columns use [flat shading](https://en.wikipedia.org/wiki/Shading#Flat_vs._smooth_shading).\n   * @default false\n   */\n  flatShading?: boolean;\n\n  /**\n   * The units of the radius.\n   * @default 'meters'\n   */\n  radiusUnits?: Unit;\n\n  /**\n   * The units of the line width.\n   * @default 'meters'\n   */\n  lineWidthUnits?: Unit;\n\n  /**\n   * The line width multiplier that multiplied to all outlines.\n   * @default 1\n   */\n  lineWidthScale?: number;\n\n  /**\n   * The minimum outline width in pixels.\n   * @default 0\n   */\n  lineWidthMinPixels?: number;\n\n  /**\n   * The maximum outline width in pixels.\n   * @default Number.MAX_SAFE_INTEGER\n   */\n  lineWidthMaxPixels?: number;\n\n  /**\n   * Material settings for lighting effect. Applies if `extruded: true`.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n\n  /**\n   * Method called to retrieve the position of each column.\n   * @default object => object.position\n   */\n  getPosition?: AccessorFunction<DataT, Position>;\n\n  /**\n   * @deprecated Use getFilledColor and getLineColor instead\n   */\n  getColor?: Accessor<DataT, Color>;\n\n  /**\n   * Fill collor value or accessor.\n   * @default [0, 0, 0, 255]\n   */\n  getFillColor?: Accessor<DataT, Color>;\n\n  /**\n   * Line color value or accessor.\n   *\n   * @default [0, 0, 0, 255]\n   */\n  getLineColor?: Accessor<DataT, Color>;\n\n  /**\n   * The elevation of each cell in meters.\n   * @default 1000\n   */\n  getElevation?: Accessor<DataT, number>;\n\n  /**\n   * The width of the outline of the column, in units specified by `lineWidthUnits`.\n   *\n   * @default 1\n   */\n  getLineWidth?: Accessor<DataT, number>;\n};\n\n/** Render extruded cylinders (tessellated regular polygons) at given coordinates. */\nexport default class ColumnLayer<DataT = any, ExtraPropsT extends {} = {}> extends Layer<\n  ExtraPropsT & Required<_ColumnLayerProps<DataT>>\n> {\n  static layerName = 'ColumnLayer';\n  static defaultProps = defaultProps;\n\n  getShaders() {\n    const {gl} = this.context;\n    const transpileToGLSL100 = !isWebGL2(gl);\n    const defines: Record<string, any> = {};\n\n    const useDerivatives = this.props.flatShading && hasFeature(gl, FEATURES.GLSL_DERIVATIVES);\n    if (useDerivatives) {\n      defines.FLAT_SHADING = 1;\n    }\n    return super.getShaders({\n      vs,\n      fs,\n      defines,\n      transpileToGLSL100,\n      modules: [project32, useDerivatives ? phongLighting : gouraudLighting, picking]\n    });\n  }\n\n  /**\n   * DeckGL calls initializeState when GL context is available\n   * Essentially a deferred constructor\n   */\n  initializeState() {\n    const attributeManager = this.getAttributeManager()!;\n    /* eslint-disable max-len */\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceElevations: {\n        size: 1,\n        transition: true,\n        accessor: 'getElevation'\n      },\n      instanceFillColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: true,\n        accessor: 'getFillColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceLineColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: true,\n        accessor: 'getLineColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceStrokeWidths: {\n        size: 1,\n        accessor: 'getLineWidth',\n        transition: true\n      }\n    });\n    /* eslint-enable max-len */\n  }\n\n  updateState(params: UpdateParameters<this>): void {\n    super.updateState(params);\n\n    const {props, oldProps, changeFlags} = params;\n    const regenerateModels =\n      changeFlags.extensionsChanged || props.flatShading !== oldProps.flatShading;\n\n    if (regenerateModels) {\n      const {gl} = this.context;\n      this.state.model?.delete();\n      this.state.model = this._getModel(gl);\n      this.getAttributeManager()!.invalidateAll();\n    }\n\n    if (\n      regenerateModels ||\n      props.diskResolution !== oldProps.diskResolution ||\n      props.vertices !== oldProps.vertices ||\n      (props.extruded || props.stroked) !== (oldProps.extruded || oldProps.stroked)\n    ) {\n      this._updateGeometry(props);\n    }\n  }\n\n  getGeometry(diskResolution: number, vertices: number[] | undefined, hasThinkness: boolean) {\n    const geometry = new ColumnGeometry({\n      radius: 1,\n      height: hasThinkness ? 2 : 0,\n      vertices,\n      nradial: diskResolution\n    });\n\n    let meanVertexDistance = 0;\n    if (vertices) {\n      for (let i = 0; i < diskResolution; i++) {\n        const p = vertices[i];\n        const d = Math.sqrt(p[0] * p[0] + p[1] * p[1]);\n        meanVertexDistance += d / diskResolution;\n      }\n    } else {\n      meanVertexDistance = 1;\n    }\n    this.setState({\n      edgeDistance: Math.cos(Math.PI / diskResolution) * meanVertexDistance\n    });\n\n    return geometry;\n  }\n\n  protected _getModel(gl: WebGLRenderingContext): Model {\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      isInstanced: true\n    });\n  }\n\n  protected _updateGeometry({diskResolution, vertices, extruded, stroked}) {\n    const geometry: any = this.getGeometry(diskResolution, vertices, extruded || stroked);\n\n    this.setState({\n      fillVertexCount: geometry.attributes.POSITION.value.length / 3,\n      wireframeVertexCount: geometry.indices.value.length\n    });\n\n    this.state.model.setProps({geometry});\n  }\n\n  draw({uniforms}) {\n    const {\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      radiusUnits,\n      elevationScale,\n      extruded,\n      filled,\n      stroked,\n      wireframe,\n      offset,\n      coverage,\n      radius,\n      angle\n    } = this.props;\n    const {model, fillVertexCount, wireframeVertexCount, edgeDistance} = this.state;\n\n    model.setUniforms(uniforms).setUniforms({\n      radius,\n      angle: (angle / 180) * Math.PI,\n      offset,\n      extruded,\n      stroked,\n      coverage,\n      elevationScale,\n      edgeDistance,\n      radiusUnits: UNIT[radiusUnits],\n      widthUnits: UNIT[lineWidthUnits],\n      widthScale: lineWidthScale,\n      widthMinPixels: lineWidthMinPixels,\n      widthMaxPixels: lineWidthMaxPixels\n    });\n\n    // When drawing 3d: draw wireframe first so it doesn't get occluded by depth test\n    if (extruded && wireframe) {\n      model.setProps({isIndexed: true});\n      model\n        .setVertexCount(wireframeVertexCount)\n        .setDrawMode(GL.LINES)\n        .setUniforms({isStroke: true})\n        .draw();\n    }\n    if (filled) {\n      model.setProps({isIndexed: false});\n      model\n        .setVertexCount(fillVertexCount)\n        .setDrawMode(GL.TRIANGLE_STRIP)\n        .setUniforms({isStroke: false})\n        .draw();\n    }\n    // When drawing 2d: draw fill before stroke so that the outline is always on top\n    if (!extruded && stroked) {\n      model.setProps({isIndexed: false});\n      // The width of the stroke is achieved by flattening the side of the cylinder.\n      // Skip the last 1/3 of the vertices which is the top.\n      model\n        .setVertexCount((fillVertexCount * 2) / 3)\n        .setDrawMode(GL.TRIANGLE_STRIP)\n        .setUniforms({isStroke: true})\n        .draw();\n    }\n  }\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `#version 300 es\n#define SHADER_NAME column-layer-fragment-shader\n\nprecision highp float;\n\nuniform vec3 project_uCameraPosition;\nuniform bool extruded;\nuniform bool isStroke;\n\nout vec4 fragColor;\n\nin vec4 vColor;\n#ifdef FLAT_SHADING\nin vec4 position_commonspace;\n#endif\n\nvoid main(void) {\n  fragColor = vColor;\n#ifdef FLAT_SHADING\n  if (extruded && !isStroke && !picking_uActive) {\n    vec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n    fragColor.rgb = lighting_getLightColor(vColor.rgb, project_uCameraPosition, position_commonspace.xyz, normal);\n  }\n#endif\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n`;\n"],"names":["defaultColorRange","colorRangeToFlatArray","colorRange","normalize","ArrayType","Float32Array","flatArray","Number","isFinite","length","index","i","color","nop","dimensionSteps","defaultDimensions","key","accessor","pickingInfo","getBins","triggers","value","prop","updateTrigger","weight","aggregation","filterData","getDomain","lowerPercentile","upperPercentile","scaleType","getScaleFunc","domain","range","onSet","props","nullValue","defaultGetCellSize","cellSize","CPUAggregator","constructor","opts","this","state","layerData","dimensions","changeFlags","dimensionUpdaters","_getCellSize","getCellSize","_getAggregator","getAggregator","_addDimension","updateState","aggregationParams","oldProps","updateGetValueFuncs","reprojectNeeded","needsReProjectPoints","aggregationDirty","dataChanged","getAggregatedData","getDimensionChanges","forEach","f","setState","updateObject","setDimensionState","normalizeResult","result","hexagons","data","aggregator","getSortedBins","getValue","needUpdateDimensionStep","wrapGetValueFunc","getValueFunc","updateTriggersChanged","all","getPosition","addDimension","dimension","getDimensionUpdaters","sortedBins","scaleFunc","updater","getDimensionSortedBins","getDimensionValueDomain","getDimensionScale","attributeAccessor","getSubLayerDimensionAttribute","dimensionStep","Object","values","some","item","updaters","needUpdate","find","step","push","bind","getUpdateTriggers","_updateTriggers","updateTriggers","fromProp","Array","isArray","undefined","assign","dimensionUpdater","BinSorter","_filterData","valueDomain","getValueDomainByScale","dimensionRange","dimensionDomain","getScaleFunctionByScaleType","getScaleFunction","cell","bin","binMap","counts","cv","getSubLayerAccessors","accessors","getPickingInfo","info","object","picked","binInfo","points","filteredPoints","Boolean","getAccessor","dimensionKey","hasOwnProperty","ColumnGeometry","Geometry","id","uid","indices","attributes","radius","height","nradial","vertices","log","assert","flatMap","v","modifyPolygonWindingDirection","WINDING","COUNTER_CLOCKWISE","isExtruded","vertsAroundEdge","numVertices","stepAngle","Math","PI","Uint16Array","positions","normals","j","a","vertexIndex","sin","cos","k","floor","sign","POSITION","size","NORMAL","tesselateColumn","super","DEFAULT_COLOR","defaultProps","diskResolution","type","min","angle","offset","coverage","max","elevationScale","radiusUnits","lineWidthUnits","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","MAX_SAFE_INTEGER","extruded","wireframe","filled","stroked","x","position","getFillColor","getLineColor","getLineWidth","getElevation","material","getColor","deprecatedFor","ColumnLayer","Layer","getShaders","gl","context","transpileToGLSL100","isWebGL2","defines","useDerivatives","flatShading","hasFeature","FEATURES","GLSL_DERIVATIVES","FLAT_SHADING","vs","fs","modules","project32","phongLighting","gouraudLighting","picking","initializeState","getAttributeManager","addInstanced","instancePositions","fp64","use64bitPositions","transition","instanceElevations","instanceFillColors","colorFormat","normalized","defaultValue","instanceLineColors","instanceStrokeWidths","params","regenerateModels","extensionsChanged","_this$state$model","model","delete","_getModel","invalidateAll","_updateGeometry","getGeometry","hasThinkness","geometry","meanVertexDistance","p","sqrt","edgeDistance","Model","isInstanced","fillVertexCount","wireframeVertexCount","setProps","draw","uniforms","setUniforms","UNIT","widthUnits","widthScale","widthMinPixels","widthMaxPixels","isIndexed","setVertexCount","setDrawMode","isStroke"],"sourceRoot":""}