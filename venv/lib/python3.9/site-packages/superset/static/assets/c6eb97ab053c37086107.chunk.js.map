{"version":3,"file":"c6eb97ab053c37086107.chunk.js","mappings":"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","sources":["webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-utils.js","webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-arithmetic.glsl.js","webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64.js","webpack://superset/../../../src/cpu-grid-layer/grid-aggregator.js","webpack://superset/../../src/grid-aggregation-layer.ts","webpack://superset/../../../../src/utils/gpu-grid-aggregation/gpu-grid-aggregator-constants.js","webpack://superset/../../../../src/utils/gpu-grid-aggregation/gpu-grid-aggregator.js","webpack://superset/../../../../src/utils/gpu-grid-aggregation/transform-mean-vs.glsl.js","webpack://superset/../../../../src/utils/gpu-grid-aggregation/aggregate-to-grid-vs.glsl.js","webpack://superset/../../../../src/utils/gpu-grid-aggregation/aggregate-to-grid-fs.glsl.js","webpack://superset/../../../../src/utils/gpu-grid-aggregation/aggregate-all-vs.glsl.js","webpack://superset/../../../../src/utils/gpu-grid-aggregation/aggregate-all-fs.glsl.js","webpack://superset/../../../src/utils/grid-aggregation-utils.js","webpack://superset/../../../src/utils/resource-utils.js"],"sourcesContent":["export function fp64ify(a) {\n  let out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  const hiPart = Math.fround(a);\n  const loPart = a - hiPart;\n  out[startIndex] = hiPart;\n  out[startIndex + 1] = loPart;\n  return out;\n}\nexport function fp64LowPart(a) {\n  return a - Math.fround(a);\n}\nexport function fp64ifyMatrix4(matrix) {\n  const matrixFP64 = new Float32Array(32);\n\n  for (let i = 0; i < 4; ++i) {\n    for (let j = 0; j < 4; ++j) {\n      const index = i * 4 + j;\n      fp64ify(matrix[j * 4 + i], matrixFP64, index * 2);\n    }\n  }\n\n  return matrixFP64;\n}\n//# sourceMappingURL=fp64-utils.js.map","export default \"uniform float ONE;\\nvec2 split(float a) {\\n  const float SPLIT = 4097.0;\\n  float t = a * SPLIT;\\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\\n  float a_hi = t * ONE - (t - a);\\n  float a_lo = a * ONE - a_hi;\\n#else\\n  float a_hi = t - (t - a);\\n  float a_lo = a - a_hi;\\n#endif\\n  return vec2(a_hi, a_lo);\\n}\\nvec2 split2(vec2 a) {\\n  vec2 b = split(a.x);\\n  b.y += a.y;\\n  return b;\\n}\\nvec2 quickTwoSum(float a, float b) {\\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\\n  float sum = (a + b) * ONE;\\n  float err = b - (sum - a) * ONE;\\n#else\\n  float sum = a + b;\\n  float err = b - (sum - a);\\n#endif\\n  return vec2(sum, err);\\n}\\nvec2 twoSum(float a, float b) {\\n  float s = (a + b);\\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\\n  float v = (s * ONE - a) * ONE;\\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);\\n#else\\n  float v = s - a;\\n  float err = (a - (s - v)) + (b - v);\\n#endif\\n  return vec2(s, err);\\n}\\n\\nvec2 twoSub(float a, float b) {\\n  float s = (a - b);\\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\\n  float v = (s * ONE - a) * ONE;\\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);\\n#else\\n  float v = s - a;\\n  float err = (a - (s - v)) - (b + v);\\n#endif\\n  return vec2(s, err);\\n}\\n\\nvec2 twoSqr(float a) {\\n  float prod = a * a;\\n  vec2 a_fp64 = split(a);\\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\\n  float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *\\n    a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;\\n#else\\n  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\\n#endif\\n  return vec2(prod, err);\\n}\\n\\nvec2 twoProd(float a, float b) {\\n  float prod = a * b;\\n  vec2 a_fp64 = split(a);\\n  vec2 b_fp64 = split(b);\\n  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\\n    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\\n  return vec2(prod, err);\\n}\\n\\nvec2 sum_fp64(vec2 a, vec2 b) {\\n  vec2 s, t;\\n  s = twoSum(a.x, b.x);\\n  t = twoSum(a.y, b.y);\\n  s.y += t.x;\\n  s = quickTwoSum(s.x, s.y);\\n  s.y += t.y;\\n  s = quickTwoSum(s.x, s.y);\\n  return s;\\n}\\n\\nvec2 sub_fp64(vec2 a, vec2 b) {\\n  vec2 s, t;\\n  s = twoSub(a.x, b.x);\\n  t = twoSub(a.y, b.y);\\n  s.y += t.x;\\n  s = quickTwoSum(s.x, s.y);\\n  s.y += t.y;\\n  s = quickTwoSum(s.x, s.y);\\n  return s;\\n}\\n\\nvec2 mul_fp64(vec2 a, vec2 b) {\\n  vec2 prod = twoProd(a.x, b.x);\\n  prod.y += a.x * b.y;\\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\\n  prod = split2(prod);\\n#endif\\n  prod = quickTwoSum(prod.x, prod.y);\\n  prod.y += a.y * b.x;\\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\\n  prod = split2(prod);\\n#endif\\n  prod = quickTwoSum(prod.x, prod.y);\\n  return prod;\\n}\\n\\nvec2 div_fp64(vec2 a, vec2 b) {\\n  float xn = 1.0 / b.x;\\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\\n  vec2 yn = mul_fp64(a, vec2(xn, 0));\\n#else\\n  vec2 yn = a * xn;\\n#endif\\n  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;\\n  vec2 prod = twoProd(xn, diff);\\n  return sum_fp64(yn, prod);\\n}\\n\\nvec2 sqrt_fp64(vec2 a) {\\n  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\\n  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\\n\\n  float x = 1.0 / sqrt(a.x);\\n  float yn = a.x * x;\\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\\n  vec2 yn_sqr = twoSqr(yn) * ONE;\\n#else\\n  vec2 yn_sqr = twoSqr(yn);\\n#endif\\n  float diff = sub_fp64(a, yn_sqr).x;\\n  vec2 prod = twoProd(x * 0.5, diff);\\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\\n  return sum_fp64(split(yn), prod);\\n#else\\n  return sum_fp64(vec2(yn, 0.0), prod);\\n#endif\\n}\\n\";\n//# sourceMappingURL=fp64-arithmetic.glsl.js.map","import { fp64ify, fp64LowPart, fp64ifyMatrix4 } from './fp64-utils';\nimport fp64arithmeticShader from './fp64-arithmetic.glsl';\nimport fp64functionShader from './fp64-functions.glsl';\nconst CONST_UNIFORMS = {\n  ONE: 1.0\n};\nexport { fp64ify, fp64LowPart, fp64ifyMatrix4 };\n\nfunction getUniforms() {\n  return CONST_UNIFORMS;\n}\n\nexport const fp64arithmetic = {\n  name: 'fp64-arithmetic',\n  vs: fp64arithmeticShader,\n  fs: null,\n  getUniforms,\n  fp64ify,\n  fp64LowPart,\n  fp64ifyMatrix4\n};\nexport const fp64 = {\n  name: 'fp64',\n  vs: fp64functionShader,\n  fs: null,\n  dependencies: [fp64arithmetic],\n  fp64ify,\n  fp64LowPart,\n  fp64ifyMatrix4\n};\n//# sourceMappingURL=fp64.js.map","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {createIterable} from '@deck.gl/core';\nimport {getGridOffset} from '../utils/grid-aggregation-utils';\n\n/**\n * Calculate density grid from an array of points\n * @param {Object} props - object containing :\n * @param {Iterable} [props.data] - data objects to be aggregated\n * @param {Integer} [props.cellSize] - size of the grid cell\n *\n * @param {Object} aggregationParams - object containing :\n * @param {Object} gridOffset - {xOffset, yOffset} cell size in meters\n * @param {Integer} width - width of the grid\n * @param {Integer} height - height of the grid\n * @param {Boolean} projectPoints - `true` if doing screen space projection, `false` otherwise\n * @param {Array} attributes - attributes array containing position values\n * @param {Viewport} viewport - viewport to be used for projection\n * @param {Array} posOffset - [xOffset, yOffset] offset to be applied to positions to get cell index\n * @param {Object} boundingBox - {xMin, yMin, xMax, yMax} bounding box of input data\n *\n * @returns {object} - grid data, cell dimension\n */\nexport function pointToDensityGridDataCPU(props, aggregationParams) {\n  const hashInfo = pointsToGridHashing(props, aggregationParams);\n  const result = getGridLayerDataFromGridHash(hashInfo);\n\n  return {\n    gridHash: hashInfo.gridHash,\n    gridOffset: hashInfo.gridOffset,\n    data: result\n  };\n}\n\n/**\n * Project points into each cell, return a hash table of cells\n * @param {Iterable} points\n * @param {number} cellSize - unit size in meters\n * @param {function} getPosition - position accessor\n * @returns {object} - grid hash and cell dimension\n */\n/* eslint-disable max-statements, complexity */\nfunction pointsToGridHashing(props, aggregationParams) {\n  const {data = [], cellSize} = props;\n  const {attributes, viewport, projectPoints, numInstances} = aggregationParams;\n  const positions = attributes.positions.value;\n  const {size} = attributes.positions.getAccessor();\n  const boundingBox =\n    aggregationParams.boundingBox || getPositionBoundingBox(attributes.positions, numInstances);\n  const offsets = aggregationParams.posOffset || [180, 90];\n  const gridOffset = aggregationParams.gridOffset || getGridOffset(boundingBox, cellSize);\n\n  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {\n    return {gridHash: {}, gridOffset};\n  }\n\n  const {width, height} = viewport;\n  const numCol = Math.ceil(width / gridOffset.xOffset);\n  const numRow = Math.ceil(height / gridOffset.yOffset);\n\n  // calculate count per cell\n  const gridHash = {};\n\n  const {iterable, objectInfo} = createIterable(data);\n  const position = new Array(3);\n  for (const pt of iterable) {\n    objectInfo.index++;\n    position[0] = positions[objectInfo.index * size];\n    position[1] = positions[objectInfo.index * size + 1];\n    position[2] = size >= 3 ? positions[objectInfo.index * size + 2] : 0;\n    const [x, y] = projectPoints ? viewport.project(position) : position;\n    if (Number.isFinite(x) && Number.isFinite(y)) {\n      const yIndex = Math.floor((y + offsets[1]) / gridOffset.yOffset);\n      const xIndex = Math.floor((x + offsets[0]) / gridOffset.xOffset);\n      if (\n        !projectPoints ||\n        // when doing screen space agggregation (projectPoints = true), filter points outside of the viewport range.\n        (xIndex >= 0 && xIndex < numCol && yIndex >= 0 && yIndex < numRow)\n      ) {\n        const key = `${yIndex}-${xIndex}`;\n\n        gridHash[key] = gridHash[key] || {count: 0, points: [], lonIdx: xIndex, latIdx: yIndex};\n        gridHash[key].count += 1;\n        gridHash[key].points.push({\n          source: pt,\n          index: objectInfo.index\n        });\n      }\n    }\n  }\n\n  return {gridHash, gridOffset, offsets: [offsets[0] * -1, offsets[1] * -1]};\n}\n/* eslint-enable max-statements, complexity */\n\nfunction getGridLayerDataFromGridHash({gridHash, gridOffset, offsets}) {\n  const data = new Array(Object.keys(gridHash).length);\n  let i = 0;\n  for (const key in gridHash) {\n    const idxs = key.split('-');\n    const latIdx = parseInt(idxs[0], 10);\n    const lonIdx = parseInt(idxs[1], 10);\n    const index = i++;\n\n    data[index] = {\n      index,\n      position: [\n        offsets[0] + gridOffset.xOffset * lonIdx,\n        offsets[1] + gridOffset.yOffset * latIdx\n      ],\n      ...gridHash[key]\n    };\n  }\n  return data;\n}\n\n// Calculate bounding box of position attribute\nfunction getPositionBoundingBox(positionAttribute, numInstance) {\n  // TODO - value might not exist (e.g. attribute transition)\n  const positions = positionAttribute.value;\n  const {size} = positionAttribute.getAccessor();\n\n  let yMin = Infinity;\n  let yMax = -Infinity;\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let y;\n  let x;\n\n  for (let i = 0; i < numInstance; i++) {\n    x = positions[i * size];\n    y = positions[i * size + 1];\n    if (Number.isFinite(x) && Number.isFinite(y)) {\n      yMin = y < yMin ? y : yMin;\n      yMax = y > yMax ? y : yMax;\n      xMin = x < xMin ? x : xMin;\n      xMax = x > xMax ? x : xMax;\n    }\n  }\n\n  return {xMin, xMax, yMin, yMax};\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport AggregationLayer, {AggregationLayerProps} from './aggregation-layer';\nimport GPUGridAggregator from './utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {Buffer} from '@luma.gl/core';\nimport {LayerContext, log, UpdateParameters} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport BinSorter from './utils/bin-sorter';\nimport {pointToDensityGridDataCPU} from './cpu-grid-layer/grid-aggregator';\n\nexport type GridAggregationLayerProps<DataT> = AggregationLayerProps<DataT>;\n\nexport default abstract class GridAggregationLayer<\n  DataT,\n  ExtraPropsT extends {} = {}\n> extends AggregationLayer<DataT, ExtraPropsT> {\n  static layerName = 'GridAggregationLayer';\n\n  state!: AggregationLayer<DataT>['state'] & {\n    aggregationDataDirty?: any;\n    aggregationWeightsDirty?: any;\n    gpuAggregation?: any;\n    getValue?: () => any;\n    sortedBins?: BinSorter;\n  };\n\n  initializeAggregationLayer({dimensions}) {\n    const {gl} = this.context;\n    super.initializeAggregationLayer(dimensions);\n    this.setState({\n      // CPU aggregation results\n      layerData: {},\n      gpuGridAggregator: new GPUGridAggregator(gl, {id: `${this.id}-gpu-aggregator`}),\n      cpuGridAggregator: pointToDensityGridDataCPU\n    });\n  }\n\n  updateState(opts: UpdateParameters<this>) {\n    // get current attributes\n    super.updateState(opts);\n\n    this.updateAggregationState(opts);\n\n    const {aggregationDataDirty, aggregationWeightsDirty, gpuAggregation} = this.state;\n    if (this.getNumInstances() <= 0) {\n      return;\n    }\n    let aggregationDirty = false;\n    // CPU aggregation is two steps\n    // 1. Create bins (based on cellSize and position) 2. Aggregate weights for each bin\n    // For GPU aggregation both above steps are combined into one step\n\n    // step-1\n    if (aggregationDataDirty || (gpuAggregation && aggregationWeightsDirty)) {\n      this._updateAggregation(opts);\n      aggregationDirty = true;\n    }\n    // step-2 (Applicalbe for CPU aggregation only)\n    if (!gpuAggregation && (aggregationDataDirty || aggregationWeightsDirty)) {\n      this._updateWeightBins();\n      this._uploadAggregationResults();\n      aggregationDirty = true;\n    }\n\n    this.setState({aggregationDirty});\n  }\n\n  finalizeState(context: LayerContext) {\n    const {count} = this.state.weights;\n    if (count && count.aggregationBuffer) {\n      count.aggregationBuffer.delete();\n    }\n    this.state.gpuGridAggregator?.delete();\n    super.finalizeState(context);\n  }\n\n  updateShaders(shaders: any): void {\n    if (this.state.gpuAggregation) {\n      this.state.gpuGridAggregator.updateShaders(shaders);\n    }\n  }\n\n  // Methods that can be overriden by subclasses for customizations\n\n  updateAggregationState(opts) {\n    // Sublayers should implement this method.\n    log.assert(false);\n  }\n\n  allocateResources(numRow, numCol) {\n    if (this.state.numRow !== numRow || this.state.numCol !== numCol) {\n      const dataBytes = numCol * numRow * 4 * 4;\n      const gl = this.context.gl;\n      const {weights} = this.state;\n      for (const name in weights) {\n        const weight = weights[name];\n        if (weight.aggregationBuffer) {\n          weight.aggregationBuffer.delete();\n        }\n        weight.aggregationBuffer = new Buffer(gl, {\n          byteLength: dataBytes,\n          accessor: {\n            size: 4,\n            type: GL.FLOAT,\n            divisor: 1\n          }\n        });\n      }\n    }\n  }\n\n  updateResults({aggregationData, maxMinData, maxData, minData}) {\n    const {count} = this.state.weights;\n    if (count) {\n      count.aggregationData = aggregationData;\n      count.maxMinData = maxMinData;\n      count.maxData = maxData;\n      count.minData = minData;\n    }\n  }\n\n  // Private\n\n  _updateAggregation(opts) {\n    const {\n      cpuGridAggregator,\n      gpuGridAggregator,\n      gridOffset,\n      posOffset,\n      translation = [0, 0],\n      scaling = [0, 0, 0],\n      boundingBox,\n      projectPoints,\n      gpuAggregation,\n      numCol,\n      numRow\n    } = this.state;\n    const {props} = opts;\n    const {viewport} = this.context;\n    const attributes = this.getAttributes();\n    const vertexCount = this.getNumInstances();\n\n    if (!gpuAggregation) {\n      const result = cpuGridAggregator(props, {\n        gridOffset,\n        projectPoints,\n        attributes,\n        viewport,\n        posOffset,\n        boundingBox\n      });\n      this.setState({\n        layerData: result\n      });\n    } else {\n      const {weights} = this.state;\n      gpuGridAggregator.run({\n        weights,\n        cellSize: [gridOffset.xOffset, gridOffset.yOffset],\n        numCol,\n        numRow,\n        translation,\n        scaling,\n        vertexCount,\n        projectPoints,\n        attributes,\n        moduleSettings: this.getModuleSettings()\n      });\n    }\n  }\n\n  _updateWeightBins() {\n    const {getValue} = this.state;\n\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {getValue});\n    this.setState({sortedBins});\n  }\n\n  _uploadAggregationResults(): void {\n    const {numCol, numRow} = this.state;\n    const {data} = this.state.layerData;\n    const {aggregatedBins, minValue, maxValue, totalCount} = this.state.sortedBins!;\n\n    const ELEMENTCOUNT = 4;\n    const aggregationSize = numCol * numRow * ELEMENTCOUNT;\n    const aggregationData = new Float32Array(aggregationSize).fill(0);\n    for (const bin of aggregatedBins) {\n      const {lonIdx, latIdx} = data[bin.i];\n      const {value, counts} = bin;\n      const cellIndex = (lonIdx + latIdx * numCol) * ELEMENTCOUNT;\n      aggregationData[cellIndex] = value;\n      aggregationData[cellIndex + ELEMENTCOUNT - 1] = counts;\n    }\n    const maxMinData = new Float32Array([maxValue, 0, 0, minValue]);\n    const maxData = new Float32Array([maxValue, 0, 0, totalCount]);\n    const minData = new Float32Array([minValue, 0, 0, totalCount]);\n    this.updateResults({aggregationData, maxMinData, maxData, minData});\n  }\n}\n","import GL from '@luma.gl/constants';\nimport {AGGREGATION_OPERATION} from '../aggregation-operation-utils';\n\nexport const DEFAULT_RUN_PARAMS = {\n  projectPoints: false,\n  viewport: null,\n  createBufferObjects: true,\n  moduleSettings: {}\n};\n\nexport const MAX_32_BIT_FLOAT = 3.402823466e38;\nexport const MIN_BLEND_EQUATION = [GL.MIN, GL.FUNC_ADD];\nexport const MAX_BLEND_EQUATION = [GL.MAX, GL.FUNC_ADD];\nexport const MAX_MIN_BLEND_EQUATION = [GL.MAX, GL.MIN];\nexport const EQUATION_MAP = {\n  [AGGREGATION_OPERATION.SUM]: GL.FUNC_ADD,\n  [AGGREGATION_OPERATION.MEAN]: GL.FUNC_ADD,\n  [AGGREGATION_OPERATION.MIN]: MIN_BLEND_EQUATION,\n  [AGGREGATION_OPERATION.MAX]: MAX_BLEND_EQUATION\n};\n\nexport const ELEMENTCOUNT = 4;\nexport const DEFAULT_WEIGHT_PARAMS = {\n  size: 1,\n  operation: AGGREGATION_OPERATION.SUM,\n  needMin: false,\n  needMax: false,\n  combineMaxMin: false\n};\n\nexport const PIXEL_SIZE = 4; // RGBA32F\nexport const WEIGHT_SIZE = 3;\n\nexport const MAX_MIN_TEXTURE_OPTS = {\n  format: GL.RGBA32F,\n  type: GL.FLOAT,\n  border: 0,\n  mipmaps: false,\n  parameters: {\n    [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n    [GL.TEXTURE_MIN_FILTER]: GL.NEAREST\n  },\n  dataFormat: GL.RGBA,\n  width: 1,\n  height: 1\n};\n","// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {\n  Model,\n  Transform,\n  FEATURES,\n  hasFeatures,\n  isWebGL2,\n  readPixelsToBuffer,\n  withParameters\n} from '@luma.gl/core';\nimport {fp64arithmetic} from '@luma.gl/shadertools';\nimport {log, project32, _mergeShaders as mergeShaders} from '@deck.gl/core';\n\nimport {\n  DEFAULT_RUN_PARAMS,\n  MAX_32_BIT_FLOAT,\n  MIN_BLEND_EQUATION,\n  MAX_BLEND_EQUATION,\n  MAX_MIN_BLEND_EQUATION,\n  EQUATION_MAP,\n  DEFAULT_WEIGHT_PARAMS,\n  PIXEL_SIZE\n} from './gpu-grid-aggregator-constants';\nimport {AGGREGATION_OPERATION} from '../aggregation-operation-utils';\n\nimport AGGREGATE_TO_GRID_VS from './aggregate-to-grid-vs.glsl';\nimport AGGREGATE_TO_GRID_FS from './aggregate-to-grid-fs.glsl';\nimport AGGREGATE_ALL_VS from './aggregate-all-vs.glsl';\nimport AGGREGATE_ALL_FS from './aggregate-all-fs.glsl';\nimport TRANSFORM_MEAN_VS from './transform-mean-vs.glsl';\nimport {getFloatTexture, getFramebuffer} from './../resource-utils.js';\n\nconst BUFFER_NAMES = ['aggregationBuffer', 'maxMinBuffer', 'minBuffer', 'maxBuffer'];\nconst ARRAY_BUFFER_MAP = {\n  maxData: 'maxBuffer',\n  minData: 'minBuffer',\n  maxMinData: 'maxMinBuffer'\n};\n\nconst REQUIRED_FEATURES = [\n  FEATURES.WEBGL2, // TODO: Remove after trannsform refactor\n  FEATURES.COLOR_ATTACHMENT_RGBA32F,\n  FEATURES.BLEND_EQUATION_MINMAX,\n  FEATURES.FLOAT_BLEND,\n  FEATURES.TEXTURE_FLOAT\n];\n\nexport default class GPUGridAggregator {\n  // Decode and return aggregation data of given pixel.\n  static getAggregationData({aggregationData, maxData, minData, maxMinData, pixelIndex}) {\n    const index = pixelIndex * PIXEL_SIZE;\n    const results = {};\n    if (aggregationData) {\n      results.cellCount = aggregationData[index + 3];\n      results.cellWeight = aggregationData[index];\n    }\n    if (maxMinData) {\n      results.maxCellWieght = maxMinData[0];\n      results.minCellWeight = maxMinData[3];\n    } else {\n      if (maxData) {\n        results.maxCellWieght = maxData[0];\n        results.totalCount = maxData[3];\n      }\n      if (minData) {\n        results.minCellWeight = minData[0];\n        results.totalCount = maxData[3];\n      }\n    }\n    return results;\n  }\n\n  // Decodes and retuns counts and weights of all cells\n  static getCellData({countsData, size = 1}) {\n    const numCells = countsData.length / 4;\n    const cellWeights = new Float32Array(numCells * size);\n    const cellCounts = new Uint32Array(numCells);\n    for (let i = 0; i < numCells; i++) {\n      // weights in RGB channels\n      for (let sizeIndex = 0; sizeIndex < size; sizeIndex++) {\n        cellWeights[i * size + sizeIndex] = countsData[i * 4 + sizeIndex];\n      }\n      // count in Alpha channel\n      cellCounts[i] = countsData[i * 4 + 3];\n    }\n    return {cellCounts, cellWeights};\n  }\n\n  static isSupported(gl) {\n    return hasFeatures(gl, REQUIRED_FEATURES);\n  }\n\n  // DEBUG ONLY\n  // static logData({aggregationBuffer, minBuffer, maxBuffer, maxMinBuffer, limit = 10}) {\n  //   if (aggregationBuffer) {\n  //     console.log('Aggregation Data:');\n  //     const agrData = aggregationBuffer.getData();\n  //     for (let index = 0; index < agrData.length && limit > 0; index += 4) {\n  //       if (agrData[index + 3] > 0) {\n  //         console.log(\n  //           `index: ${index} weights: ${agrData[index]} ${agrData[index + 1]} ${\n  //             agrData[index + 2]\n  //           } count: ${agrData[index + 3]}`\n  //         );\n  //         limit--;\n  //       }\n  //     }\n  //   }\n  //   const obj = {minBuffer, maxBuffer, maxMinBuffer};\n  //   for (const key in obj) {\n  //     if (obj[key]) {\n  //       const data = obj[key].getData();\n  //       console.log(`${key} data : R: ${data[0]} G: ${data[1]} B: ${data[2]} A: ${data[3]}`);\n  //     }\n  //   }\n  // }\n\n  constructor(gl, opts = {}) {\n    this.id = opts.id || 'gpu-grid-aggregator';\n    this.gl = gl;\n    this.state = {\n      // per weight GPU resources\n      weightAttributes: {},\n      textures: {},\n      meanTextures: {},\n      buffers: {},\n      framebuffers: {},\n      maxMinFramebuffers: {},\n      minFramebuffers: {},\n      maxFramebuffers: {},\n      equations: {},\n\n      // common resources to be deleted\n      resources: {},\n\n      // results\n      results: {}\n    };\n    this._hasGPUSupport =\n      isWebGL2(gl) && // gl_InstanceID usage in min/max calculation shaders\n      hasFeatures(\n        this.gl,\n        FEATURES.BLEND_EQUATION_MINMAX, // set min/max blend modes\n        FEATURES.COLOR_ATTACHMENT_RGBA32F, // render to float texture\n        FEATURES.TEXTURE_FLOAT // sample from a float texture\n      );\n    if (this._hasGPUSupport) {\n      this._setupModels();\n    }\n  }\n\n  // Delete owned resources.\n  delete() {\n    const {gridAggregationModel, allAggregationModel, meanTransform} = this;\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    } = this.state;\n\n    gridAggregationModel?.delete();\n    allAggregationModel?.delete();\n    meanTransform?.delete();\n\n    deleteResources([\n      framebuffers,\n      textures,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    ]);\n  }\n\n  // Perform aggregation and retun the results\n  run(opts = {}) {\n    // reset results\n    this.setState({results: {}});\n    const aggregationParams = this._normalizeAggregationParams(opts);\n    if (!this._hasGPUSupport) {\n      log.log(1, 'GPUGridAggregator: not supported')();\n    }\n    return this._runAggregation(aggregationParams);\n  }\n\n  // Reads aggregation data into JS Array object\n  // For WebGL1, data is available in JS Array objects already.\n  // For WebGL2, data is read from Buffer objects and cached for subsequent queries.\n  getData(weightId) {\n    const data = {};\n    const results = this.state.results;\n    if (!results[weightId].aggregationData) {\n      // cache the results if reading from the buffer (WebGL2 path)\n      results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();\n    }\n    data.aggregationData = results[weightId].aggregationData;\n\n    // Check for optional results\n    for (const arrayName in ARRAY_BUFFER_MAP) {\n      const bufferName = ARRAY_BUFFER_MAP[arrayName];\n\n      if (results[weightId][arrayName] || results[weightId][bufferName]) {\n        // cache the result\n        results[weightId][arrayName] =\n          results[weightId][arrayName] || results[weightId][bufferName].getData();\n        data[arrayName] = results[weightId][arrayName];\n      }\n    }\n    return data;\n  }\n\n  updateShaders(shaderOptions = {}) {\n    this.setState({shaderOptions, modelDirty: true});\n  }\n\n  // PRIVATE\n\n  _normalizeAggregationParams(opts) {\n    const aggregationParams = {...DEFAULT_RUN_PARAMS, ...opts};\n    const {weights} = aggregationParams;\n    if (weights) {\n      aggregationParams.weights = normalizeWeightParams(weights);\n    }\n    return aggregationParams;\n  }\n\n  // Update priveate state\n  setState(updateObject) {\n    Object.assign(this.state, updateObject);\n  }\n\n  // GPU Aggregation methods\n\n  _getAggregateData(opts) {\n    const results = {};\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      resources\n    } = this.state;\n    const {weights} = opts;\n\n    for (const id in weights) {\n      results[id] = {};\n      const {needMin, needMax, combineMaxMin} = weights[id];\n      results[id].aggregationTexture = textures[id];\n      results[id].aggregationBuffer = readPixelsToBuffer(framebuffers[id], {\n        target: weights[id].aggregationBuffer, // update if a buffer is provided\n        sourceType: GL.FLOAT\n      });\n      if (needMin && needMax && combineMaxMin) {\n        results[id].maxMinBuffer = readPixelsToBuffer(maxMinFramebuffers[id], {\n          target: weights[id].maxMinBuffer, // update if a buffer is provided\n          sourceType: GL.FLOAT\n        });\n        results[id].maxMinTexture = resources[`${id}-maxMinTexture`];\n      } else {\n        if (needMin) {\n          results[id].minBuffer = readPixelsToBuffer(minFramebuffers[id], {\n            target: weights[id].minBuffer, // update if a buffer is provided\n            sourceType: GL.FLOAT\n          });\n          results[id].minTexture = resources[`${id}-minTexture`];\n        }\n        if (needMax) {\n          results[id].maxBuffer = readPixelsToBuffer(maxFramebuffers[id], {\n            target: weights[id].maxBuffer, // update if a buffer is provided\n            sourceType: GL.FLOAT\n          });\n          results[id].maxTexture = resources[`${id}-maxTexture`];\n        }\n      }\n    }\n    this._trackGPUResultBuffers(results, weights);\n    return results;\n  }\n\n  _renderAggregateData(opts) {\n    const {\n      cellSize,\n      projectPoints,\n      attributes,\n      moduleSettings,\n      numCol,\n      numRow,\n      weights,\n      translation,\n      scaling\n    } = opts;\n    const {maxMinFramebuffers, minFramebuffers, maxFramebuffers} = this.state;\n\n    const gridSize = [numCol, numRow];\n    const parameters = {\n      blend: true,\n      depthTest: false,\n      blendFunc: [GL.ONE, GL.ONE]\n    };\n    const uniforms = {\n      cellSize,\n      gridSize,\n      projectPoints,\n      translation,\n      scaling\n    };\n\n    for (const id in weights) {\n      const {needMin, needMax} = weights[id];\n      const combineMaxMin = needMin && needMax && weights[id].combineMaxMin;\n      this._renderToWeightsTexture({\n        id,\n        parameters,\n        moduleSettings,\n        uniforms,\n        gridSize,\n        attributes,\n        weights\n      });\n      if (combineMaxMin) {\n        this._renderToMaxMinTexture({\n          id,\n          parameters: {...parameters, blendEquation: MAX_MIN_BLEND_EQUATION},\n          gridSize,\n          minOrMaxFb: maxMinFramebuffers[id],\n          clearParams: {clearColor: [0, 0, 0, MAX_32_BIT_FLOAT]},\n          combineMaxMin\n        });\n      } else {\n        if (needMin) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: {...parameters, blendEquation: MIN_BLEND_EQUATION},\n            gridSize,\n            minOrMaxFb: minFramebuffers[id],\n            clearParams: {clearColor: [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]},\n            combineMaxMin\n          });\n        }\n        if (needMax) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: {...parameters, blendEquation: MAX_BLEND_EQUATION},\n            gridSize,\n            minOrMaxFb: maxFramebuffers[id],\n            clearParams: {clearColor: [0, 0, 0, 0]},\n            combineMaxMin\n          });\n        }\n      }\n    }\n  }\n\n  // render all aggregated grid-cells to generate Min, Max or MaxMin data texture\n  _renderToMaxMinTexture(opts) {\n    const {id, parameters, gridSize, minOrMaxFb, combineMaxMin, clearParams = {}} = opts;\n    const {framebuffers} = this.state;\n    const {gl, allAggregationModel} = this;\n\n    withParameters(\n      gl,\n      {\n        ...clearParams,\n        framebuffer: minOrMaxFb,\n        viewport: [0, 0, gridSize[0], gridSize[1]]\n      },\n      () => {\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        allAggregationModel.draw({\n          parameters,\n          uniforms: {\n            uSampler: framebuffers[id].texture,\n            gridSize,\n            combineMaxMin\n          }\n        });\n      }\n    );\n  }\n\n  // render all data points to aggregate weights\n  _renderToWeightsTexture(opts) {\n    const {id, parameters, moduleSettings, uniforms, gridSize, weights} = opts;\n    const {framebuffers, equations, weightAttributes} = this.state;\n    const {gl, gridAggregationModel} = this;\n    const {operation} = weights[id];\n\n    const clearColor =\n      operation === AGGREGATION_OPERATION.MIN\n        ? [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]\n        : [0, 0, 0, 0];\n    withParameters(\n      gl,\n      {\n        framebuffer: framebuffers[id],\n        viewport: [0, 0, gridSize[0], gridSize[1]],\n        clearColor\n      },\n      () => {\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        const attributes = {weights: weightAttributes[id]};\n        gridAggregationModel.draw({\n          parameters: {...parameters, blendEquation: equations[id]},\n          moduleSettings,\n          uniforms,\n          attributes\n        });\n      }\n    );\n\n    if (operation === AGGREGATION_OPERATION.MEAN) {\n      const {meanTextures, textures} = this.state;\n      const transformOptions = {\n        _sourceTextures: {aggregationValues: meanTextures[id]}, // contains aggregated data\n        _targetTexture: textures[id], // store mean values,\n        elementCount: textures[id].width * textures[id].height\n      };\n      if (this.meanTransform) {\n        this.meanTransform.update(transformOptions);\n      } else {\n        this.meanTransform = getMeanTransform(gl, transformOptions);\n      }\n      this.meanTransform.run({\n        parameters: {\n          blend: false,\n          depthTest: false\n        }\n      });\n\n      // update framebuffer with mean results so readPixelsToBuffer returns mean values\n      framebuffers[id].attach({[GL.COLOR_ATTACHMENT0]: textures[id]});\n    }\n  }\n\n  _runAggregation(opts) {\n    this._updateModels(opts);\n    this._setupFramebuffers(opts);\n    this._renderAggregateData(opts);\n    const results = this._getAggregateData(opts);\n    this.setState({results});\n    return results;\n  }\n\n  // set up framebuffer for each weight\n  /* eslint-disable complexity, max-depth, max-statements*/\n  _setupFramebuffers(opts) {\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      equations\n    } = this.state;\n    const {weights} = opts;\n    const {numCol, numRow} = opts;\n    const framebufferSize = {width: numCol, height: numRow};\n    for (const id in weights) {\n      const {needMin, needMax, combineMaxMin, operation} = weights[id];\n      textures[id] =\n        weights[id].aggregationTexture ||\n        textures[id] ||\n        getFloatTexture(this.gl, {id: `${id}-texture`, width: numCol, height: numRow});\n      textures[id].resize(framebufferSize);\n      let texture = textures[id];\n      if (operation === AGGREGATION_OPERATION.MEAN) {\n        // For MEAN, we first aggregatet into a temp texture\n        meanTextures[id] =\n          meanTextures[id] ||\n          getFloatTexture(this.gl, {id: `${id}-mean-texture`, width: numCol, height: numRow});\n        meanTextures[id].resize(framebufferSize);\n        texture = meanTextures[id];\n      }\n      if (framebuffers[id]) {\n        framebuffers[id].attach({[GL.COLOR_ATTACHMENT0]: texture});\n      } else {\n        framebuffers[id] = getFramebuffer(this.gl, {\n          id: `${id}-fb`,\n          width: numCol,\n          height: numRow,\n          texture\n        });\n      }\n      framebuffers[id].resize(framebufferSize);\n      equations[id] = EQUATION_MAP[operation] || EQUATION_MAP.SUM;\n      // For min/max framebuffers will use default size 1X1\n      if (needMin || needMax) {\n        if (needMin && needMax && combineMaxMin) {\n          if (!maxMinFramebuffers[id]) {\n            texture = weights[id].maxMinTexture || this._getMinMaxTexture(`${id}-maxMinTexture`);\n            maxMinFramebuffers[id] = getFramebuffer(this.gl, {id: `${id}-maxMinFb`, texture});\n          }\n        } else {\n          if (needMin) {\n            if (!minFramebuffers[id]) {\n              texture = weights[id].minTexture || this._getMinMaxTexture(`${id}-minTexture`);\n              minFramebuffers[id] = getFramebuffer(this.gl, {\n                id: `${id}-minFb`,\n                texture\n              });\n            }\n          }\n          if (needMax) {\n            if (!maxFramebuffers[id]) {\n              texture = weights[id].maxTexture || this._getMinMaxTexture(`${id}-maxTexture`);\n              maxFramebuffers[id] = getFramebuffer(this.gl, {\n                id: `${id}-maxFb`,\n                texture\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  /* eslint-enable complexity, max-depth, max-statements */\n\n  _getMinMaxTexture(name) {\n    const {resources} = this.state;\n    if (!resources[name]) {\n      resources[name] = getFloatTexture(this.gl, {id: `resourceName`});\n    }\n    return resources[name];\n  }\n\n  _setupModels({numCol = 0, numRow = 0} = {}) {\n    const {gl} = this;\n    const {shaderOptions} = this.state;\n    this.gridAggregationModel?.delete();\n    this.gridAggregationModel = getAggregationModel(gl, shaderOptions);\n    if (!this.allAggregationModel) {\n      const instanceCount = numCol * numRow;\n      this.allAggregationModel = getAllAggregationModel(gl, instanceCount);\n    }\n  }\n\n  // set up buffers for all weights\n  _setupWeightAttributes(opts) {\n    const {weightAttributes} = this.state;\n    const {weights} = opts;\n    for (const id in weights) {\n      weightAttributes[id] = opts.attributes[id];\n    }\n  }\n\n  // GPU Aggregation results are provided in Buffers, if new Buffer objects are created track them for later deletion.\n  /* eslint-disable max-depth */\n  _trackGPUResultBuffers(results, weights) {\n    const {resources} = this.state;\n    for (const id in results) {\n      if (results[id]) {\n        for (const bufferName of BUFFER_NAMES) {\n          if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {\n            // No result buffer is provided in weights object, `readPixelsToBuffer` has created a new Buffer object\n            // collect the new buffer for garabge collection\n            const name = `gpu-result-${id}-${bufferName}`;\n            if (resources[name]) {\n              resources[name].delete();\n            }\n            resources[name] = results[id][bufferName];\n          }\n        }\n      }\n    }\n  }\n  /* eslint-enable max-depth */\n\n  _updateModels(opts) {\n    const {vertexCount, attributes, numCol, numRow} = opts;\n    const {modelDirty} = this.state;\n\n    if (modelDirty) {\n      this._setupModels(opts);\n      this.setState({modelDirty: false});\n    }\n\n    // this maps color/elevation to weight name.\n    this._setupWeightAttributes(opts);\n\n    this.gridAggregationModel.setVertexCount(vertexCount);\n    this.gridAggregationModel.setAttributes(attributes);\n\n    this.allAggregationModel.setInstanceCount(numCol * numRow);\n  }\n}\n\n// HELPER METHODS\n\nfunction normalizeWeightParams(weights) {\n  const result = {};\n  for (const id in weights) {\n    result[id] = {...DEFAULT_WEIGHT_PARAMS, ...weights[id]};\n  }\n  return result;\n}\n\nfunction deleteResources(resources) {\n  resources = Array.isArray(resources) ? resources : [resources];\n  resources.forEach(obj => {\n    for (const name in obj) {\n      obj[name].delete();\n    }\n  });\n}\n\nfunction getAggregationModel(gl, shaderOptions) {\n  const shaders = mergeShaders(\n    {\n      vs: AGGREGATE_TO_GRID_VS,\n      fs: AGGREGATE_TO_GRID_FS,\n      modules: [fp64arithmetic, project32]\n    },\n    shaderOptions\n  );\n\n  return new Model(gl, {\n    id: 'Gird-Aggregation-Model',\n    vertexCount: 1,\n    drawMode: GL.POINTS,\n    ...shaders\n  });\n}\n\nfunction getAllAggregationModel(gl, instanceCount) {\n  return new Model(gl, {\n    id: 'All-Aggregation-Model',\n    vs: AGGREGATE_ALL_VS,\n    fs: AGGREGATE_ALL_FS,\n    modules: [fp64arithmetic],\n    vertexCount: 1,\n    drawMode: GL.POINTS,\n    isInstanced: true,\n    instanceCount,\n    attributes: {\n      position: [0, 0]\n    }\n  });\n}\n\nfunction getMeanTransform(gl, opts) {\n  return new Transform(gl, {\n    vs: TRANSFORM_MEAN_VS,\n    _targetTextureVarying: 'meanValues',\n    ...opts\n  });\n}\n","// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME gpu-aggregation-transform-mean-vs\nattribute vec4 aggregationValues;\nvarying vec4 meanValues;\n\nvoid main()\n{\n  // TODO: Use 64-bit division ?? not needed given this is aggregation ??\n  bool isCellValid = bool(aggregationValues.w > 0.);\n  // aggregationValues:  XYZ contain aggregated values, W contains count\n  meanValues.xyz = isCellValid ? aggregationValues.xyz/aggregationValues.w : vec3(0, 0, 0);\n  meanValues.w = aggregationValues.w;\n\n  // Enforce default value for ANGLE issue (https://bugs.chromium.org/p/angleproject/issues/detail?id=3941)\n  gl_PointSize = 1.0;\n}\n`;\n","// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME gpu-aggregation-to-grid-vs\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute vec3 weights;\nuniform vec2 cellSize;\nuniform vec2 gridSize;\nuniform bool projectPoints;\nuniform vec2 translation;\nuniform vec3 scaling;\n\nvarying vec3 vWeights;\n\nvec2 project_to_pixel(vec4 pos) {\n  vec4 result;\n  pos.xy = pos.xy/pos.w;\n  result = pos + vec4(translation, 0., 0.);\n  result.xy = scaling.z > 0. ? result.xy * scaling.xy : result.xy;\n  return result.xy;\n}\n\nvoid main(void) {\n\n  vWeights = weights;\n\n  vec4 windowPos = vec4(positions, 1.);\n  if (projectPoints) {\n    windowPos = project_position_to_clipspace(positions, positions64Low, vec3(0));\n  }\n\n  vec2 pos = project_to_pixel(windowPos);\n\n  vec2 pixelXY64[2];\n  pixelXY64[0] = vec2(pos.x, 0.);\n  pixelXY64[1] = vec2(pos.y, 0.);\n\n  // Transform (0,0):windowSize -> (0, 0): gridSize\n  vec2 gridXY64[2];\n  gridXY64[0] = div_fp64(pixelXY64[0], vec2(cellSize.x, 0));\n  gridXY64[1] = div_fp64(pixelXY64[1], vec2(cellSize.y, 0));\n  float x = floor(gridXY64[0].x);\n  float y = floor(gridXY64[1].x);\n  pos = vec2(x, y);\n\n  // Transform (0,0):gridSize -> (-1, -1):(1,1)\n  pos = (pos * (2., 2.) / (gridSize)) - (1., 1.);\n\n  // Move to pixel center, pixel-size in screen sapce (2/gridSize) * 0.5 => 1/gridSize\n  vec2 offset = 1.0 / gridSize;\n  pos = pos + offset;\n\n  gl_Position = vec4(pos, 0.0, 1.0);\n\n  // Enforce default value for ANGLE issue (https://bugs.chromium.org/p/angleproject/issues/detail?id=3941)\n  gl_PointSize = 1.0;\n}\n`;\n","// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME gpu-aggregation-to-grid-fs\n\nprecision highp float;\n\nvarying vec3 vWeights;\n\nvoid main(void) {\n  gl_FragColor = vec4(vWeights, 1.0);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n`;\n","// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-all-vs-64\n\nin vec2 position;\nuniform ivec2 gridSize;\nout vec2 vTextureCoord;\n\nvoid main(void) {\n  // Map each position to single pixel\n  vec2 pos = vec2(-1.0, -1.0);\n\n  // Move to pixel center, pixel-size in screen sapce (2/gridSize) * 0.5 => 1/gridSize\n  vec2 offset = 1.0 / vec2(gridSize);\n  pos = pos + offset;\n\n  gl_Position = vec4(pos, 0.0, 1.0);\n\n  int yIndex = gl_InstanceID / gridSize[0];\n  int xIndex = gl_InstanceID - (yIndex * gridSize[0]);\n\n  vec2 yIndexFP64 = vec2(float(yIndex), 0.);\n  vec2 xIndexFP64 = vec2(float(xIndex), 0.);\n  vec2 gridSizeYFP64 = vec2(gridSize[1], 0.);\n  vec2 gridSizeXFP64 = vec2(gridSize[0], 0.);\n\n  vec2 texCoordXFP64 = div_fp64(yIndexFP64, gridSizeYFP64);\n  vec2 texCoordYFP64 = div_fp64(xIndexFP64, gridSizeXFP64);\n\n  vTextureCoord = vec2(texCoordYFP64.x, texCoordXFP64.x);\n  // Enforce default value for ANGLE issue (https://bugs.chromium.org/p/angleproject/issues/detail?id=3941)\n  gl_PointSize = 1.0;\n}\n`;\n","// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-all-fs\n\nprecision highp float;\n\nin vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform bool combineMaxMin;\nout vec4 fragColor;\nvoid main(void) {\n  vec4 textureColor = texture(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));\n  if (textureColor.a == 0.) {\n    discard;\n  }\n  fragColor.rgb = textureColor.rgb;\n  // if combineMinMax is true, use Alpha channel for first weights min value.\n  fragColor.a = combineMaxMin ? textureColor.r : textureColor.a;\n}\n`;\n","import {log, COORDINATE_SYSTEM} from '@deck.gl/core';\nconst R_EARTH = 6378000;\n\nfunction toFinite(n) {\n  return Number.isFinite(n) ? n : 0;\n}\n\n// Parse input data to build positions, wights and bounding box.\n/* eslint-disable max-statements */\nexport function getBoundingBox(attributes, vertexCount) {\n  // TODO - value might not exist (e.g. attribute transition)\n  const positions = attributes.positions.value;\n\n  let yMin = Infinity;\n  let yMax = -Infinity;\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let y;\n  let x;\n\n  for (let i = 0; i < vertexCount; i++) {\n    x = positions[i * 3];\n    y = positions[i * 3 + 1];\n    yMin = y < yMin ? y : yMin;\n    yMax = y > yMax ? y : yMax;\n    xMin = x < xMin ? x : xMin;\n    xMax = x > xMax ? x : xMax;\n  }\n\n  const boundingBox = {\n    xMin: toFinite(xMin),\n    xMax: toFinite(xMax),\n    yMin: toFinite(yMin),\n    yMax: toFinite(yMax)\n  };\n\n  return boundingBox;\n}\n/* eslint-enable max-statements */\n\n// Returns XY translation for positions to peform aggregation in +ve sapce\nfunction getTranslation(boundingBox, gridOffset, coordinateSystem, viewport) {\n  const {width, height} = viewport;\n\n  // Origin to define grid\n  // DEFAULT coordinate system is treated as LNGLAT\n  const worldOrigin =\n    coordinateSystem === COORDINATE_SYSTEM.CARTESIAN ? [-width / 2, -height / 2] : [-180, -90];\n\n  // Other coordinate systems not supported/verified yet\n  log.assert(\n    coordinateSystem === COORDINATE_SYSTEM.CARTESIAN ||\n      coordinateSystem === COORDINATE_SYSTEM.LNGLAT ||\n      coordinateSystem === COORDINATE_SYSTEM.DEFAULT\n  );\n\n  const {xMin, yMin} = boundingBox;\n  return [\n    // Align origin to match grid cell boundaries in CPU and GPU aggregations\n    -1 * (alignToCell(xMin - worldOrigin[0], gridOffset.xOffset) + worldOrigin[0]),\n    -1 * (alignToCell(yMin - worldOrigin[1], gridOffset.yOffset) + worldOrigin[1])\n  ];\n}\n\n// Aligns `inValue` to given `cellSize`\nexport function alignToCell(inValue, cellSize) {\n  const sign = inValue < 0 ? -1 : 1;\n\n  let value = sign < 0 ? Math.abs(inValue) + cellSize : Math.abs(inValue);\n\n  value = Math.floor(value / cellSize) * cellSize;\n\n  return value * sign;\n}\n\n/**\n * Based on geometric center of sample points, calculate cellSize in lng/lat (degree) space\n * @param {object} boundingBox - {xMin, yMin, xMax, yMax} contains bounding box of data\n * @param {number} cellSize - grid cell size in meters\n * @param {boolean, optional} converToDegrees - when true offsets are converted from meters to lng/lat (degree) space\n * @returns {xOffset, yOffset} - cellSize size\n */\n\nexport function getGridOffset(boundingBox, cellSize, convertToMeters = true) {\n  if (!convertToMeters) {\n    return {xOffset: cellSize, yOffset: cellSize};\n  }\n\n  const {yMin, yMax} = boundingBox;\n  const centerLat = (yMin + yMax) / 2;\n\n  return calculateGridLatLonOffset(cellSize, centerLat);\n}\n\nexport function getGridParams(boundingBox, cellSize, viewport, coordinateSystem) {\n  const gridOffset = getGridOffset(\n    boundingBox,\n    cellSize,\n    coordinateSystem !== COORDINATE_SYSTEM.CARTESIAN\n  );\n\n  const translation = getTranslation(boundingBox, gridOffset, coordinateSystem, viewport);\n\n  const {xMin, yMin, xMax, yMax} = boundingBox;\n\n  const width = xMax - xMin + gridOffset.xOffset;\n  const height = yMax - yMin + gridOffset.yOffset;\n\n  const numCol = Math.ceil(width / gridOffset.xOffset);\n  const numRow = Math.ceil(height / gridOffset.yOffset);\n  return {gridOffset, translation, width, height, numCol, numRow};\n}\n\n/**\n * calculate grid layer cell size in lat lon based on world unit size\n * and current latitude\n * @param {number} cellSize\n * @param {number} latitude\n * @returns {object} - lat delta and lon delta\n */\nfunction calculateGridLatLonOffset(cellSize, latitude) {\n  const yOffset = calculateLatOffset(cellSize);\n  const xOffset = calculateLonOffset(latitude, cellSize);\n  return {yOffset, xOffset};\n}\n\n/**\n * with a given x-km change, calculate the increment of latitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} dy - change in km\n * @return {number} - increment in latitude\n */\nfunction calculateLatOffset(dy) {\n  return (dy / R_EARTH) * (180 / Math.PI);\n}\n\n/**\n * with a given x-km change, and current latitude\n * calculate the increment of longitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} lat - latitude of current location (based on city)\n * @param {number} dx - change in km\n * @return {number} - increment in longitude\n */\nfunction calculateLonOffset(lat, dx) {\n  return ((dx / R_EARTH) * (180 / Math.PI)) / Math.cos((lat * Math.PI) / 180);\n}\n","import GL from '@luma.gl/constants';\nimport {Framebuffer, Texture2D, isWebGL2} from '@luma.gl/core';\n\nconst DEFAULT_PARAMETERS = {\n  [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_MIN_FILTER]: GL.NEAREST\n};\n\nexport function getFloatTexture(gl, opts = {}) {\n  const {\n    width = 1,\n    height = 1,\n    data = null,\n    unpackFlipY = true,\n    parameters = DEFAULT_PARAMETERS\n  } = opts;\n  const texture = new Texture2D(gl, {\n    data,\n    format: isWebGL2(gl) ? GL.RGBA32F : GL.RGBA,\n    type: GL.FLOAT,\n    border: 0,\n    mipmaps: false,\n    parameters,\n    dataFormat: GL.RGBA,\n    width,\n    height,\n    unpackFlipY\n  });\n  return texture;\n}\n\nexport function getFramebuffer(gl, opts) {\n  const {id, width = 1, height = 1, texture} = opts;\n  const fb = new Framebuffer(gl, {\n    id,\n    width,\n    height,\n    attachments: {\n      [GL.COLOR_ATTACHMENT0]: texture\n    }\n  });\n\n  return fb;\n}\n\nexport function getFloatArray(array, size, fillValue = 0) {\n  if (!array || array.length < size) {\n    return new Float32Array(size).fill(fillValue);\n  }\n  return array;\n}\n"],"names":["fp64ify","a","out","arguments","length","undefined","startIndex","hiPart","Math","fround","loPart","CONST_UNIFORMS","ONE","fp64arithmetic","name","vs","fs","getUniforms","fp64LowPart","fp64ifyMatrix4","matrix","matrixFP64","Float32Array","i","j","index","pointToDensityGridDataCPU","props","aggregationParams","hashInfo","data","cellSize","attributes","viewport","projectPoints","numInstances","positions","value","size","getAccessor","boundingBox","positionAttribute","numInstance","y","x","yMin","Infinity","yMax","xMin","xMax","Number","isFinite","getPositionBoundingBox","offsets","posOffset","gridOffset","getGridOffset","xOffset","yOffset","gridHash","width","height","numCol","ceil","numRow","iterable","objectInfo","createIterable","position","Array","pt","project","yIndex","floor","xIndex","key","concat","count","points","lonIdx","latIdx","push","source","pointsToGridHashing","result","Object","keys","idxs","split","parseInt","getGridLayerDataFromGridHash","GridAggregationLayer","AggregationLayer","constructor","args","_defineProperty","initializeAggregationLayer","dimensions","gl","this","context","super","setState","layerData","gpuGridAggregator","GPUGridAggregator","id","cpuGridAggregator","updateState","opts","updateAggregationState","aggregationDataDirty","aggregationWeightsDirty","gpuAggregation","state","getNumInstances","aggregationDirty","_updateAggregation","_updateWeightBins","_uploadAggregationResults","finalizeState","_this$state$gpuGridAg","weights","aggregationBuffer","delete","updateShaders","shaders","log","assert","allocateResources","dataBytes","weight","Buffer","byteLength","accessor","type","divisor","updateResults","aggregationData","maxMinData","maxData","minData","translation","scaling","getAttributes","vertexCount","run","moduleSettings","getModuleSettings","getValue","sortedBins","BinSorter","aggregatedBins","minValue","maxValue","totalCount","fill","bin","counts","cellIndex","DEFAULT_RUN_PARAMS","createBufferObjects","MAX_32_BIT_FLOAT","MIN_BLEND_EQUATION","MAX_BLEND_EQUATION","MAX_MIN_BLEND_EQUATION","EQUATION_MAP","AGGREGATION_OPERATION","SUM","MEAN","MIN","MAX","DEFAULT_WEIGHT_PARAMS","operation","needMin","needMax","combineMaxMin","BUFFER_NAMES","ARRAY_BUFFER_MAP","REQUIRED_FEATURES","FEATURES","WEBGL2","COLOR_ATTACHMENT_RGBA32F","BLEND_EQUATION_MINMAX","FLOAT_BLEND","TEXTURE_FLOAT","getAggregationData","pixelIndex","results","cellCount","cellWeight","maxCellWieght","minCellWeight","getCellData","countsData","numCells","cellWeights","cellCounts","Uint32Array","sizeIndex","isSupported","hasFeatures","weightAttributes","textures","meanTextures","buffers","framebuffers","maxMinFramebuffers","minFramebuffers","maxFramebuffers","equations","resources","_hasGPUSupport","isWebGL2","_setupModels","gridAggregationModel","allAggregationModel","meanTransform","isArray","forEach","obj","deleteResources","_normalizeAggregationParams","_runAggregation","getData","weightId","arrayName","bufferName","shaderOptions","modelDirty","normalizeWeightParams","updateObject","assign","_getAggregateData","aggregationTexture","readPixelsToBuffer","target","sourceType","maxMinBuffer","maxMinTexture","minBuffer","minTexture","maxBuffer","maxTexture","_trackGPUResultBuffers","_renderAggregateData","gridSize","parameters","blend","depthTest","blendFunc","uniforms","_renderToWeightsTexture","_renderToMaxMinTexture","blendEquation","minOrMaxFb","clearParams","clearColor","withParameters","framebuffer","clear","draw","uSampler","texture","transformOptions","_sourceTextures","aggregationValues","_targetTexture","elementCount","update","Transform","_targetTextureVarying","getMeanTransform","attach","_updateModels","_setupFramebuffers","framebufferSize","getFloatTexture","resize","getFramebuffer","_getMinMaxTexture","_this$gridAggregation","mergeShaders","modules","project32","Model","drawMode","getAggregationModel","instanceCount","isInstanced","getAllAggregationModel","_setupWeightAttributes","setVertexCount","setAttributes","setInstanceCount","R_EARTH","toFinite","n","getBoundingBox","alignToCell","inValue","sign","abs","convertToMeters","latitude","lat","PI","cos","calculateGridLatLonOffset","getGridParams","coordinateSystem","COORDINATE_SYSTEM","CARTESIAN","worldOrigin","LNGLAT","DEFAULT","getTranslation","DEFAULT_PARAMETERS","unpackFlipY","Texture2D","format","border","mipmaps","dataFormat","Framebuffer","attachments"],"sourceRoot":""}