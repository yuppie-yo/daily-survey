{"version":3,"file":"64c6f7d3ee35da2509ee.chunk.js","mappings":"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","sources":["webpack://superset/../../../src/heatmap-layer/heatmap-layer-utils.ts","webpack://superset/../../../src/heatmap-layer/triangle-layer.ts","webpack://superset/../../../src/heatmap-layer/triangle-layer-vertex.glsl.ts","webpack://superset/../../../src/heatmap-layer/triangle-layer-fragment.glsl.ts","webpack://superset/../../../src/heatmap-layer/weights-vs.glsl.ts","webpack://superset/../../../src/heatmap-layer/heatmap-layer.ts","webpack://superset/../../../src/heatmap-layer/max-vs.glsl.ts","webpack://superset/../../../src/heatmap-layer/max-fs.glsl.ts","webpack://superset/../../../src/heatmap-layer/weights-fs.glsl.ts"],"sourcesContent":["import GL from '@luma.gl/constants';\nimport {isWebGL2} from '@luma.gl/core';\n\nexport function getBounds(points: number[][]): number[] {\n  // Now build bounding box in world space (aligned to world coordiante system)\n  const x = points.map(p => p[0]);\n  const y = points.map(p => p[1]);\n\n  const xMin = Math.min.apply(null, x);\n  const xMax = Math.max.apply(null, x);\n  const yMin = Math.min.apply(null, y);\n  const yMax = Math.max.apply(null, y);\n\n  return [xMin, yMin, xMax, yMax];\n}\n\n// true if currentBounds contains targetBounds, false otherwise\nexport function boundsContain(currentBounds: number[], targetBounds: number[]): boolean {\n  if (\n    targetBounds[0] >= currentBounds[0] &&\n    targetBounds[2] <= currentBounds[2] &&\n    targetBounds[1] >= currentBounds[1] &&\n    targetBounds[3] <= currentBounds[3]\n  ) {\n    return true;\n  }\n  return false;\n}\n\nconst scratchArray = new Float32Array(12);\n\n// For given rectangle bounds generates two triangles vertices that coverit completely\nexport function packVertices(points: number[][], dimensions: number = 2): Float32Array {\n  let index = 0;\n  for (const point of points) {\n    for (let i = 0; i < dimensions; i++) {\n      scratchArray[index++] = point[i] || 0;\n    }\n  }\n  return scratchArray;\n}\n\n// Expands boundingBox:[xMin, yMin, xMax, yMax] to match aspect ratio of given width and height\nexport function scaleToAspectRatio(boundingBox: number[], width: number, height: number): number[] {\n  const [xMin, yMin, xMax, yMax] = boundingBox;\n\n  const currentWidth = xMax - xMin;\n  const currentHeight = yMax - yMin;\n\n  let newWidth = currentWidth;\n  let newHeight = currentHeight;\n  if (currentWidth / currentHeight < width / height) {\n    // expand bounding box width\n    newWidth = (width / height) * currentHeight;\n  } else {\n    newHeight = (height / width) * currentWidth;\n  }\n\n  if (newWidth < width) {\n    newWidth = width;\n    newHeight = height;\n  }\n\n  const xCenter = (xMax + xMin) / 2;\n  const yCenter = (yMax + yMin) / 2;\n\n  return [\n    xCenter - newWidth / 2,\n    yCenter - newHeight / 2,\n    xCenter + newWidth / 2,\n    yCenter + newHeight / 2\n  ];\n}\n\n// Get texture coordiante of point inside a bounding box\nexport function getTextureCoordinates(point: number[], bounds: number[]) {\n  const [xMin, yMin, xMax, yMax] = bounds;\n  return [(point[0] - xMin) / (xMax - xMin), (point[1] - yMin) / (yMax - yMin)];\n}\n\n// Returns format and type for creating texture objects\nexport function getTextureParams({gl, floatTargetSupport}) {\n  return floatTargetSupport\n    ? {\n        // format:  should be RGBA32F on WebGL2 (float textures), RGBA in WebGL1 for float or non float textures\n        format: isWebGL2(gl) ? GL.RGBA32F : GL.RGBA,\n        type: GL.FLOAT\n      }\n    : {\n        format: GL.RGBA,\n        type: GL.UNSIGNED_BYTE\n      };\n}\n","// Copyright (c) 2015 - 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry, Texture2D} from '@luma.gl/core';\nimport {Layer, LayerContext, project32} from '@deck.gl/core';\nimport vs from './triangle-layer-vertex.glsl';\nimport fs from './triangle-layer-fragment.glsl';\n\ntype _TriangleLayerProps = {\n  colorDomain: number[];\n  aggregationMode: string;\n  threshold: number;\n  intensity: number;\n  vertexCount: number;\n  colorTexture: Texture2D;\n  maxTexture: Texture2D;\n  texture: Texture2D;\n};\n\nexport default class TriangleLayer extends Layer<_TriangleLayerProps> {\n  static layerName = 'TriangleLayer';\n\n  getShaders() {\n    return {vs, fs, modules: [project32]};\n  }\n\n  initializeState({gl}: LayerContext): void {\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      positions: {size: 3, noAlloc: true},\n      texCoords: {size: 2, noAlloc: true}\n    });\n    this.setState({\n      model: this._getModel(gl)\n    });\n  }\n\n  _getModel(gl: WebGLRenderingContext): Model {\n    const {vertexCount} = this.props;\n\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: GL.TRIANGLE_FAN,\n        vertexCount\n      })\n    });\n  }\n\n  draw({uniforms}): void {\n    const {model} = this.state;\n\n    const {texture, maxTexture, colorTexture, intensity, threshold, aggregationMode, colorDomain} =\n      this.props;\n\n    model\n      .setUniforms({\n        ...uniforms,\n        texture,\n        maxTexture,\n        colorTexture,\n        intensity,\n        threshold,\n        aggregationMode,\n        colorDomain\n      })\n      .draw();\n  }\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Inspired by screen-grid-layer vertex shader in deck.gl\n\nexport default `\\\n#define SHADER_NAME heatp-map-layer-vertex-shader\n\nuniform sampler2D maxTexture;\nuniform float intensity;\nuniform vec2 colorDomain;\nuniform float threshold;\nuniform float aggregationMode;\n\nattribute vec3 positions;\nattribute vec2 texCoords;\n\nvarying vec2 vTexCoords;\nvarying float vIntensityMin;\nvarying float vIntensityMax;\n\nvoid main(void) {\n  gl_Position = project_position_to_clipspace(positions, vec3(0.0), vec3(0.0));\n  vTexCoords = texCoords;\n  vec4 maxTexture = texture2D(maxTexture, vec2(0.5));\n  float maxValue = aggregationMode < 0.5 ? maxTexture.r : maxTexture.g;\n  float minValue = maxValue * threshold;\n  if (colorDomain[1] > 0.) {\n    // if user specified custom domain use it.\n    maxValue = colorDomain[1];\n    minValue = colorDomain[0];\n  }\n  vIntensityMax = intensity / maxValue;\n  vIntensityMin = intensity / minValue;\n}\n`;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME triangle-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D texture;\nuniform sampler2D colorTexture;\nuniform float aggregationMode;\n\nvarying vec2 vTexCoords;\nvarying float vIntensityMin;\nvarying float vIntensityMax;\n\nvec4 getLinearColor(float value) {\n  float factor = clamp(value * vIntensityMax, 0., 1.);\n  vec4 color = texture2D(colorTexture, vec2(factor, 0.5));\n  color.a *= min(value * vIntensityMin, 1.0);\n  return color;\n}\n\nvoid main(void) {\n  vec4 weights = texture2D(texture, vTexCoords);\n  float weight = weights.r;\n\n  if (aggregationMode > 0.5) {\n    weight /= max(1.0, weights.a);\n  }\n\n  // discard pixels with 0 weight.\n  if (weight <= 0.) {\n     discard;\n  }\n\n  vec4 linearColor = getLinearColor(weight);\n  linearColor.a *= opacity;\n  gl_FragColor =linearColor;\n}\n`;\n","export default `\\\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float weights;\nvarying vec4 weightsTexture;\nuniform float radiusPixels;\nuniform float textureWidth;\nuniform vec4 commonBounds;\nuniform float weightsScale;\nvoid main()\n{\n  weightsTexture = vec4(weights * weightsScale, 0., 0., 1.);\n\n  float radiusTexels  = project_pixel_size(radiusPixels) * textureWidth / (commonBounds.z - commonBounds.x);\n  gl_PointSize = radiusTexels * 2.;\n\n  vec3 commonPosition = project_position(positions, positions64Low);\n\n  // map xy from commonBounds to [-1, 1]\n  gl_Position.xy = (commonPosition.xy - commonBounds.xy) / (commonBounds.zw - commonBounds.xy) ;\n  gl_Position.xy = (gl_Position.xy * 2.) - (1.);\n}\n`;\n","// Copyright (c) 2015 - 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* global setTimeout clearTimeout */\nimport GL from '@luma.gl/constants';\nimport {\n  getBounds,\n  boundsContain,\n  packVertices,\n  scaleToAspectRatio,\n  getTextureCoordinates,\n  getTextureParams\n} from './heatmap-layer-utils';\nimport {\n  Buffer,\n  Texture2D,\n  Transform,\n  getParameters,\n  withParameters,\n  FEATURES,\n  hasFeatures\n} from '@luma.gl/core';\nimport {\n  Accessor,\n  AccessorFunction,\n  AttributeManager,\n  ChangeFlags,\n  Color,\n  COORDINATE_SYSTEM,\n  Layer,\n  LayerContext,\n  LayersList,\n  log,\n  Position,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\nimport TriangleLayer from './triangle-layer';\nimport AggregationLayer, {AggregationLayerProps} from '../aggregation-layer';\nimport {defaultColorRange, colorRangeToFlatArray} from '../utils/color-utils';\nimport weightsVs from './weights-vs.glsl';\nimport weightsFs from './weights-fs.glsl';\nimport vsMax from './max-vs.glsl';\nimport fsMax from './max-fs.glsl';\n\nconst RESOLUTION = 2; // (number of common space pixels) / (number texels)\nconst TEXTURE_OPTIONS = {\n  mipmaps: false,\n  parameters: {\n    [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n    [GL.TEXTURE_MIN_FILTER]: GL.LINEAR,\n    [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n    [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n  },\n  dataFormat: GL.RGBA\n};\nconst DEFAULT_COLOR_DOMAIN = [0, 0];\nconst AGGREGATION_MODE = {\n  SUM: 0,\n  MEAN: 1\n};\n\nconst defaultProps: DefaultProps<HeatmapLayerProps> = {\n  getPosition: {type: 'accessor', value: x => x.position},\n  getWeight: {type: 'accessor', value: 1},\n  intensity: {type: 'number', min: 0, value: 1},\n  radiusPixels: {type: 'number', min: 1, max: 100, value: 50},\n  colorRange: defaultColorRange,\n  threshold: {type: 'number', min: 0, max: 1, value: 0.05},\n  colorDomain: {type: 'array', value: null, optional: true},\n  // 'SUM' or 'MEAN'\n  aggregation: 'SUM',\n  weightsTextureSize: {type: 'number', min: 128, max: 2048, value: 2048},\n  debounceTimeout: {type: 'number', min: 0, max: 1000, value: 500}\n};\n\nconst REQUIRED_FEATURES = [\n  FEATURES.BLEND_EQUATION_MINMAX, // max weight calculation\n  FEATURES.TEXTURE_FLOAT // weight-map as texture\n];\n\nconst FLOAT_TARGET_FEATURES = [\n  FEATURES.COLOR_ATTACHMENT_RGBA32F, // ability to render to float texture\n  FEATURES.FLOAT_BLEND // ability to blend when rendering to float texture\n];\n\nconst DIMENSIONS = {\n  data: {\n    props: ['radiusPixels']\n  }\n};\n\nexport type HeatmapLayerProps<DataT = any> = _HeatmapLayerProps<DataT> &\n  AggregationLayerProps<DataT>;\n\ntype _HeatmapLayerProps<DataT> = {\n  /**\n   * Radius of the circle in pixels, to which the weight of an object is distributed.\n   *\n   * @default 30\n   */\n  radiusPixels?: number;\n\n  /**\n   * Specified as an array of colors [color1, color2, ...].\n   *\n   * @default `6-class YlOrRd` - [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6)\n   */\n  colorRange?: Color[];\n\n  /**\n   * Value that is multiplied with the total weight at a pixel to obtain the final weight.\n   *\n   * @default 1\n   */\n  intensity?: number;\n\n  /**\n   * Ratio of the fading weight to the max weight, between `0` and `1`.\n   *\n   * For example, `0.1` affects all pixels with weight under 10% of the max.\n   *\n   * Ignored when `colorDomain` is specified.\n   * @default 0.05\n   */\n  threshold?: number;\n\n  /**\n   * Controls how weight values are mapped to the `colorRange`, as an array of two numbers [`minValue`, `maxValue`].\n   *\n   * @default null\n   */\n  colorDomain?: [number, number] | null;\n\n  /**\n   * Defines the type of aggregation operation\n   *\n   * V valid values are 'SUM', 'MEAN'.\n   *\n   * @default 'SUM'\n   */\n  aggregation?: 'SUM' | 'MEAN';\n\n  /**\n   * Specifies the size of weight texture.\n   * @default 2048\n   */\n  weightsTextureSize?: number;\n\n  /**\n   * Interval in milliseconds during which changes to the viewport don't trigger aggregation.\n   *\n   * @default 500\n   */\n  debounceTimeout?: number;\n\n  /**\n   * Method called to retrieve the position of each object.\n   *\n   * @default d => d.position\n   */\n  getPosition?: AccessorFunction<DataT, Position>;\n\n  /**\n   * The weight of each object.\n   *\n   * @default 1\n   */\n  getWeight?: Accessor<DataT, number>;\n};\n\n/** Visualizes the spatial distribution of data. */\nexport default class HeatmapLayer<\n  DataT = any,\n  ExtraPropsT extends {} = {}\n> extends AggregationLayer<DataT, ExtraPropsT & Required<_HeatmapLayerProps<DataT>>> {\n  static layerName = 'HeatmapLayer';\n  static defaultProps = defaultProps;\n\n  state!: AggregationLayer<DataT>['state'] & {\n    supported: boolean;\n    colorDomain?: number[];\n    isWeightMapDirty?: boolean;\n    weightsTexture?: Texture2D;\n    zoom?: number;\n    worldBounds?: number[];\n    normalizedCommonBounds?: number[];\n    updateTimer?: any;\n    triPositionBuffer?: Buffer;\n    triTexCoordBuffer?: Buffer;\n  };\n\n  initializeState() {\n    const {gl} = this.context;\n    if (!hasFeatures(gl, REQUIRED_FEATURES)) {\n      this.setState({supported: false});\n      log.error(`HeatmapLayer: ${this.id} is not supported on this browser`)();\n      return;\n    }\n    super.initializeAggregationLayer(DIMENSIONS);\n    this.setState({supported: true, colorDomain: DEFAULT_COLOR_DOMAIN});\n    this._setupTextureParams();\n    this._setupAttributes();\n    this._setupResources();\n  }\n\n  shouldUpdateState({changeFlags}: UpdateParameters<this>) {\n    // Need to be updated when viewport changes\n    return changeFlags.somethingChanged;\n  }\n\n  /* eslint-disable max-statements,complexity */\n  updateState(opts: UpdateParameters<this>) {\n    if (!this.state.supported) {\n      return;\n    }\n    super.updateState(opts);\n    this._updateHeatmapState(opts);\n  }\n\n  _updateHeatmapState(opts: UpdateParameters<this>) {\n    const {props, oldProps} = opts;\n    const changeFlags = this._getChangeFlags(opts);\n\n    if (changeFlags.dataChanged || changeFlags.viewportChanged) {\n      // if data is changed, do not debounce and immediately update the weight map\n      changeFlags.boundsChanged = this._updateBounds(changeFlags.dataChanged);\n      this._updateTextureRenderingBounds();\n    }\n\n    if (changeFlags.dataChanged || changeFlags.boundsChanged) {\n      // Update weight map immediately\n      clearTimeout(this.state.updateTimer);\n      this.setState({isWeightMapDirty: true});\n    } else if (changeFlags.viewportZoomChanged) {\n      // Update weight map when zoom stops\n      this._debouncedUpdateWeightmap();\n    }\n\n    if (props.colorRange !== oldProps.colorRange) {\n      this._updateColorTexture(opts);\n    }\n\n    if (this.state.isWeightMapDirty) {\n      this._updateWeightmap();\n    }\n\n    this.setState({zoom: opts.context.viewport.zoom});\n  }\n\n  renderLayers(): LayersList | Layer {\n    if (!this.state.supported) {\n      return [];\n    }\n    const {\n      weightsTexture,\n      triPositionBuffer,\n      triTexCoordBuffer,\n      maxWeightsTexture,\n      colorTexture,\n      colorDomain\n    } = this.state;\n    const {updateTriggers, intensity, threshold, aggregation} = this.props;\n\n    const TriangleLayerClass = this.getSubLayerClass('triangle', TriangleLayer);\n\n    return new TriangleLayerClass(\n      this.getSubLayerProps({\n        id: 'triangle-layer',\n        updateTriggers\n      }),\n      {\n        // position buffer is filled with world coordinates generated from viewport.unproject\n        // i.e. LNGLAT if geospatial, CARTESIAN otherwise\n        coordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n        data: {\n          attributes: {\n            positions: triPositionBuffer,\n            texCoords: triTexCoordBuffer\n          }\n        },\n        vertexCount: 4,\n        maxTexture: maxWeightsTexture,\n        colorTexture,\n        aggregationMode: AGGREGATION_MODE[aggregation] || 0,\n        texture: weightsTexture,\n        intensity,\n        threshold,\n        colorDomain\n      }\n    );\n  }\n\n  finalizeState(context: LayerContext) {\n    super.finalizeState(context);\n    const {\n      weightsTransform,\n      weightsTexture,\n      maxWeightTransform,\n      maxWeightsTexture,\n      triPositionBuffer,\n      triTexCoordBuffer,\n      colorTexture,\n      updateTimer\n    } = this.state;\n    weightsTransform?.delete();\n    weightsTexture?.delete();\n    maxWeightTransform?.delete();\n    maxWeightsTexture?.delete();\n    triPositionBuffer?.delete();\n    triTexCoordBuffer?.delete();\n    colorTexture?.delete();\n    if (updateTimer) {\n      clearTimeout(updateTimer);\n    }\n  }\n\n  // PRIVATE\n\n  // override Composite layer private method to create AttributeManager instance\n  _getAttributeManager() {\n    return new AttributeManager(this.context.gl, {\n      id: this.props.id,\n      stats: this.context.stats\n    });\n  }\n\n  _getChangeFlags(opts: UpdateParameters<this>) {\n    const changeFlags: Partial<ChangeFlags> & {\n      boundsChanged?: boolean;\n      viewportZoomChanged?: boolean;\n    } = {};\n    const {dimensions} = this.state;\n    changeFlags.dataChanged =\n      this.isAttributeChanged() || // if any attribute is changed\n      this.isAggregationDirty(opts, {\n        compareAll: true,\n        dimension: dimensions.data\n      });\n    changeFlags.viewportChanged = opts.changeFlags.viewportChanged;\n\n    const {zoom} = this.state;\n    if (!opts.context.viewport || opts.context.viewport.zoom !== zoom) {\n      changeFlags.viewportZoomChanged = true;\n    }\n\n    return changeFlags;\n  }\n\n  _createTextures() {\n    const {gl} = this.context;\n    const {textureSize, format, type} = this.state;\n\n    this.setState({\n      weightsTexture: new Texture2D(gl, {\n        width: textureSize,\n        height: textureSize,\n        format,\n        type,\n        ...TEXTURE_OPTIONS\n      }),\n      maxWeightsTexture: new Texture2D(gl, {format, type, ...TEXTURE_OPTIONS}) // 1 X 1 texture,\n    });\n  }\n\n  _setupAttributes() {\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      positions: {size: 3, type: GL.DOUBLE, accessor: 'getPosition'},\n      weights: {size: 1, accessor: 'getWeight'}\n    });\n    this.setState({positionAttributeName: 'positions'});\n  }\n\n  _setupTextureParams() {\n    const {gl} = this.context;\n    const {weightsTextureSize} = this.props;\n\n    const textureSize = Math.min(weightsTextureSize, getParameters(gl, gl.MAX_TEXTURE_SIZE));\n    const floatTargetSupport = hasFeatures(gl, FLOAT_TARGET_FEATURES);\n    const {format, type} = getTextureParams({gl, floatTargetSupport});\n    const weightsScale = floatTargetSupport ? 1 : 1 / 255;\n    this.setState({textureSize, format, type, weightsScale});\n    if (!floatTargetSupport) {\n      log.warn(\n        `HeatmapLayer: ${this.id} rendering to float texture not supported, fallingback to low precession format`\n      )();\n    }\n  }\n\n  getShaders(type) {\n    return super.getShaders(\n      type === 'max-weights-transform'\n        ? {\n            vs: vsMax,\n            _fs: fsMax\n          }\n        : {\n            vs: weightsVs,\n            _fs: weightsFs\n          }\n    );\n  }\n\n  _createWeightsTransform(shaders = {}) {\n    const {gl} = this.context;\n    let {weightsTransform} = this.state;\n    const {weightsTexture} = this.state;\n    weightsTransform?.delete();\n\n    weightsTransform = new Transform(gl, {\n      id: `${this.id}-weights-transform`,\n      elementCount: 1,\n      _targetTexture: weightsTexture,\n      _targetTextureVarying: 'weightsTexture',\n      ...shaders\n    });\n    this.setState({weightsTransform});\n  }\n\n  _setupResources() {\n    const {gl} = this.context;\n    this._createTextures();\n    const {textureSize, weightsTexture, maxWeightsTexture} = this.state;\n\n    const weightsTransformShaders = this.getShaders('weights-transform');\n    this._createWeightsTransform(weightsTransformShaders);\n\n    const maxWeightsTransformShaders = this.getShaders('max-weights-transform');\n    const maxWeightTransform = new Transform(gl, {\n      id: `${this.id}-max-weights-transform`,\n      _sourceTextures: {\n        inTexture: weightsTexture\n      },\n      _targetTexture: maxWeightsTexture,\n      _targetTextureVarying: 'outTexture',\n      ...maxWeightsTransformShaders,\n      elementCount: textureSize * textureSize\n    });\n\n    this.setState({\n      weightsTexture,\n      maxWeightsTexture,\n      maxWeightTransform,\n      zoom: null,\n      triPositionBuffer: new Buffer(gl, {\n        byteLength: 48,\n        accessor: {size: 3}\n      }),\n      triTexCoordBuffer: new Buffer(gl, {\n        byteLength: 48,\n        accessor: {size: 2}\n      })\n    });\n  }\n\n  // overwrite super class method to update transform model\n  updateShaders(shaderOptions) {\n    // sahder params (modules, injects) changed, update model object\n    this._createWeightsTransform(shaderOptions);\n  }\n\n  _updateMaxWeightValue() {\n    const {maxWeightTransform} = this.state;\n    maxWeightTransform.run({\n      parameters: {\n        blend: true,\n        depthTest: false,\n        blendFunc: [GL.ONE, GL.ONE],\n        blendEquation: GL.MAX\n      }\n    });\n  }\n\n  // Computes world bounds area that needs to be processed for generate heatmap\n  _updateBounds(forceUpdate: any = false): boolean {\n    const {viewport} = this.context;\n\n    // Unproject all 4 corners of the current screen coordinates into world coordinates (lng/lat)\n    // Takes care of viewport has non zero bearing/pitch (i.e axis not aligned with world coordiante system)\n    const viewportCorners = [\n      viewport.unproject([0, 0]),\n      viewport.unproject([viewport.width, 0]),\n      viewport.unproject([viewport.width, viewport.height]),\n      viewport.unproject([0, viewport.height])\n    ].map(p => p.map(Math.fround));\n\n    // #1: get world bounds for current viewport extends\n    const visibleWorldBounds = getBounds(viewportCorners); // TODO: Change to visible bounds\n\n    const newState: Partial<HeatmapLayer['state']> = {visibleWorldBounds, viewportCorners};\n    let boundsChanged = false;\n\n    if (\n      forceUpdate ||\n      !this.state.worldBounds ||\n      !boundsContain(this.state.worldBounds, visibleWorldBounds)\n    ) {\n      // #2 : convert world bounds to common (Flat) bounds\n      // #3 : extend common bounds to match aspect ratio with viewport\n      const scaledCommonBounds = this._worldToCommonBounds(visibleWorldBounds);\n\n      // #4 :convert aligned common bounds to world bounds\n      const worldBounds = this._commonToWorldBounds(scaledCommonBounds);\n\n      // Clip webmercator projection limits\n      if (this.props.coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n        worldBounds[1] = Math.max(worldBounds[1], -85.051129);\n        worldBounds[3] = Math.min(worldBounds[3], 85.051129);\n        worldBounds[0] = Math.max(worldBounds[0], -360);\n        worldBounds[2] = Math.min(worldBounds[2], 360);\n      }\n\n      // #5: now convert world bounds to common using Layer's coordiante system and origin\n      const normalizedCommonBounds = this._worldToCommonBounds(worldBounds);\n\n      newState.worldBounds = worldBounds;\n      newState.normalizedCommonBounds = normalizedCommonBounds;\n\n      boundsChanged = true;\n    }\n    this.setState(newState);\n    return boundsChanged;\n  }\n\n  _updateTextureRenderingBounds() {\n    // Just render visible portion of the texture\n    const {triPositionBuffer, triTexCoordBuffer, normalizedCommonBounds, viewportCorners} =\n      this.state;\n\n    const {viewport} = this.context;\n\n    triPositionBuffer.subData(packVertices(viewportCorners, 3));\n\n    const textureBounds = viewportCorners.map(p =>\n      getTextureCoordinates(viewport.projectPosition(p), normalizedCommonBounds!)\n    );\n    triTexCoordBuffer.subData(packVertices(textureBounds, 2));\n  }\n\n  _updateColorTexture(opts) {\n    const {colorRange} = opts.props;\n    let {colorTexture} = this.state;\n    const colors = colorRangeToFlatArray(colorRange, false, Uint8Array as any);\n\n    if (colorTexture) {\n      colorTexture.setImageData({\n        data: colors,\n        width: colorRange.length\n      });\n    } else {\n      colorTexture = new Texture2D(this.context.gl, {\n        data: colors,\n        width: colorRange.length,\n        height: 1,\n        ...TEXTURE_OPTIONS\n      });\n    }\n    this.setState({colorTexture});\n  }\n\n  _updateWeightmap() {\n    const {radiusPixels, colorDomain, aggregation} = this.props;\n    const {weightsTransform, worldBounds, textureSize, weightsTexture, weightsScale} = this.state;\n    this.state.isWeightMapDirty = false;\n\n    // convert world bounds to common using Layer's coordiante system and origin\n    const commonBounds = this._worldToCommonBounds(worldBounds, {\n      useLayerCoordinateSystem: true\n    });\n\n    if (colorDomain && aggregation === 'SUM') {\n      // scale color domain to weight per pixel\n      const {viewport} = this.context;\n      const metersPerPixel =\n        (viewport.distanceScales.metersPerUnit[2] * (commonBounds[2] - commonBounds[0])) /\n        textureSize;\n      this.state.colorDomain = colorDomain.map(x => x * metersPerPixel * weightsScale);\n    } else {\n      this.state.colorDomain = colorDomain || DEFAULT_COLOR_DOMAIN;\n    }\n\n    const uniforms = {\n      radiusPixels,\n      commonBounds,\n      textureWidth: textureSize,\n      weightsScale\n    };\n    // Attribute manager sets data array count as instaceCount on model\n    // we need to set that as elementCount on 'weightsTransform'\n    weightsTransform.update({\n      elementCount: this.getNumInstances()\n    });\n    // Need to explictly specify clearColor as external context may have modified it\n    withParameters(this.context.gl, {clearColor: [0, 0, 0, 0]}, () => {\n      weightsTransform.run({\n        uniforms,\n        parameters: {\n          blend: true,\n          depthTest: false,\n          blendFunc: [GL.ONE, GL.ONE],\n          blendEquation: GL.FUNC_ADD\n        },\n        clearRenderTarget: true,\n        attributes: this.getAttributes(),\n        moduleSettings: this.getModuleSettings()\n      });\n    });\n    this._updateMaxWeightValue();\n\n    // reset filtering parameters (TODO: remove once luma issue#1193 is fixed)\n    weightsTexture.setParameters({\n      [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n      [GL.TEXTURE_MIN_FILTER]: GL.LINEAR\n    });\n  }\n\n  _debouncedUpdateWeightmap(fromTimer = false) {\n    let {updateTimer} = this.state;\n    const {debounceTimeout} = this.props;\n\n    if (fromTimer) {\n      updateTimer = null;\n      // update\n      this._updateBounds(true);\n      this._updateTextureRenderingBounds();\n      this.setState({isWeightMapDirty: true});\n    } else {\n      this.setState({isWeightMapDirty: false});\n      clearTimeout(updateTimer);\n      updateTimer = setTimeout(this._debouncedUpdateWeightmap.bind(this, true), debounceTimeout);\n    }\n\n    this.setState({updateTimer});\n  }\n\n  // input: worldBounds: [minLong, minLat, maxLong, maxLat]\n  // input: opts.useLayerCoordinateSystem : layers coordiante system is used\n  // optput: commonBounds: [minX, minY, maxX, maxY] scaled to fit the current texture\n  _worldToCommonBounds(worldBounds, opts: {useLayerCoordinateSystem?: boolean} = {}) {\n    const {useLayerCoordinateSystem = false} = opts;\n    const [minLong, minLat, maxLong, maxLat] = worldBounds;\n    const {viewport} = this.context;\n    const {textureSize} = this.state;\n    const {coordinateSystem} = this.props;\n\n    const offsetMode =\n      useLayerCoordinateSystem &&\n      (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS ||\n        coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS);\n    const offsetOriginCommon = offsetMode\n      ? viewport.projectPosition(this.props.coordinateOrigin)\n      : [0, 0];\n    const size = (textureSize * RESOLUTION) / viewport.scale;\n\n    let bottomLeftCommon;\n    let topRightCommon;\n\n    // Y-axis is flipped between World and Common bounds\n    if (useLayerCoordinateSystem && !offsetMode) {\n      bottomLeftCommon = this.projectPosition([minLong, minLat, 0]);\n      topRightCommon = this.projectPosition([maxLong, maxLat, 0]);\n    } else {\n      bottomLeftCommon = viewport.projectPosition([minLong, minLat, 0]);\n      topRightCommon = viewport.projectPosition([maxLong, maxLat, 0]);\n    }\n    // Ignore z component\n    return scaleToAspectRatio(\n      [\n        bottomLeftCommon[0] - offsetOriginCommon[0],\n        bottomLeftCommon[1] - offsetOriginCommon[1],\n        topRightCommon[0] - offsetOriginCommon[0],\n        topRightCommon[1] - offsetOriginCommon[1]\n      ],\n      size,\n      size\n    );\n  }\n\n  // input commonBounds: [xMin, yMin, xMax, yMax]\n  // output worldBounds: [minLong, minLat, maxLong, maxLat]\n  _commonToWorldBounds(commonBounds) {\n    const [xMin, yMin, xMax, yMax] = commonBounds;\n    const {viewport} = this.context;\n    const bottomLeftWorld = viewport.unprojectPosition([xMin, yMin]);\n    const topRightWorld = viewport.unprojectPosition([xMax, yMax]);\n\n    return bottomLeftWorld.slice(0, 2).concat(topRightWorld.slice(0, 2));\n  }\n}\n","export default `\\\nattribute vec4 inTexture;\nvarying vec4 outTexture;\n\nvoid main()\n{\noutTexture = inTexture;\ngl_Position = vec4(0, 0, 0, 1.);\n// Enforce default value for ANGLE issue (https://bugs.chromium.org/p/angleproject/issues/detail?id=3941)\ngl_PointSize = 1.0;\n}\n`;\n","export default `\\\nvarying vec4 outTexture;\nvoid main() {\n  gl_FragColor = outTexture;\n  gl_FragColor.g = outTexture.r / max(1.0, outTexture.a);\n}\n`;\n","export default `\\\nvarying vec4 weightsTexture;\n// Epanechnikov function, keeping for reference\n// float epanechnikovKDE(float u) {\n//   return 0.75 * (1.0 - u * u);\n// }\nfloat gaussianKDE(float u){\n  return pow(2.71828, -u*u/0.05555)/(1.77245385*0.166666);\n}\nvoid main()\n{\n  float dist = length(gl_PointCoord - vec2(0.5, 0.5));\n  if (dist > 0.5) {\n    discard;\n  }\n  gl_FragColor = weightsTexture * gaussianKDE(2. * dist);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n`;\n"],"names":["scratchArray","Float32Array","packVertices","points","dimensions","index","point","i","TriangleLayer","Layer","getShaders","vs","fs","modules","project32","initializeState","gl","this","getAttributeManager","add","positions","size","noAlloc","texCoords","setState","model","_getModel","vertexCount","props","Model","id","geometry","Geometry","drawMode","draw","uniforms","state","texture","maxTexture","colorTexture","intensity","threshold","aggregationMode","colorDomain","setUniforms","TEXTURE_OPTIONS","mipmaps","parameters","dataFormat","DEFAULT_COLOR_DOMAIN","AGGREGATION_MODE","SUM","MEAN","defaultProps","getPosition","type","value","x","position","getWeight","min","radiusPixels","max","colorRange","defaultColorRange","optional","aggregation","weightsTextureSize","debounceTimeout","REQUIRED_FEATURES","FEATURES","BLEND_EQUATION_MINMAX","TEXTURE_FLOAT","FLOAT_TARGET_FEATURES","COLOR_ATTACHMENT_RGBA32F","FLOAT_BLEND","DIMENSIONS","data","HeatmapLayer","AggregationLayer","constructor","args","_defineProperty","context","hasFeatures","supported","log","error","concat","super","initializeAggregationLayer","_setupTextureParams","_setupAttributes","_setupResources","shouldUpdateState","changeFlags","somethingChanged","updateState","opts","_updateHeatmapState","oldProps","_getChangeFlags","dataChanged","viewportChanged","boundsChanged","_updateBounds","_updateTextureRenderingBounds","clearTimeout","updateTimer","isWeightMapDirty","viewportZoomChanged","_debouncedUpdateWeightmap","_updateColorTexture","_updateWeightmap","zoom","viewport","renderLayers","weightsTexture","triPositionBuffer","triTexCoordBuffer","maxWeightsTexture","updateTriggers","getSubLayerClass","getSubLayerProps","coordinateSystem","COORDINATE_SYSTEM","DEFAULT","attributes","finalizeState","weightsTransform","maxWeightTransform","delete","_getAttributeManager","AttributeManager","stats","isAttributeChanged","isAggregationDirty","compareAll","dimension","_createTextures","textureSize","format","Texture2D","width","height","accessor","weights","positionAttributeName","Math","getParameters","floatTargetSupport","isWebGL2","getTextureParams","weightsScale","warn","_fs","_createWeightsTransform","shaders","_weightsTransform","Transform","elementCount","_targetTexture","_targetTextureVarying","weightsTransformShaders","maxWeightsTransformShaders","_sourceTextures","inTexture","Buffer","byteLength","updateShaders","shaderOptions","_updateMaxWeightValue","run","blend","depthTest","blendFunc","blendEquation","forceUpdate","viewportCorners","unproject","map","p","fround","visibleWorldBounds","y","xMin","apply","xMax","getBounds","newState","worldBounds","currentBounds","targetBounds","scaledCommonBounds","_worldToCommonBounds","_commonToWorldBounds","LNGLAT","normalizedCommonBounds","subData","textureBounds","bounds","yMin","yMax","getTextureCoordinates","projectPosition","colors","colorRangeToFlatArray","Uint8Array","setImageData","length","commonBounds","useLayerCoordinateSystem","metersPerPixel","distanceScales","metersPerUnit","textureWidth","update","getNumInstances","withParameters","clearColor","clearRenderTarget","getAttributes","moduleSettings","getModuleSettings","setParameters","fromTimer","setTimeout","bind","minLong","minLat","maxLong","maxLat","offsetMode","LNGLAT_OFFSETS","METER_OFFSETS","offsetOriginCommon","coordinateOrigin","scale","bottomLeftCommon","topRightCommon","boundingBox","currentWidth","currentHeight","newWidth","newHeight","xCenter","yCenter","scaleToAspectRatio","bottomLeftWorld","unprojectPosition","topRightWorld","slice"],"sourceRoot":""}