"use strict";(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[4276],{579543:(e,t,i)=>{i.d(t,{K:()=>n,P:()=>o});const n=[[255,255,178],[254,217,118],[254,178,76],[253,141,60],[240,59,32],[189,0,38]];function o(e,t=!1,i=Float32Array){let n;if(Number.isFinite(e[0]))n=new i(e);else{n=new i(4*e.length);let t=0;for(let i=0;i<e.length;i++){const o=e[i];n[t++]=o[0],n[t++]=o[1],n[t++]=o[2],n[t++]=Number.isFinite(o[3])?o[3]:255}}if(t)for(let e=0;e<n.length;e++)n[e]/=255;return n}},311959:(e,t,i)=>{i.d(t,{Z:()=>g});var n=i(489713),o=i(833312),s=i(844059);function a(){}const r=["getBins","getDomain","getScaleFunc"],l=[{key:"fillColor",accessor:"getFillColor",pickingInfo:"colorValue",getBins:{triggers:{value:{prop:"getColorValue",updateTrigger:"getColorValue"},weight:{prop:"getColorWeight",updateTrigger:"getColorWeight"},aggregation:{prop:"colorAggregation"},filterData:{prop:"_filterData",updateTrigger:"_filterData"}}},getDomain:{triggers:{lowerPercentile:{prop:"lowerPercentile"},upperPercentile:{prop:"upperPercentile"},scaleType:{prop:"colorScaleType"}}},getScaleFunc:{triggers:{domain:{prop:"colorDomain"},range:{prop:"colorRange"}},onSet:{props:"onSetColorDomain"}},nullValue:[0,0,0,0]},{key:"elevation",accessor:"getElevation",pickingInfo:"elevationValue",getBins:{triggers:{value:{prop:"getElevationValue",updateTrigger:"getElevationValue"},weight:{prop:"getElevationWeight",updateTrigger:"getElevationWeight"},aggregation:{prop:"elevationAggregation"},filterData:{prop:"_filterData",updateTrigger:"_filterData"}}},getDomain:{triggers:{lowerPercentile:{prop:"elevationLowerPercentile"},upperPercentile:{prop:"elevationUpperPercentile"},scaleType:{prop:"elevationScaleType"}}},getScaleFunc:{triggers:{domain:{prop:"elevationDomain"},range:{prop:"elevationRange"}},onSet:{props:"onSetElevationDomain"}},nullValue:-1}],d=e=>e.cellSize;class g{constructor(e){this.state={layerData:{},dimensions:{}},this.changeFlags={},this.dimensionUpdaters={},this._getCellSize=e.getCellSize||d,this._getAggregator=e.getAggregator,this._addDimension(e.dimensions||l)}static defaultDimensions(){return l}updateState(e,t){const{oldProps:i,props:n,changeFlags:o}=e;this.updateGetValueFuncs(i,n,o);const s=this.needsReProjectPoints(i,n,o);let a=!1;return o.dataChanged||s?(this.getAggregatedData(n,t),a=!0):((this.getDimensionChanges(i,n,o)||[]).forEach((e=>"function"==typeof e&&e())),a=!0),this.setState({aggregationDirty:a}),this.state}setState(e){this.state={...this.state,...e}}setDimensionState(e,t){this.setState({dimensions:{...this.state.dimensions,[e]:{...this.state.dimensions[e],...t}}})}normalizeResult(e={}){return e.hexagons?{data:e.hexagons,...e}:e.layerData?{data:e.layerData,...e}:e}getAggregatedData(e,t){const i=this._getAggregator(e)(e,t);this.setState({layerData:this.normalizeResult(i)}),this.changeFlags={layerData:!0},this.getSortedBins(e)}updateGetValueFuncs(e,t,i){for(const n in this.dimensionUpdaters){const{value:o,weight:a,aggregation:r}=this.dimensionUpdaters[n].getBins.triggers;let l=t[o.prop];this.needUpdateDimensionStep(this.dimensionUpdaters[n].getBins,e,t,i)&&(l=l?(0,s.q5)(l,{data:t.data}):(0,s._D)(t[r.prop],t[a.prop],{data:t.data})),l&&this.setDimensionState(n,{getValue:l})}}needsReProjectPoints(e,t,i){return this._getCellSize(e)!==this._getCellSize(t)||this._getAggregator(e)!==this._getAggregator(t)||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getPosition)}addDimension(e){this._addDimension(e)}_addDimension(e=[]){e.forEach((e=>{const{key:t}=e;this.dimensionUpdaters[t]=this.getDimensionUpdaters(e),this.state.dimensions[t]={getValue:null,domain:null,sortedBins:null,scaleFunc:a}}))}getDimensionUpdaters({key:e,accessor:t,pickingInfo:i,getBins:n,getDomain:o,getScaleFunc:s,nullValue:a}){return{key:e,accessor:t,pickingInfo:i,getBins:{updater:this.getDimensionSortedBins,...n},getDomain:{updater:this.getDimensionValueDomain,...o},getScaleFunc:{updater:this.getDimensionScale,...s},attributeAccessor:this.getSubLayerDimensionAttribute(e,a)}}needUpdateDimensionStep(e,t,i,n){return Object.values(e.triggers).some((e=>e.updateTrigger?n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged[e.updateTrigger]):t[e.prop]!==i[e.prop]))}getDimensionChanges(e,t,i){const n=[];for(const o in this.dimensionUpdaters){const s=r.find((n=>this.needUpdateDimensionStep(this.dimensionUpdaters[o][n],e,t,i)));s&&n.push(this.dimensionUpdaters[o][s].updater.bind(this,t,this.dimensionUpdaters[o]))}return n.length?n:null}getUpdateTriggers(e){const t=e.updateTriggers||{},i={};for(const n in this.dimensionUpdaters){const{accessor:o}=this.dimensionUpdaters[n];i[o]={},r.forEach((s=>{Object.values(this.dimensionUpdaters[n][s].triggers).forEach((({prop:n,updateTrigger:s})=>{if(s){const e=t[s];"object"!=typeof e||Array.isArray(e)?void 0!==e&&(i[o][n]=e):Object.assign(i[o],e)}else i[o][n]=e[n]}))}))}return i}getSortedBins(e){for(const t in this.dimensionUpdaters)this.getDimensionSortedBins(e,this.dimensionUpdaters[t])}getDimensionSortedBins(e,t){const{key:i}=t,{getValue:o}=this.state.dimensions[i],s=new n.Z(this.state.layerData.data||[],{getValue:o,filterData:e._filterData});this.setDimensionState(i,{sortedBins:s}),this.getDimensionValueDomain(e,t)}getDimensionValueDomain(e,t){const{getDomain:i,key:n}=t,{triggers:{lowerPercentile:o,upperPercentile:s,scaleType:a}}=i,r=this.state.dimensions[n].sortedBins.getValueDomainByScale(e[a.prop],[e[o.prop],e[s.prop]]);this.setDimensionState(n,{valueDomain:r}),this.getDimensionScale(e,t)}getDimensionScale(e,t){const{key:i,getScaleFunc:n,getDomain:s}=t,{domain:a,range:r}=n.triggers,{scaleType:l}=s.triggers,{onSet:d}=n,g=e[r.prop],c=e[a.prop]||this.state.dimensions[i].valueDomain,p=(0,o.ge)(l&&e[l.prop])(c,g);"object"==typeof d&&"function"==typeof e[d.props]&&e[d.props](p.domain()),this.setDimensionState(i,{scaleFunc:p})}getSubLayerDimensionAttribute(e,t){return i=>{const{sortedBins:n,scaleFunc:o}=this.state.dimensions[e],s=n.binMap[i.index];if(s&&0===s.counts)return t;const a=s&&s.value,r=o.domain();return a>=r[0]&&a<=r[r.length-1]?o(a):t}}getSubLayerAccessors(e){const t={};for(const i in this.dimensionUpdaters){const{accessor:n}=this.dimensionUpdaters[i];t[n]=this.getSubLayerDimensionAttribute(e,i)}return t}getPickingInfo({info:e}){let t=null;if(e.picked&&e.index>-1){const i=this.state.layerData.data[e.index],n={};for(const e in this.dimensionUpdaters){const{pickingInfo:t}=this.dimensionUpdaters[e],{sortedBins:o}=this.state.dimensions[e],s=o.binMap[i.index]&&o.binMap[i.index].value;n[t]=s}t=Object.assign(n,i,{points:i.filteredPoints||i.points})}return e.picked=Boolean(t),e.object=t,e}getAccessor(e){return this.dimensionUpdaters.hasOwnProperty(e)?this.dimensionUpdaters[e].attributeAccessor:a}}},643444:(e,t,i)=>{i.d(t,{Z:()=>D});var n=i(204942),o=i(905259),s=i(537832),a=i(295644),r=i(113717),l=i(733321),d=i(739450),g=i(844211),c=i(106948),p=i(339769),u=i(541576),h=i(453982),m=i(574538),f=i(25215);class v extends h.Z{constructor(e){const{id:t=(0,m.hQ)("column-geometry")}=e,{indices:i,attributes:n}=function(e){const{radius:t,height:i=1,nradial:n=10}=e;let{vertices:o}=e;o&&(u.Z.assert(o.length>=n),o=o.flatMap((e=>[e[0],e[1]])),(0,f.Ny)(o,f.wG.COUNTER_CLOCKWISE));const s=i>0,a=n+1,r=s?3*a+1:n,l=2*Math.PI/n,d=new Uint16Array(s?3*n*2:0),g=new Float32Array(3*r),c=new Float32Array(3*r);let p=0;if(s){for(let e=0;e<a;e++){const s=e*l,a=e%n,r=Math.sin(s),d=Math.cos(s);for(let e=0;e<2;e++)g[p+0]=o?o[2*a]:d*t,g[p+1]=o?o[2*a+1]:r*t,g[p+2]=(.5-e)*i,c[p+0]=o?o[2*a]:d,c[p+1]=o?o[2*a+1]:r,p+=3}g[p+0]=g[p-3],g[p+1]=g[p-2],g[p+2]=g[p-1],p+=3}for(let e=s?0:1;e<a;e++){const s=Math.floor(e/2)*Math.sign(.5-e%2),a=s*l,r=(s+n)%n,d=Math.sin(a),u=Math.cos(a);g[p+0]=o?o[2*r]:u*t,g[p+1]=o?o[2*r+1]:d*t,g[p+2]=i/2,c[p+2]=1,p+=3}if(s){let e=0;for(let t=0;t<n;t++)d[e++]=2*t+0,d[e++]=2*t+2,d[e++]=2*t+0,d[e++]=2*t+1,d[e++]=2*t+1,d[e++]=2*t+3}return{indices:d,attributes:{POSITION:{size:3,value:g},NORMAL:{size:3,value:c}}}}(e);super({...e,id:t,indices:i,attributes:n})}}const S=[0,0,0,255],y={diskResolution:{type:"number",min:4,value:20},vertices:null,radius:{type:"number",min:0,value:1e3},angle:{type:"number",value:0},offset:{type:"array",value:[0,0]},coverage:{type:"number",min:0,max:1,value:1},elevationScale:{type:"number",min:0,value:1},radiusUnits:"meters",lineWidthUnits:"meters",lineWidthScale:1,lineWidthMinPixels:0,lineWidthMaxPixels:Number.MAX_SAFE_INTEGER,extruded:!0,wireframe:!1,filled:!0,stroked:!1,getPosition:{type:"accessor",value:e=>e.position},getFillColor:{type:"accessor",value:S},getLineColor:{type:"accessor",value:S},getLineWidth:{type:"accessor",value:1},getElevation:{type:"accessor",value:1e3},material:!0,getColor:{deprecatedFor:["getFillColor","getLineColor"]}};class D extends o.Z{getShaders(){const{gl:e}=this.context,t=!(0,d.D0)(e),i={},n=this.props.flatShading&&(0,g.U6)(e,c.h.GLSL_DERIVATIVES);return n&&(i.FLAT_SHADING=1),super.getShaders({vs:"#version 300 es\n\n#define SHADER_NAME column-layer-vertex-shader\n\nin vec3 positions;\nin vec3 normals;\n\nin vec3 instancePositions;\nin float instanceElevations;\nin vec3 instancePositions64Low;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\nin float instanceStrokeWidths;\n\nin vec3 instancePickingColors;\nuniform float opacity;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\nuniform bool extruded;\nuniform bool stroked;\nuniform bool isStroke;\nuniform float coverage;\nuniform float elevationScale;\nuniform float edgeDistance;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform int radiusUnits;\nuniform int widthUnits;\nout vec4 vColor;\n#ifdef FLAT_SHADING\nout vec4 position_commonspace;\n#endif\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n\n  vec4 color = isStroke ? instanceLineColors : instanceFillColors;\n  mat2 rotationMatrix = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n  float elevation = 0.0;\n  float strokeOffsetRatio = 1.0;\n\n  if (extruded) {\n    elevation = instanceElevations * (positions.z + 1.0) / 2.0 * elevationScale;\n  } else if (stroked) {\n    float widthPixels = clamp(\n      project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n      widthMinPixels, widthMaxPixels) / 2.0;\n    float halfOffset = project_pixel_size(widthPixels) / project_size(edgeDistance * coverage * radius);\n    if (isStroke) {\n      strokeOffsetRatio -= sign(positions.z) * halfOffset;\n    } else {\n      strokeOffsetRatio -= halfOffset;\n    }\n  }\n  float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);\n  float dotRadius = radius * coverage * shouldRender;\n\n  geometry.pickingColor = instancePickingColors;\n  vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);\n  vec3 centroidPosition64Low = instancePositions64Low;\n  vec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + offset) * dotRadius;\n  if (radiusUnits == UNIT_METERS) {\n    offset = project_size(offset);\n  }\n  vec3 pos = vec3(offset, 0.);\n  DECKGL_FILTER_SIZE(pos, geometry);\n\n  gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);\n  geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  if (extruded && !isStroke) {\n#ifdef FLAT_SHADING\n    position_commonspace = geometry.position;\n    vColor = vec4(color.rgb, color.a * opacity);\n#else\n    vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\n    vColor = vec4(lightColor, color.a * opacity);\n#endif\n  } else {\n    vColor = vec4(color.rgb, color.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME column-layer-fragment-shader\n\nprecision highp float;\n\nuniform vec3 project_uCameraPosition;\nuniform bool extruded;\nuniform bool isStroke;\n\nout vec4 fragColor;\n\nin vec4 vColor;\n#ifdef FLAT_SHADING\nin vec4 position_commonspace;\n#endif\n\nvoid main(void) {\n  fragColor = vColor;\n#ifdef FLAT_SHADING\n  if (extruded && !isStroke && !picking_uActive) {\n    vec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n    fragColor.rgb = lighting_getLightColor(vColor.rgb, project_uCameraPosition, position_commonspace.xyz, normal);\n  }\n#endif\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",defines:i,transpileToGLSL100:t,modules:[s.Z,n?a.s:a.N,r.Z]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceElevations:{size:1,transition:!0,accessor:"getElevation"},instanceFillColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getFillColor",defaultValue:S},instanceLineColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getLineColor",defaultValue:S},instanceStrokeWidths:{size:1,accessor:"getLineWidth",transition:!0}})}updateState(e){super.updateState(e);const{props:t,oldProps:i,changeFlags:n}=e,o=n.extensionsChanged||t.flatShading!==i.flatShading;if(o){var s;const{gl:e}=this.context;null===(s=this.state.model)||void 0===s||s.delete(),this.state.model=this._getModel(e),this.getAttributeManager().invalidateAll()}(o||t.diskResolution!==i.diskResolution||t.vertices!==i.vertices||(t.extruded||t.stroked)!==(i.extruded||i.stroked))&&this._updateGeometry(t)}getGeometry(e,t,i){const n=new v({radius:1,height:i?2:0,vertices:t,nradial:e});let o=0;if(t)for(let i=0;i<e;i++){const n=t[i];o+=Math.sqrt(n[0]*n[0]+n[1]*n[1])/e}else o=1;return this.setState({edgeDistance:Math.cos(Math.PI/e)*o}),n}_getModel(e){return new p.Z(e,{...this.getShaders(),id:this.props.id,isInstanced:!0})}_updateGeometry({diskResolution:e,vertices:t,extruded:i,stroked:n}){const o=this.getGeometry(e,t,i||n);this.setState({fillVertexCount:o.attributes.POSITION.value.length/3,wireframeVertexCount:o.indices.value.length}),this.state.model.setProps({geometry:o})}draw({uniforms:e}){const{lineWidthUnits:t,lineWidthScale:i,lineWidthMinPixels:n,lineWidthMaxPixels:o,radiusUnits:s,elevationScale:a,extruded:r,filled:d,stroked:g,wireframe:c,offset:p,coverage:u,radius:h,angle:m}=this.props,{model:f,fillVertexCount:v,wireframeVertexCount:S,edgeDistance:y}=this.state;f.setUniforms(e).setUniforms({radius:h,angle:m/180*Math.PI,offset:p,extruded:r,stroked:g,coverage:u,elevationScale:a,edgeDistance:y,radiusUnits:l.iI[s],widthUnits:l.iI[t],widthScale:i,widthMinPixels:n,widthMaxPixels:o}),r&&c&&(f.setProps({isIndexed:!0}),f.setVertexCount(S).setDrawMode(1).setUniforms({isStroke:!0}).draw()),d&&(f.setProps({isIndexed:!1}),f.setVertexCount(v).setDrawMode(5).setUniforms({isStroke:!1}).draw()),!r&&g&&(f.setProps({isIndexed:!1}),f.setVertexCount(2*v/3).setDrawMode(5).setUniforms({isStroke:!0}).draw())}}(0,n.Z)(D,"layerName","ColumnLayer"),(0,n.Z)(D,"defaultProps",y)}}]);
//# sourceMappingURL=e8ba275aac71f10a04c8.chunk.js.map