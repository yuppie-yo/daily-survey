{"version":3,"file":"183a09a8f92b4b383894.chunk.js","mappings":"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","sources":["webpack://superset/./node_modules/@math.gl/polygon/dist/esm/polygon-utils.js","webpack://superset/./node_modules/@math.gl/polygon/dist/esm/lineclip.js","webpack://superset/./node_modules/@math.gl/polygon/dist/esm/utils.js","webpack://superset/./node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js","webpack://superset/./node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js","webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js","webpack://superset/../../../../src/shaderlib/picking/picking.ts"],"sourcesContent":["import { equals } from '@math.gl/core';\nexport const WINDING = {\n  CLOCKWISE: 1,\n  COUNTER_CLOCKWISE: -1\n};\nexport function modifyPolygonWindingDirection(points, direction, options = {}) {\n  const windingDirection = getPolygonWindingDirection(points, options);\n\n  if (windingDirection !== direction) {\n    reversePolygon(points, options);\n    return true;\n  }\n\n  return false;\n}\nexport function getPolygonWindingDirection(points, options = {}) {\n  return Math.sign(getPolygonSignedArea(points, options));\n}\nexport function getPolygonSignedArea(points, options = {}) {\n  const {\n    start = 0,\n    end = points.length\n  } = options;\n  const dim = options.size || 2;\n  let area = 0;\n\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    area += (points[i] - points[j]) * (points[i + 1] + points[j + 1]);\n    j = i;\n  }\n\n  return area / 2;\n}\nexport function forEachSegmentInPolygon(points, visitor, options = {}) {\n  const {\n    start = 0,\n    end = points.length,\n    size = 2,\n    isClosed\n  } = options;\n  const numPoints = (end - start) / size;\n\n  for (let i = 0; i < numPoints - 1; ++i) {\n    visitor(points[start + i * size], points[start + i * size + 1], points[start + (i + 1) * size], points[start + (i + 1) * size + 1], i, i + 1);\n  }\n\n  const endPointIndex = start + (numPoints - 1) * size;\n  const isClosedEx = isClosed || equals(points[start], points[endPointIndex]) && equals(points[start + 1], points[endPointIndex + 1]);\n\n  if (!isClosedEx) {\n    visitor(points[endPointIndex], points[endPointIndex + 1], points[start], points[start + 1], numPoints - 1, 0);\n  }\n}\n\nfunction reversePolygon(points, options) {\n  const {\n    start = 0,\n    end = points.length,\n    size = 2\n  } = options;\n  const numPoints = (end - start) / size;\n  const numSwaps = Math.floor(numPoints / 2);\n\n  for (let i = 0; i < numSwaps; ++i) {\n    const b1 = start + i * size;\n    const b2 = start + (numPoints - 1 - i) * size;\n\n    for (let j = 0; j < size; ++j) {\n      const tmp = points[b1 + j];\n      points[b1 + j] = points[b2 + j];\n      points[b2 + j] = tmp;\n    }\n  }\n}\n\nexport function modifyPolygonWindingDirectionPoints(points, direction, options = {}) {\n  const currentDirection = getPolygonWindingDirectionPoints(points, options);\n\n  if (currentDirection !== direction) {\n    points.reverse();\n    return true;\n  }\n\n  return false;\n}\nexport function getPolygonWindingDirectionPoints(points, options = {}) {\n  return Math.sign(getPolygonSignedAreaPoints(points, options));\n}\nexport function getPolygonSignedAreaPoints(points, options = {}) {\n  const {\n    start = 0,\n    end = points.length\n  } = options;\n  let area = 0;\n\n  for (let i = start, j = end - 1; i < end; ++i) {\n    area += (points[i][0] - points[j][0]) * (points[i][1] + points[j][1]);\n    j = i;\n  }\n\n  return area / 2;\n}\nexport function forEachSegmentInPolygonPoints(points, visitor, options = {}) {\n  const {\n    start = 0,\n    end = points.length,\n    isClosed\n  } = options;\n\n  for (let i = start; i < end - 1; ++i) {\n    visitor(points[i], points[i + 1], i, i + 1);\n  }\n\n  const isClosedEx = isClosed || equals(points[end - 1], points[0]);\n\n  if (!isClosedEx) {\n    visitor(points[end - 1], points[0], end - 1, 0);\n  }\n}\n//# sourceMappingURL=polygon-utils.js.map","import { push, copy, getPointAtIndex } from './utils';\nexport function clipPolyline(positions, bbox, options) {\n  const {\n    size = 2,\n    startIndex = 0,\n    endIndex = positions.length\n  } = options || {};\n  const numPoints = (endIndex - startIndex) / size;\n  const result = [];\n  let part = [];\n  let a;\n  let b;\n  let codeA = -1;\n  let codeB;\n  let lastCode;\n\n  for (let i = 1; i < numPoints; i++) {\n    a = getPointAtIndex(positions, i - 1, size, startIndex, a);\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n\n    if (codeA < 0) {\n      codeA = bitCode(a, bbox);\n    }\n\n    codeB = lastCode = bitCode(b, bbox);\n\n    while (true) {\n      if (!(codeA | codeB)) {\n        push(part, a);\n\n        if (codeB !== lastCode) {\n          push(part, b);\n\n          if (i < numPoints - 1) {\n            result.push(part);\n            part = [];\n          }\n        } else if (i === numPoints - 1) {\n          push(part, b);\n        }\n\n        break;\n      } else if (codeA & codeB) {\n        break;\n      } else if (codeA) {\n        intersect(a, b, codeA, bbox, a);\n        codeA = bitCode(a, bbox);\n      } else {\n        intersect(a, b, codeB, bbox, b);\n        codeB = bitCode(b, bbox);\n      }\n    }\n\n    codeA = lastCode;\n  }\n\n  if (part.length) result.push(part);\n  return result;\n}\nexport function clipPolygon(positions, bbox, options) {\n  const {\n    size = 2,\n    endIndex = positions.length\n  } = options || {};\n  let {\n    startIndex = 0\n  } = options || {};\n  let numPoints = (endIndex - startIndex) / size;\n  let result;\n  let p;\n  let prev;\n  let inside;\n  let prevInside;\n\n  for (let edge = 1; edge <= 8; edge *= 2) {\n    result = [];\n    prev = getPointAtIndex(positions, numPoints - 1, size, startIndex, prev);\n    prevInside = !(bitCode(prev, bbox) & edge);\n\n    for (let i = 0; i < numPoints; i++) {\n      p = getPointAtIndex(positions, i, size, startIndex, p);\n      inside = !(bitCode(p, bbox) & edge);\n      if (inside !== prevInside) push(result, intersect(prev, p, edge, bbox));\n      if (inside) push(result, p);\n      copy(prev, p);\n      prevInside = inside;\n    }\n\n    positions = result;\n    startIndex = 0;\n    numPoints = result.length / size;\n    if (!numPoints) break;\n  }\n\n  return result;\n}\nexport function intersect(a, b, edge, bbox, out = []) {\n  let t;\n  let snap;\n\n  if (edge & 8) {\n    t = (bbox[3] - a[1]) / (b[1] - a[1]);\n    snap = 3;\n  } else if (edge & 4) {\n    t = (bbox[1] - a[1]) / (b[1] - a[1]);\n    snap = 1;\n  } else if (edge & 2) {\n    t = (bbox[2] - a[0]) / (b[0] - a[0]);\n    snap = 2;\n  } else if (edge & 1) {\n    t = (bbox[0] - a[0]) / (b[0] - a[0]);\n    snap = 0;\n  } else {\n    return null;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    out[i] = (snap & 1) === i ? bbox[snap] : t * (b[i] - a[i]) + a[i];\n  }\n\n  return out;\n}\nexport function bitCode(p, bbox) {\n  let code = 0;\n  if (p[0] < bbox[0]) code |= 1;else if (p[0] > bbox[2]) code |= 2;\n  if (p[1] < bbox[1]) code |= 4;else if (p[1] > bbox[3]) code |= 8;\n  return code;\n}\n//# sourceMappingURL=lineclip.js.map","export function push(target, source) {\n  const size = source.length;\n  const startIndex = target.length;\n\n  if (startIndex > 0) {\n    let isDuplicate = true;\n\n    for (let i = 0; i < size; i++) {\n      if (target[startIndex - size + i] !== source[i]) {\n        isDuplicate = false;\n        break;\n      }\n    }\n\n    if (isDuplicate) {\n      return false;\n    }\n  }\n\n  for (let i = 0; i < size; i++) {\n    target[startIndex + i] = source[i];\n  }\n\n  return true;\n}\nexport function copy(target, source) {\n  const size = source.length;\n\n  for (let i = 0; i < size; i++) {\n    target[i] = source[i];\n  }\n}\nexport function getPointAtIndex(positions, index, size, offset, out = []) {\n  const startI = offset + index * size;\n\n  for (let i = 0; i < size; i++) {\n    out[i] = positions[startI + i];\n  }\n\n  return out;\n}\n//# sourceMappingURL=utils.js.map","import { bitCode, intersect } from './lineclip';\nimport { getPointAtIndex, copy, push } from './utils';\nexport function cutPolylineByGrid(positions, options) {\n  const {\n    size = 2,\n    broken = false,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    startIndex = 0,\n    endIndex = positions.length\n  } = options || {};\n  const numPoints = (endIndex - startIndex) / size;\n  let part = [];\n  const result = [part];\n  const a = getPointAtIndex(positions, 0, size, startIndex);\n  let b;\n  let codeB;\n  const cell = getGridCell(a, gridResolution, gridOffset, []);\n  const scratchPoint = [];\n  push(part, a);\n\n  for (let i = 1; i < numPoints; i++) {\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n    codeB = bitCode(b, cell);\n\n    while (codeB) {\n      intersect(a, b, codeB, cell, scratchPoint);\n      const codeAlt = bitCode(scratchPoint, cell);\n\n      if (codeAlt) {\n        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);\n        codeB = codeAlt;\n      }\n\n      push(part, scratchPoint);\n      copy(a, scratchPoint);\n      moveToNeighborCell(cell, gridResolution, codeB);\n\n      if (broken && part.length > size) {\n        part = [];\n        result.push(part);\n        push(part, a);\n      }\n\n      codeB = bitCode(b, cell);\n    }\n\n    push(part, b);\n    copy(a, b);\n  }\n\n  return broken ? result : result[0];\n}\nconst TYPE_INSIDE = 0;\nconst TYPE_BORDER = 1;\n\nfunction concatInPlace(arr1, arr2) {\n  for (let i = 0; i < arr2.length; i++) {\n    arr1.push(arr2[i]);\n  }\n\n  return arr1;\n}\n\nexport function cutPolygonByGrid(positions, holeIndices = null, options) {\n  if (!positions.length) {\n    return [];\n  }\n\n  const {\n    size = 2,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    edgeTypes = false\n  } = options || {};\n  const result = [];\n  const queue = [{\n    pos: positions,\n    types: edgeTypes ? new Array(positions.length / size).fill(TYPE_BORDER) : null,\n    holes: holeIndices || []\n  }];\n  const bbox = [[], []];\n  let cell = [];\n\n  while (queue.length) {\n    const {\n      pos,\n      types,\n      holes\n    } = queue.shift();\n    getBoundingBox(pos, size, holes[0] || pos.length, bbox);\n    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);\n    const code = bitCode(bbox[1], cell);\n\n    if (code) {\n      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);\n      const polygonLow = {\n        pos: parts[0].pos,\n        types: parts[0].types,\n        holes: []\n      };\n      const polygonHigh = {\n        pos: parts[1].pos,\n        types: parts[1].types,\n        holes: []\n      };\n      queue.push(polygonLow, polygonHigh);\n\n      for (let i = 0; i < holes.length; i++) {\n        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);\n\n        if (parts[0]) {\n          polygonLow.holes.push(polygonLow.pos.length);\n          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);\n\n          if (edgeTypes) {\n            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);\n          }\n        }\n\n        if (parts[1]) {\n          polygonHigh.holes.push(polygonHigh.pos.length);\n          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);\n\n          if (edgeTypes) {\n            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);\n          }\n        }\n      }\n    } else {\n      const polygon = {\n        positions: pos\n      };\n\n      if (edgeTypes) {\n        polygon.edgeTypes = types;\n      }\n\n      if (holes.length) {\n        polygon.holeIndices = holes;\n      }\n\n      result.push(polygon);\n    }\n  }\n\n  return result;\n}\n\nfunction bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {\n  const numPoints = (endIndex - startIndex) / size;\n  const resultLow = [];\n  const resultHigh = [];\n  const typesLow = [];\n  const typesHigh = [];\n  const scratchPoint = [];\n  let p;\n  let side;\n  let type;\n  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);\n  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);\n  let prevType = edgeTypes && edgeTypes[numPoints - 1];\n  let lowPointCount = 0;\n  let highPointCount = 0;\n\n  for (let i = 0; i < numPoints; i++) {\n    p = getPointAtIndex(positions, i, size, startIndex, p);\n    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);\n    type = edgeTypes && edgeTypes[startIndex / size + i];\n\n    if (side && prevSide && prevSide !== side) {\n      intersect(prev, p, edge, bbox, scratchPoint);\n      push(resultLow, scratchPoint) && typesLow.push(prevType);\n      push(resultHigh, scratchPoint) && typesHigh.push(prevType);\n    }\n\n    if (side <= 0) {\n      push(resultLow, p) && typesLow.push(type);\n      lowPointCount -= side;\n    } else if (typesLow.length) {\n      typesLow[typesLow.length - 1] = TYPE_INSIDE;\n    }\n\n    if (side >= 0) {\n      push(resultHigh, p) && typesHigh.push(type);\n      highPointCount += side;\n    } else if (typesHigh.length) {\n      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;\n    }\n\n    copy(prev, p);\n    prevSide = side;\n    prevType = type;\n  }\n\n  return [lowPointCount ? {\n    pos: resultLow,\n    types: edgeTypes && typesLow\n  } : null, highPointCount ? {\n    pos: resultHigh,\n    types: edgeTypes && typesHigh\n  } : null];\n}\n\nfunction getGridCell(p, gridResolution, gridOffset, out) {\n  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];\n  const bottom = Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];\n  out[0] = left;\n  out[1] = bottom;\n  out[2] = left + gridResolution;\n  out[3] = bottom + gridResolution;\n  return out;\n}\n\nfunction moveToNeighborCell(cell, gridResolution, edge) {\n  if (edge & 8) {\n    cell[1] += gridResolution;\n    cell[3] += gridResolution;\n  } else if (edge & 4) {\n    cell[1] -= gridResolution;\n    cell[3] -= gridResolution;\n  } else if (edge & 2) {\n    cell[0] += gridResolution;\n    cell[2] += gridResolution;\n  } else if (edge & 1) {\n    cell[0] -= gridResolution;\n    cell[2] -= gridResolution;\n  }\n}\n\nfunction getBoundingBox(positions, size, endIndex, out) {\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  for (let i = 0; i < endIndex; i += size) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    minX = x < minX ? x : minX;\n    maxX = x > maxX ? x : maxX;\n    minY = y < minY ? y : minY;\n    maxY = y > maxY ? y : maxY;\n  }\n\n  out[0][0] = minX;\n  out[0][1] = minY;\n  out[1][0] = maxX;\n  out[1][1] = maxY;\n  return out;\n}\n//# sourceMappingURL=cut-by-grid.js.map","import { cutPolylineByGrid, cutPolygonByGrid } from './cut-by-grid';\nimport { getPointAtIndex, push } from './utils';\nconst DEFAULT_MAX_LATITUDE = 85.051129;\nexport function cutPolylineByMercatorBounds(positions, options) {\n  const {\n    size = 2,\n    startIndex = 0,\n    endIndex = positions.length,\n    normalize = true\n  } = options || {};\n  const newPositions = positions.slice(startIndex, endIndex);\n  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);\n  const parts = cutPolylineByGrid(newPositions, {\n    size,\n    broken: true,\n    gridResolution: 360,\n    gridOffset: [-180, -180]\n  });\n\n  if (normalize) {\n    for (const part of parts) {\n      shiftLongitudesIntoRange(part, size);\n    }\n  }\n\n  return parts;\n}\nexport function cutPolygonByMercatorBounds(positions, holeIndices = null, options) {\n  const {\n    size = 2,\n    normalize = true,\n    edgeTypes = false\n  } = options || {};\n  holeIndices = holeIndices || [];\n  const newPositions = [];\n  const newHoleIndices = [];\n  let srcStartIndex = 0;\n  let targetIndex = 0;\n\n  for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {\n    const srcEndIndex = holeIndices[ringIndex] || positions.length;\n    const targetStartIndex = targetIndex;\n    const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);\n\n    for (let i = splitIndex; i < srcEndIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n\n    for (let i = srcStartIndex; i < splitIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n\n    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);\n    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options === null || options === void 0 ? void 0 : options.maxLatitude);\n    srcStartIndex = srcEndIndex;\n    newHoleIndices[ringIndex] = targetIndex;\n  }\n\n  newHoleIndices.pop();\n  const parts = cutPolygonByGrid(newPositions, newHoleIndices, {\n    size,\n    gridResolution: 360,\n    gridOffset: [-180, -180],\n    edgeTypes\n  });\n\n  if (normalize) {\n    for (const part of parts) {\n      shiftLongitudesIntoRange(part.positions, size);\n    }\n  }\n\n  return parts;\n}\n\nfunction findSplitIndex(positions, size, startIndex, endIndex) {\n  let maxLat = -1;\n  let pointIndex = -1;\n\n  for (let i = startIndex + 1; i < endIndex; i += size) {\n    const lat = Math.abs(positions[i]);\n\n    if (lat > maxLat) {\n      maxLat = lat;\n      pointIndex = i - 1;\n    }\n  }\n\n  return pointIndex;\n}\n\nfunction insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {\n  const firstLng = positions[startIndex];\n  const lastLng = positions[endIndex - size];\n\n  if (Math.abs(firstLng - lastLng) > 180) {\n    const p = getPointAtIndex(positions, 0, size, startIndex);\n    p[0] += Math.round((lastLng - firstLng) / 360) * 360;\n    push(positions, p);\n    p[1] = Math.sign(p[1]) * maxLatitude;\n    push(positions, p);\n    p[0] = firstLng;\n    push(positions, p);\n  }\n}\n\nfunction wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {\n  let prevLng = positions[0];\n  let lng;\n\n  for (let i = startIndex; i < endIndex; i += size) {\n    lng = positions[i];\n    const delta = lng - prevLng;\n\n    if (delta > 180 || delta < -180) {\n      lng -= Math.round(delta / 360) * 360;\n    }\n\n    positions[i] = prevLng = lng;\n  }\n}\n\nfunction shiftLongitudesIntoRange(positions, size) {\n  let refLng;\n  const pointCount = positions.length / size;\n\n  for (let i = 0; i < pointCount; i++) {\n    refLng = positions[i * size];\n\n    if ((refLng + 180) % 360 !== 0) {\n      break;\n    }\n  }\n\n  const delta = -Math.round(refLng / 360) * 360;\n\n  if (delta === 0) {\n    return;\n  }\n\n  for (let i = 0; i < pointCount; i++) {\n    positions[i * size] += delta;\n  }\n}\n//# sourceMappingURL=cut-by-mercator-bounds.js.map","const DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);\nconst DEFAULT_MODULE_OPTIONS = {\n  pickingSelectedColor: null,\n  pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR,\n  pickingActive: false,\n  pickingAttribute: false\n};\n\nfunction getUniforms() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;\n  const uniforms = {};\n\n  if (opts.pickingSelectedColor !== undefined) {\n    if (!opts.pickingSelectedColor) {\n      uniforms.picking_uSelectedColorValid = 0;\n    } else {\n      const selectedColor = opts.pickingSelectedColor.slice(0, 3);\n      uniforms.picking_uSelectedColorValid = 1;\n      uniforms.picking_uSelectedColor = selectedColor;\n    }\n  }\n\n  if (opts.pickingHighlightColor) {\n    const color = Array.from(opts.pickingHighlightColor, x => x / 255);\n\n    if (!Number.isFinite(color[3])) {\n      color[3] = 1;\n    }\n\n    uniforms.picking_uHighlightColor = color;\n  }\n\n  if (opts.pickingActive !== undefined) {\n    uniforms.picking_uActive = Boolean(opts.pickingActive);\n    uniforms.picking_uAttribute = Boolean(opts.pickingAttribute);\n  }\n\n  return uniforms;\n}\n\nconst vs = \"uniform bool picking_uActive;\\nuniform bool picking_uAttribute;\\nuniform vec3 picking_uSelectedColor;\\nuniform bool picking_uSelectedColorValid;\\n\\nout vec4 picking_vRGBcolor_Avalid;\\n\\nconst float COLOR_SCALE = 1. / 255.;\\n\\nbool picking_isColorValid(vec3 color) {\\n  return dot(color, vec3(1.0)) > 0.001;\\n}\\n\\nbool isVertexPicked(vec3 vertexColor) {\\n  return\\n    picking_uSelectedColorValid &&\\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\\n}\\n\\nvoid picking_setPickingColor(vec3 pickingColor) {\\n  if (picking_uActive) {\\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\\n\\n    if (!picking_uAttribute) {\\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\\n    }\\n  } else {\\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\\n  }\\n}\\n\\nvoid picking_setPickingAttribute(float value) {\\n  if (picking_uAttribute) {\\n    picking_vRGBcolor_Avalid.r = value;\\n  }\\n}\\nvoid picking_setPickingAttribute(vec2 value) {\\n  if (picking_uAttribute) {\\n    picking_vRGBcolor_Avalid.rg = value;\\n  }\\n}\\nvoid picking_setPickingAttribute(vec3 value) {\\n  if (picking_uAttribute) {\\n    picking_vRGBcolor_Avalid.rgb = value;\\n  }\\n}\\n\";\nconst fs = \"uniform bool picking_uActive;\\nuniform vec3 picking_uSelectedColor;\\nuniform vec4 picking_uHighlightColor;\\n\\nin vec4 picking_vRGBcolor_Avalid;\\nvec4 picking_filterHighlightColor(vec4 color) {\\n  if (picking_uActive) {\\n    return color;\\n  }\\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\\n\\n  if (selected) {\\n    float highLightAlpha = picking_uHighlightColor.a;\\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\\n    float highLightRatio = highLightAlpha / blendedAlpha;\\n\\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\\n    return vec4(blendedRGB, blendedAlpha);\\n  } else {\\n    return color;\\n  }\\n}\\nvec4 picking_filterPickingColor(vec4 color) {\\n  if (picking_uActive) {\\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\\n      discard;\\n    }\\n    return picking_vRGBcolor_Avalid;\\n  }\\n  return color;\\n}\\nvec4 picking_filterColor(vec4 color) {\\n  vec4 highightColor = picking_filterHighlightColor(color);\\n  return picking_filterPickingColor(highightColor);\\n}\\n\\n\";\nexport const picking = {\n  name: 'picking',\n  vs,\n  fs,\n  getUniforms\n};\n//# sourceMappingURL=picking.js.map","import {picking} from '@luma.gl/core';\nimport type {ShaderModule} from '../../types/types';\n\ntype PickingModuleSettings = {\n  /** Set to a picking color to visually highlight that item */\n  pickingSelectedColor?: [number, number, number] | null;\n  /** Color of the highlight */\n  pickingHighlightColor?: [number, number, number, number];\n  /** Set to true when rendering to off-screen \"picking\" buffer */\n  pickingActive?: boolean;\n  /** Set to true when picking an attribute value instead of object index */\n  pickingAttribute?: boolean;\n};\n\nexport default {\n  inject: {\n    'vs:DECKGL_FILTER_GL_POSITION': `\n    // for picking depth values\n    picking_setPickingAttribute(position.z / position.w);\n  `,\n    'vs:DECKGL_FILTER_COLOR': `\n  picking_setPickingColor(geometry.pickingColor);\n  `,\n    // TODO - this should be declared in the luma module\n    'fs:#decl': `\nuniform bool picking_uAttribute;\n  `,\n    'fs:DECKGL_FILTER_COLOR': {\n      order: 99,\n      injection: `\n  // use highlight color if this fragment belongs to the selected object.\n  color = picking_filterHighlightColor(color);\n\n  // use picking color if rendering to picking FBO.\n  color = picking_filterPickingColor(color);\n    `\n    }\n  },\n  ...picking\n} as ShaderModule<PickingModuleSettings>;\n"],"names":["WINDING","CLOCKWISE","COUNTER_CLOCKWISE","points","direction","options","windingDirection","Math","sign","start","end","length","dim","size","area","i","j","getPolygonWindingDirection","numPoints","numSwaps","floor","b1","b2","tmp","reversePolygon","intersect","a","b","edge","bbox","out","t","snap","bitCode","p","code","target","source","startIndex","isDuplicate","positions","index","offset","startI","cutPolylineByGrid","broken","gridResolution","gridOffset","endIndex","part","result","codeB","cell","getGridCell","scratchPoint","codeAlt","moveToNeighborCell","push","TYPE_INSIDE","TYPE_BORDER","concatInPlace","arr1","arr2","cutPolygonByGrid","holeIndices","edgeTypes","queue","pos","types","Array","fill","holes","shift","getBoundingBox","parts","bisectPolygon","polygonLow","polygonHigh","polygon","resultLow","resultHigh","typesLow","typesHigh","side","type","prev","prevSide","prevType","lowPointCount","highPointCount","left","bottom","minX","Infinity","maxX","minY","maxY","x","y","DEFAULT_MAX_LATITUDE","cutPolylineByMercatorBounds","normalize","newPositions","slice","wrapLongitudesForShortestPath","shiftLongitudesIntoRange","cutPolygonByMercatorBounds","newHoleIndices","srcStartIndex","targetIndex","ringIndex","srcEndIndex","targetStartIndex","splitIndex","findSplitIndex","insertPoleVertices","maxLatitude","pop","maxLat","pointIndex","lat","abs","firstLng","lastLng","round","lng","prevLng","delta","refLng","pointCount","DEFAULT_MODULE_OPTIONS","pickingSelectedColor","pickingHighlightColor","Uint8Array","pickingActive","pickingAttribute","inject","order","injection","name","vs","fs","getUniforms","opts","arguments","undefined","uniforms","selectedColor","picking_uSelectedColorValid","picking_uSelectedColor","color","from","Number","isFinite","picking_uHighlightColor","picking_uActive","Boolean","picking_uAttribute"],"sourceRoot":""}