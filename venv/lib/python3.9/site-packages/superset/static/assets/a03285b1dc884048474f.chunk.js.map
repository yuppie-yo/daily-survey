{"version":3,"file":"a03285b1dc884048474f.chunk.js","mappings":"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","sources":["webpack://superset/../../../src/line-layer/line-layer-vertex.glsl.ts","webpack://superset/../../../src/line-layer/line-layer.ts","webpack://superset/../../../src/line-layer/line-layer-fragment.glsl.ts","webpack://superset/../../../src/contour-layer/marching-squares-codes.ts","webpack://superset/../../../src/contour-layer/marching-squares.ts","webpack://superset/../../../src/contour-layer/contour-layer.ts","webpack://superset/../../../src/contour-layer/contour-utils.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME line-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\n\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float useShortestPath;\nuniform int widthUnits;\n\nvarying vec4 vColor;\nvarying vec2 uv;\n\n// offset vector by strokeWidth pixels\n// offset_direction is -1 (left) or 1 (right)\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nvec3 splitLine(vec3 a, vec3 b, float x) {\n  float t = (x - a.x) / (b.x - a.x);\n  return vec3(x, mix(a.yz, b.yz, t));\n}\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  vec3 source_world = instanceSourcePositions;\n  vec3 target_world = instanceTargetPositions;\n  vec3 source_world_64low = instanceSourcePositions64Low;\n  vec3 target_world_64low = instanceTargetPositions64Low;\n\n  if (useShortestPath > 0.5 || useShortestPath < -0.5) {\n    source_world.x = mod(source_world.x + 180., 360.0) - 180.;\n    target_world.x = mod(target_world.x + 180., 360.0) - 180.;\n    float deltaLng = target_world.x - source_world.x;\n\n    if (deltaLng * useShortestPath > 180.) {\n      source_world.x += 360. * useShortestPath;\n      source_world = splitLine(source_world, target_world, 180. * useShortestPath);\n      source_world_64low = vec3(0.0);\n    } else if (deltaLng * useShortestPath < -180.) {\n      target_world.x += 360. * useShortestPath;\n      target_world = splitLine(source_world, target_world, 180. * useShortestPath);\n      target_world_64low = vec3(0.0);\n    } else if (useShortestPath < 0.) {\n      // Line is not split, abort\n      gl_Position = vec4(0.);\n      return;\n    }\n  }\n\n  // Position\n  vec4 source_commonspace;\n  vec4 target_commonspace;\n  vec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);\n  vec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);\n  \n  // linear interpolation of source & target to pick right coord\n  float segmentIndex = positions.x;\n  vec4 p = mix(source, target, segmentIndex);\n  geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);\n  uv = positions.xy;\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n\n  // Multiply out width and clamp to limits\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels\n  );\n\n  // extrude\n  vec3 offset = vec3(\n    getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  DECKGL_FILTER_GL_POSITION(p, geometry);\n  gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n\n  // Color\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Layer,\n  project32,\n  picking,\n  UNIT,\n  LayerProps,\n  LayerDataSource,\n  Unit,\n  Position,\n  Accessor,\n  Color,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry} from '@luma.gl/core';\n\nimport vs from './line-layer-vertex.glsl';\nimport fs from './line-layer-fragment.glsl';\n\nconst DEFAULT_COLOR: [number, number, number, number] = [0, 0, 0, 255];\n\nconst defaultProps: DefaultProps<LineLayerProps> = {\n  getSourcePosition: {type: 'accessor', value: x => x.sourcePosition},\n  getTargetPosition: {type: 'accessor', value: x => x.targetPosition},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getWidth: {type: 'accessor', value: 1},\n\n  widthUnits: 'pixels',\n  widthScale: {type: 'number', value: 1, min: 0},\n  widthMinPixels: {type: 'number', value: 0, min: 0},\n  widthMaxPixels: {type: 'number', value: Number.MAX_SAFE_INTEGER, min: 0}\n};\n\n/** All properties supported by LineLayer. */\nexport type LineLayerProps<DataT = any> = _LineLayerProps<DataT> & LayerProps;\n\n/** Properties added by LineLayer. */\ntype _LineLayerProps<DataT> = {\n  data: LayerDataSource<DataT>;\n  /**\n   * The units of the line width, one of `'meters'`, `'common'`, and `'pixels'`.\n   * @default 'pixels'\n   */\n  widthUnits?: Unit;\n\n  /**\n   * The scaling multiplier for the width of each line.\n   * @default 1\n   */\n  widthScale?: number;\n\n  /**\n   * The minimum line width in pixels.\n   * @default 0\n   */\n  widthMinPixels?: number;\n\n  /**\n   * The maximum line width in pixels.\n   * @default Number.MAX_SAFE_INTEGER\n   */\n  widthMaxPixels?: number;\n\n  /**\n   * Source position of each object.\n   * @default object => object.sourcePosition\n   */\n  getSourcePosition?: Accessor<DataT, Position>;\n\n  /**\n   * Target position of each object.\n   * @default object => object.targetPosition\n   */\n  getTargetPosition?: Accessor<DataT, Position>;\n\n  /**\n   * The rgba color is in the format of `[r, g, b, [a]]`.\n   * @default [0, 0, 0, 255]\n   */\n  getColor?: Accessor<DataT, Color>;\n\n  /**\n   * Width of each object\n   * @default 1\n   */\n  getWidth?: Accessor<DataT, number>;\n};\n\n/**\n * A layer that renders straight lines joining pairs of source and target coordinates.\n */\nexport default class LineLayer<DataT = any, ExtraProps extends {} = {}> extends Layer<\n  ExtraProps & Required<_LineLayerProps<DataT>>\n> {\n  static layerName = 'LineLayer';\n  static defaultProps = defaultProps;\n\n  getBounds(): [number[], number[]] | null {\n    return this.getAttributeManager()?.getBounds([\n      'instanceSourcePositions',\n      'instanceTargetPositions'\n    ]);\n  }\n\n  getShaders() {\n    return super.getShaders({vs, fs, modules: [project32, picking]});\n  }\n\n  // This layer has its own wrapLongitude logic\n  get wrapLongitude(): boolean {\n    return false;\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager()!;\n\n    /* eslint-disable max-len */\n    attributeManager.addInstanced({\n      instanceSourcePositions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getSourcePosition'\n      },\n      instanceTargetPositions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getTargetPosition'\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: true,\n        accessor: 'getColor',\n        defaultValue: [0, 0, 0, 255]\n      },\n      instanceWidths: {\n        size: 1,\n        transition: true,\n        accessor: 'getWidth',\n        defaultValue: 1\n      }\n    });\n    /* eslint-enable max-len */\n  }\n\n  updateState(params: UpdateParameters<this>): void {\n    super.updateState(params);\n\n    if (params.changeFlags.extensionsChanged) {\n      const {gl} = this.context;\n      this.state.model?.delete();\n      this.state.model = this._getModel(gl);\n      this.getAttributeManager()!.invalidateAll();\n    }\n  }\n\n  draw({uniforms}): void {\n    const {widthUnits, widthScale, widthMinPixels, widthMaxPixels, wrapLongitude} = this.props;\n\n    this.state.model\n      .setUniforms(uniforms)\n      .setUniforms({\n        widthUnits: UNIT[widthUnits],\n        widthScale,\n        widthMinPixels,\n        widthMaxPixels,\n        useShortestPath: wrapLongitude ? 1 : 0\n      })\n      .draw();\n\n    if (wrapLongitude) {\n      // Render a second copy for the clipped lines at the 180th meridian\n      this.state.model\n        .setUniforms({\n          useShortestPath: -1\n        })\n        .draw();\n    }\n  }\n\n  protected _getModel(gl: WebGLRenderingContext): Model {\n    /*\n     *  (0, -1)-------------_(1, -1)\n     *       |          _,-\"  |\n     *       o      _,-\"      o\n     *       |  _,-\"          |\n     *   (0, 1)\"-------------(1, 1)\n     */\n    const positions = [0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0];\n\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: GL.TRIANGLE_STRIP,\n        attributes: {\n          positions: new Float32Array(positions)\n        }\n      }),\n      isInstanced: true\n    });\n  }\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME line-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n`;\n","// Code to Offsets Map needed to implement Marching Squares algorithm\n// Ref: https://en.wikipedia.org/wiki/Marching_squares\n\n// Table to map code to the intersection offsets\n// All offsets are relative to the center of marching cell (which is top right corner of grid-cell, and center of marching-square)\nconst HALF = 0.5;\nconst ONE6TH = 1 / 6;\nconst OFFSET = {\n  N: [0, HALF], // NORTH\n  E: [HALF, 0], // EAST\n  S: [0, -HALF], // SOUTH\n  W: [-HALF, 0], // WEST\n\n  // CORNERS\n  NE: [HALF, HALF],\n  NW: [-HALF, HALF],\n  SE: [HALF, -HALF],\n  SW: [-HALF, -HALF]\n};\n\n// NOTE: vertices are ordered in CCW direction, starting from NW corner\n\n// Triangles\nconst SW_TRIANGLE = [OFFSET.W, OFFSET.SW, OFFSET.S];\nconst SE_TRIANGLE = [OFFSET.S, OFFSET.SE, OFFSET.E];\nconst NE_TRIANGLE = [OFFSET.E, OFFSET.NE, OFFSET.N];\nconst NW_TRIANGLE = [OFFSET.NW, OFFSET.W, OFFSET.N];\n\n// Trapezoids\nconst SW_TRAPEZOID = [\n  [-HALF, ONE6TH],\n  [-HALF, -ONE6TH],\n  [-ONE6TH, -HALF],\n  [ONE6TH, -HALF]\n];\nconst SE_TRAPEZOID = [\n  [-ONE6TH, -HALF],\n  [ONE6TH, -HALF],\n  [HALF, -ONE6TH],\n  [HALF, ONE6TH]\n];\nconst NE_TRAPEZOID = [\n  [HALF, -ONE6TH],\n  [HALF, ONE6TH],\n  [ONE6TH, HALF],\n  [-ONE6TH, HALF]\n];\nconst NW_TRAPEZOID = [\n  [-HALF, ONE6TH],\n  [-HALF, -ONE6TH],\n  [ONE6TH, HALF],\n  [-ONE6TH, HALF]\n];\n\n// Rectangles\nconst S_RECTANGLE = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E];\nconst E_RECTANGLE = [OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];\nconst N_RECTANGLE = [OFFSET.NW, OFFSET.W, OFFSET.E, OFFSET.NE];\nconst W_RECTANGLE = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.N];\nconst EW_RECTANGEL = [\n  [-HALF, ONE6TH],\n  [-HALF, -ONE6TH],\n  [HALF, -ONE6TH],\n  [HALF, ONE6TH]\n];\nconst SN_RECTANGEL = [\n  [-ONE6TH, -HALF],\n  [ONE6TH, -HALF],\n  [ONE6TH, HALF],\n  [-ONE6TH, HALF]\n];\n\n// Square\nconst SQUARE = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.NE];\n\n// Pentagons\nconst SW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.E, OFFSET.N];\nconst SE_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.NE, OFFSET.N];\nconst NE_PENTAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.NE];\nconst NW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE];\n\nconst NW_N_PENTAGON = [OFFSET.NW, OFFSET.W, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];\nconst NE_E_PENTAGON = [[-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE, OFFSET.N];\nconst SE_S_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.E];\nconst SW_W_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [ONE6TH, HALF], [-ONE6TH, HALF]];\n\nconst NW_W_PENTAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.N];\nconst NE_N_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.E, OFFSET.NE, OFFSET.N];\nconst SE_E_PENTAGON = [OFFSET.S, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];\nconst SW_S_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH]];\n\n// Hexagon\nconst S_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];\nconst E_HEXAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];\nconst N_HEXAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE];\nconst W_HEXAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];\nconst SW_NE_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE, OFFSET.N];\nconst NW_SE_HEXAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.E, OFFSET.N];\n\n// Heptagon (7-sided)\nconst NE_HEPTAGON = [\n  [-HALF, ONE6TH],\n  [-HALF, -ONE6TH],\n  [-ONE6TH, -HALF],\n  [ONE6TH, -HALF],\n  OFFSET.E,\n  OFFSET.NE,\n  OFFSET.N\n];\nconst SW_HEPTAGON = [\n  OFFSET.W,\n  OFFSET.SW,\n  OFFSET.S,\n  [HALF, -ONE6TH],\n  [HALF, ONE6TH],\n  [ONE6TH, HALF],\n  [-ONE6TH, HALF]\n];\nconst NW_HEPTAGON = [\n  OFFSET.NW,\n  OFFSET.W,\n  [-ONE6TH, -HALF],\n  [ONE6TH, -HALF],\n  [HALF, -ONE6TH],\n  [HALF, ONE6TH],\n  OFFSET.N\n];\nconst SE_HEPTAGON = [\n  [-HALF, ONE6TH],\n  [-HALF, -ONE6TH],\n  OFFSET.S,\n  OFFSET.SE,\n  OFFSET.E,\n  [ONE6TH, HALF],\n  [-ONE6TH, HALF]\n];\n\n// Octagon\nconst OCTAGON = [\n  [-HALF, ONE6TH],\n  [-HALF, -ONE6TH],\n  [-ONE6TH, -HALF],\n  [ONE6TH, -HALF],\n  [HALF, -ONE6TH],\n  [HALF, ONE6TH],\n  [ONE6TH, HALF],\n  [-ONE6TH, HALF]\n];\n\n// Note: above wiki page invertes white/black dots for generating the code, we don't\nexport const ISOLINES_CODE_OFFSET_MAP = {\n  // key is equal to the code of 4 vertices (invert the code specified in wiki)\n  // value can be an array or an Object\n  // Array : [line] or [line, line], where each line is [start-point, end-point], and each point is [x, y]\n  // Object : to handle saddle cases, whos output depends on mean value of all 4 corners\n  //  key: code of mean value (0 or 1)\n  //  value: Array , as above defines one or two line segments\n  0: [],\n  1: [[OFFSET.W, OFFSET.S]],\n  2: [[OFFSET.S, OFFSET.E]],\n  3: [[OFFSET.W, OFFSET.E]],\n  4: [[OFFSET.N, OFFSET.E]],\n  5: {\n    0: [\n      [OFFSET.W, OFFSET.S],\n      [OFFSET.N, OFFSET.E]\n    ],\n    1: [\n      [OFFSET.W, OFFSET.N],\n      [OFFSET.S, OFFSET.E]\n    ]\n  },\n  6: [[OFFSET.N, OFFSET.S]],\n  7: [[OFFSET.W, OFFSET.N]],\n  8: [[OFFSET.W, OFFSET.N]],\n  9: [[OFFSET.N, OFFSET.S]],\n  10: {\n    0: [\n      [OFFSET.W, OFFSET.N],\n      [OFFSET.S, OFFSET.E]\n    ],\n    1: [\n      [OFFSET.W, OFFSET.S],\n      [OFFSET.N, OFFSET.E]\n    ]\n  },\n  11: [[OFFSET.N, OFFSET.E]],\n  12: [[OFFSET.W, OFFSET.E]],\n  13: [[OFFSET.S, OFFSET.E]],\n  14: [[OFFSET.W, OFFSET.S]],\n  15: []\n};\n\nfunction ternaryToIndex(ternary) {\n  return parseInt(ternary, 4);\n}\n\nexport const ISOBANDS_CODE_OFFSET_MAP = {\n  // Below list of cases, follow the same order as in above mentioned wiki page.\n  // Each case has its code on first commented line // T,TR,R,C\n  // where T: Top, TR: Top-right, R: Right and C: current, each will be either 0, 1 or 2\n  // final code is binary representation of above code , where takes 2 digits\n  // for example:  code 2-2-2-1 => 10-10-10-01 => 10101001 => 169\n\n  // no contours\n  [ternaryToIndex('0000')]: [],\n  [ternaryToIndex('2222')]: [],\n\n  // single triangle\n  [ternaryToIndex('2221')]: [SW_TRIANGLE],\n  [ternaryToIndex('2212')]: [SE_TRIANGLE],\n  [ternaryToIndex('2122')]: [NE_TRIANGLE],\n  [ternaryToIndex('1222')]: [NW_TRIANGLE],\n  [ternaryToIndex('0001')]: [SW_TRIANGLE],\n  [ternaryToIndex('0010')]: [SE_TRIANGLE],\n  [ternaryToIndex('0100')]: [NE_TRIANGLE],\n  [ternaryToIndex('1000')]: [NW_TRIANGLE],\n\n  // single trapezoid\n  [ternaryToIndex('2220')]: [SW_TRAPEZOID],\n  [ternaryToIndex('2202')]: [SE_TRAPEZOID],\n  [ternaryToIndex('2022')]: [NE_TRAPEZOID],\n  [ternaryToIndex('0222')]: [NW_TRAPEZOID],\n  [ternaryToIndex('0002')]: [SW_TRAPEZOID],\n  [ternaryToIndex('0020')]: [SE_TRAPEZOID],\n  [ternaryToIndex('0200')]: [NE_TRAPEZOID],\n  [ternaryToIndex('2000')]: [NW_TRAPEZOID],\n\n  // single rectangle\n  [ternaryToIndex('0011')]: [S_RECTANGLE],\n  [ternaryToIndex('0110')]: [E_RECTANGLE],\n  [ternaryToIndex('1100')]: [N_RECTANGLE],\n  [ternaryToIndex('1001')]: [W_RECTANGLE],\n  [ternaryToIndex('2211')]: [S_RECTANGLE],\n  [ternaryToIndex('2112')]: [E_RECTANGLE],\n  [ternaryToIndex('1122')]: [N_RECTANGLE],\n  [ternaryToIndex('1221')]: [W_RECTANGLE],\n  [ternaryToIndex('2200')]: [EW_RECTANGEL],\n  [ternaryToIndex('2002')]: [SN_RECTANGEL],\n  [ternaryToIndex('0022')]: [EW_RECTANGEL],\n  [ternaryToIndex('0220')]: [SN_RECTANGEL],\n\n  // single square\n  // 1111\n  [ternaryToIndex('1111')]: [SQUARE],\n\n  // single pentagon\n  [ternaryToIndex('1211')]: [SW_PENTAGON],\n  [ternaryToIndex('2111')]: [SE_PENTAGON],\n  [ternaryToIndex('1112')]: [NE_PENTAGON],\n  [ternaryToIndex('1121')]: [NW_PENTAGON],\n  [ternaryToIndex('1011')]: [SW_PENTAGON],\n  [ternaryToIndex('0111')]: [SE_PENTAGON],\n  [ternaryToIndex('1110')]: [NE_PENTAGON],\n  [ternaryToIndex('1101')]: [NW_PENTAGON],\n  [ternaryToIndex('1200')]: [NW_N_PENTAGON],\n  [ternaryToIndex('0120')]: [NE_E_PENTAGON],\n  [ternaryToIndex('0012')]: [SE_S_PENTAGON],\n  [ternaryToIndex('2001')]: [SW_W_PENTAGON],\n  [ternaryToIndex('1022')]: [NW_N_PENTAGON],\n  [ternaryToIndex('2102')]: [NE_E_PENTAGON],\n  [ternaryToIndex('2210')]: [SE_S_PENTAGON],\n  [ternaryToIndex('0221')]: [SW_W_PENTAGON],\n  [ternaryToIndex('1002')]: [NW_W_PENTAGON],\n  [ternaryToIndex('2100')]: [NE_N_PENTAGON],\n  [ternaryToIndex('0210')]: [SE_E_PENTAGON],\n  [ternaryToIndex('0021')]: [SW_S_PENTAGON],\n  [ternaryToIndex('1220')]: [NW_W_PENTAGON],\n  [ternaryToIndex('0122')]: [NE_N_PENTAGON],\n  [ternaryToIndex('2012')]: [SE_E_PENTAGON],\n  [ternaryToIndex('2201')]: [SW_S_PENTAGON],\n\n  // single hexagon\n  [ternaryToIndex('0211')]: [S_HEXAGON],\n  [ternaryToIndex('2110')]: [E_HEXAGON],\n  [ternaryToIndex('1102')]: [N_HEXAGON],\n  [ternaryToIndex('1021')]: [W_HEXAGON],\n  [ternaryToIndex('2011')]: [S_HEXAGON],\n  [ternaryToIndex('0112')]: [E_HEXAGON],\n  [ternaryToIndex('1120')]: [N_HEXAGON],\n  [ternaryToIndex('1201')]: [W_HEXAGON],\n  [ternaryToIndex('2101')]: [SW_NE_HEXAGON],\n  [ternaryToIndex('0121')]: [SW_NE_HEXAGON],\n  [ternaryToIndex('1012')]: [NW_SE_HEXAGON],\n  [ternaryToIndex('1210')]: [NW_SE_HEXAGON],\n\n  // 6-sided polygons based on mean weight\n  // NOTE: merges mean value codes for extreme changes (as per above Wiki doc)\n  [ternaryToIndex('0101')]: {\n    0: [SW_TRIANGLE, NE_TRIANGLE],\n    1: [SW_NE_HEXAGON],\n    2: [SW_NE_HEXAGON]\n  },\n  [ternaryToIndex('1010')]: {\n    0: [NW_TRIANGLE, SE_TRIANGLE],\n    1: [NW_SE_HEXAGON],\n    2: [NW_SE_HEXAGON]\n  },\n  [ternaryToIndex('2121')]: {\n    0: [SW_NE_HEXAGON],\n    1: [SW_NE_HEXAGON],\n    2: [SW_TRIANGLE, NE_TRIANGLE]\n  },\n  [ternaryToIndex('1212')]: {\n    0: [NW_SE_HEXAGON],\n    1: [NW_SE_HEXAGON],\n    2: [NW_TRIANGLE, SE_TRIANGLE]\n  },\n\n  // 7-sided polygons based on mean weight\n  [ternaryToIndex('2120')]: {\n    0: [NE_HEPTAGON],\n    1: [NE_HEPTAGON],\n    2: [SW_TRAPEZOID, NE_TRIANGLE]\n  },\n  [ternaryToIndex('2021')]: {\n    0: [SW_HEPTAGON],\n    1: [SW_HEPTAGON],\n    2: [SW_TRIANGLE, NE_TRAPEZOID]\n  },\n  [ternaryToIndex('1202')]: {\n    0: [NW_HEPTAGON],\n    1: [NW_HEPTAGON],\n    2: [NW_TRIANGLE, SE_TRAPEZOID]\n  },\n  [ternaryToIndex('0212')]: {\n    0: [SE_HEPTAGON],\n    1: [SE_HEPTAGON],\n    2: [SE_TRIANGLE, NW_TRAPEZOID]\n  },\n  [ternaryToIndex('0102')]: {\n    0: [SW_TRAPEZOID, NE_TRIANGLE],\n    1: [NE_HEPTAGON],\n    2: [NE_HEPTAGON]\n  },\n  [ternaryToIndex('0201')]: {\n    0: [SW_TRIANGLE, NE_TRAPEZOID],\n    1: [SW_HEPTAGON],\n    2: [SW_HEPTAGON]\n  },\n  [ternaryToIndex('1020')]: {\n    0: [NW_TRIANGLE, SE_TRAPEZOID],\n    1: [NW_HEPTAGON],\n    2: [NW_HEPTAGON]\n  },\n  [ternaryToIndex('2010')]: {\n    0: [SE_TRIANGLE, NW_TRAPEZOID],\n    1: [SE_HEPTAGON],\n    2: [SE_HEPTAGON]\n  },\n\n  // 8-sided polygons based on mean weight\n  [ternaryToIndex('2020')]: {\n    0: [NW_TRAPEZOID, SE_TRAPEZOID],\n    1: [OCTAGON],\n    2: [SW_TRAPEZOID, NE_TRAPEZOID]\n  },\n  [ternaryToIndex('0202')]: {\n    0: [NE_TRAPEZOID, SW_TRAPEZOID],\n    1: [OCTAGON],\n    2: [NW_TRAPEZOID, SE_TRAPEZOID]\n  }\n};\n","// All utility methods needed to implement Marching Squares algorithm\n// Ref: https://en.wikipedia.org/wiki/Marching_squares\n\nimport {log} from '@deck.gl/core';\nimport {ISOLINES_CODE_OFFSET_MAP, ISOBANDS_CODE_OFFSET_MAP} from './marching-squares-codes';\n\nexport const CONTOUR_TYPE = {\n  ISO_LINES: 1,\n  ISO_BANDS: 2\n};\n\nconst DEFAULT_THRESHOLD_DATA = {\n  zIndex: 0,\n  zOffset: 0.005\n};\n\n// Utility methods\n\nfunction getVertexCode(weight: number, threshold: number | number[]): number {\n  // threshold must be a single value or a range (array of size 2)\n\n  // Iso-bands\n  if (Array.isArray(threshold)) {\n    if (weight < threshold[0]) {\n      return 0;\n    }\n    return weight < threshold[1] ? 1 : 2;\n  }\n  // Iso-lines\n  return weight >= threshold ? 1 : 0;\n}\n\n// Returns marching square code for given cell\n/* eslint-disable complexity, max-statements*/\nexport function getCode(opts) {\n  // Assumptions\n  // Origin is on bottom-left , and X increase to right, Y to top\n  // When processing one cell, we process 4 cells, by extending row to top and on column to right\n  // to create a 2X2 cell grid\n  const {cellWeights, x, y, width, height} = opts;\n  let threshold = opts.threshold;\n  if (opts.thresholdValue) {\n    log.deprecated('thresholdValue', 'threshold')();\n    threshold = opts.thresholdValue;\n  }\n\n  const isLeftBoundary = x < 0;\n  const isRightBoundary = x >= width - 1;\n  const isBottomBoundary = y < 0;\n  const isTopBoundary = y >= height - 1;\n  const isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;\n\n  const weights: Record<string, number> = {};\n  const codes: Record<string, number> = {};\n\n  // TOP\n  if (isLeftBoundary || isTopBoundary) {\n    codes.top = 0;\n  } else {\n    weights.top = cellWeights[(y + 1) * width + x];\n    codes.top = getVertexCode(weights.top, threshold);\n  }\n\n  // TOP-RIGHT\n  if (isRightBoundary || isTopBoundary) {\n    codes.topRight = 0;\n  } else {\n    weights.topRight = cellWeights[(y + 1) * width + x + 1];\n    codes.topRight = getVertexCode(weights.topRight, threshold);\n  }\n\n  // RIGHT\n  if (isRightBoundary || isBottomBoundary) {\n    codes.right = 0;\n  } else {\n    weights.right = cellWeights[y * width + x + 1];\n    codes.right = getVertexCode(weights.right, threshold);\n  }\n\n  // CURRENT\n  if (isLeftBoundary || isBottomBoundary) {\n    codes.current = 0;\n  } else {\n    weights.current = cellWeights[y * width + x];\n    codes.current = getVertexCode(weights.current, threshold);\n  }\n\n  const {top, topRight, right, current} = codes;\n  let code = -1;\n  if (Number.isFinite(threshold)) {\n    code = (top << 3) | (topRight << 2) | (right << 1) | current;\n  }\n  if (Array.isArray(threshold)) {\n    code = (top << 6) | (topRight << 4) | (right << 2) | current;\n  }\n\n  let meanCode = 0;\n  // meanCode is only needed for saddle cases, and they should\n  // only occur when we are not processing a cell on boundary\n  // because when on a boundary either, bottom-row, top-row, left-column or right-column will have both 0 codes\n  if (!isBoundary) {\n    meanCode = getVertexCode(\n      (weights.top + weights.topRight + weights.right + weights.current) / 4,\n      threshold\n    );\n  }\n  return {code, meanCode};\n}\n/* eslint-enable complexity, max-statements*/\n\n// Returns intersection vertices for given cellindex\n// [x, y] refers current marching cell, reference vertex is always top-right corner\nexport function getVertices(opts) {\n  const {gridOrigin, cellSize, x, y, code, meanCode, type = CONTOUR_TYPE.ISO_LINES} = opts;\n  const thresholdData = {...DEFAULT_THRESHOLD_DATA, ...opts.thresholdData};\n  let offsets =\n    type === CONTOUR_TYPE.ISO_BANDS\n      ? ISOBANDS_CODE_OFFSET_MAP[code]\n      : ISOLINES_CODE_OFFSET_MAP[code];\n\n  // handle saddle cases\n  if (!Array.isArray(offsets)) {\n    offsets = offsets[meanCode];\n  }\n\n  // Reference vertex is at top-right move to top-right corner\n\n  const vZ = thresholdData.zIndex * thresholdData.zOffset;\n  const rX = (x + 1) * cellSize[0];\n  const rY = (y + 1) * cellSize[1];\n\n  const refVertexX = gridOrigin[0] + rX;\n  const refVertexY = gridOrigin[1] + rY;\n\n  // offsets format\n  // ISO_LINES: [[1A, 1B], [2A, 2B]],\n  // ISO_BANDS: [[1A, 1B, 1C, ...], [2A, 2B, 2C, ...]],\n\n  // vertices format\n\n  // ISO_LINES: [[x1A, y1A], [x1B, y1B], [x2A, x2B], ...],\n\n  // ISO_BANDS:  => confirms to SolidPolygonLayer's simple polygon format\n  //      [\n  //        [[x1A, y1A], [x1B, y1B], [x1C, y1C] ... ],\n  //        ...\n  //      ]\n\n  if (type === CONTOUR_TYPE.ISO_BANDS) {\n    const polygons: number[][][] = [];\n    offsets.forEach(polygonOffsets => {\n      const polygon: number[][] = [];\n      polygonOffsets.forEach(xyOffset => {\n        const vX = refVertexX + xyOffset[0] * cellSize[0];\n        const vY = refVertexY + xyOffset[1] * cellSize[1];\n        polygon.push([vX, vY, vZ]);\n      });\n      polygons.push(polygon);\n    });\n    return polygons;\n  }\n\n  // default case is ISO_LINES\n  const lines: number[][] = [];\n  offsets.forEach(xyOffsets => {\n    xyOffsets.forEach(offset => {\n      const vX = refVertexX + offset[0] * cellSize[0];\n      const vY = refVertexY + offset[1] * cellSize[1];\n      lines.push([vX, vY, vZ]);\n    });\n  });\n  return lines;\n}\n","// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {LineLayer, SolidPolygonLayer} from '@deck.gl/layers';\nimport {generateContours} from './contour-utils';\nimport {\n  Accessor,\n  AccessorFunction,\n  Color,\n  Layer,\n  log,\n  Position,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\n\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {AGGREGATION_OPERATION, getValueFunc} from '../utils/aggregation-operation-utils';\nimport {getBoundingBox, getGridParams} from '../utils/grid-aggregation-utils';\nimport GridAggregationLayer, {GridAggregationLayerProps} from '../grid-aggregation-layer';\n\nconst DEFAULT_COLOR = [255, 255, 255, 255];\nconst DEFAULT_STROKE_WIDTH = 1;\nconst DEFAULT_THRESHOLD = 1;\n\nconst defaultProps: DefaultProps<ContourLayerProps> = {\n  // grid aggregation\n  cellSize: {type: 'number', min: 1, max: 1000, value: 1000},\n  getPosition: {type: 'accessor', value: x => x.position},\n  getWeight: {type: 'accessor', value: 1},\n  gpuAggregation: true,\n  aggregation: 'SUM',\n\n  // contour lines\n  contours: {\n    type: 'object',\n    value: [{threshold: DEFAULT_THRESHOLD}],\n    optional: true,\n    compare: 3\n  },\n\n  zOffset: 0.005\n};\n\nconst POSITION_ATTRIBUTE_NAME = 'positions';\n\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSize']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\n\n/** All properties supported by ContourLayer. */\nexport type ContourLayerProps<DataT = any> = _ContourLayerProps<DataT> &\n  GridAggregationLayerProps<DataT>;\n\n/** Properties added by ContourLayer. */\nexport type _ContourLayerProps<DataT> = {\n  /**\n   * Size of each cell in meters.\n   * @default 1000\n   */\n  cellSize?: number;\n\n  /**\n   * When set to true, aggregation is performed on GPU, provided other conditions are met.\n   * @default true\n   */\n  gpuAggregation?: boolean;\n\n  /**\n   * Defines the type of aggregation operation, valid values are 'SUM', 'MEAN', 'MIN' and 'MAX'.\n   * @default 'SUM'\n   */\n  aggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n\n  /**\n   * Definition of contours to be drawn.\n   * @default [{threshold: 1}]\n   */\n  contours: {\n    /**\n     * Isolines: `threshold` value must be a single `Number`, Isolines are generated based on this threshold value.\n     *\n     * Isobands: `threshold` value must be an Array of two `Number`s. Isobands are generated using `[threshold[0], threshold[1])` as threshold range, i.e area that has values `>= threshold[0]` and `< threshold[1]` are rendered with corresponding color. NOTE: `threshold[0]` is inclusive and `threshold[1]` is not inclusive.\n     */\n    threshold: number | number[];\n\n    /**\n     * RGBA color array to be used to render the contour.\n     * @default [255, 255, 255, 255]\n     */\n    color?: Color;\n\n    /**\n     * Applicable for `Isoline`s only, width of the Isoline in pixels.\n     * @default 1\n     */\n    strokeWidth?: number;\n\n    /** Defines z order of the contour. */\n    zIndex?: number;\n  }[];\n\n  /**\n   * A very small z offset that is added for each vertex of a contour (Isoline or Isoband).\n   * @default 0.005\n   */\n  zOffset?: number;\n\n  /**\n   * Method called to retrieve the position of each object.\n   * @default object => object.position\n   */\n  getPosition?: AccessorFunction<DataT, Position>;\n\n  /**\n   * The weight of each object.\n   * @default 1\n   */\n  getWeight?: Accessor<DataT, number>;\n};\n\n/** Aggregate data into iso-lines or iso-bands for a given threshold and cell size. */\nexport default class ContourLayer<\n  DataT = any,\n  ExtraPropsT extends {} = {}\n> extends GridAggregationLayer<DataT, ExtraPropsT & Required<_ContourLayerProps<DataT>>> {\n  static layerName = 'ContourLayer';\n  static defaultProps = defaultProps;\n\n  initializeState(): void {\n    super.initializeAggregationLayer({\n      dimensions: DIMENSIONS\n    });\n    this.setState({\n      contourData: {},\n      projectPoints: false,\n      weights: {\n        count: {\n          size: 1,\n          operation: AGGREGATION_OPERATION.SUM\n        }\n      }\n    });\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions()\n      },\n      // this attribute is used in gpu aggregation path only\n      count: {size: 3, accessor: 'getWeight'}\n    });\n  }\n\n  updateState(opts: UpdateParameters<this>): void {\n    super.updateState(opts);\n    let contoursChanged = false;\n    const {oldProps, props} = opts;\n    const {aggregationDirty} = this.state;\n\n    if (oldProps.contours !== props.contours || oldProps.zOffset !== props.zOffset) {\n      contoursChanged = true;\n      this._updateThresholdData(opts.props);\n    }\n\n    if (this.getNumInstances() > 0 && (aggregationDirty || contoursChanged)) {\n      this._generateContours();\n    }\n  }\n\n  renderLayers(): Layer[] {\n    const {contourSegments, contourPolygons} = this.state.contourData;\n\n    const LinesSubLayerClass = this.getSubLayerClass('lines', LineLayer);\n    const BandsSubLayerClass = this.getSubLayerClass('bands', SolidPolygonLayer);\n\n    // Contour lines layer\n    const lineLayer =\n      contourSegments &&\n      contourSegments.length > 0 &&\n      new LinesSubLayerClass(\n        this.getSubLayerProps({\n          id: 'lines'\n        }),\n        {\n          data: this.state.contourData.contourSegments,\n          getSourcePosition: d => d.start,\n          getTargetPosition: d => d.end,\n          getColor: d => d.contour.color || DEFAULT_COLOR,\n          getWidth: d => d.contour.strokeWidth || DEFAULT_STROKE_WIDTH\n        }\n      );\n\n    // Contour bands layer\n    const bandsLayer =\n      contourPolygons &&\n      contourPolygons.length > 0 &&\n      new BandsSubLayerClass(\n        this.getSubLayerProps({\n          id: 'bands'\n        }),\n        {\n          data: this.state.contourData.contourPolygons,\n          getPolygon: d => d.vertices,\n          getFillColor: d => d.contour.color || DEFAULT_COLOR\n        }\n      );\n\n    return [lineLayer, bandsLayer];\n  }\n\n  // Aggregation Overrides\n\n  /* eslint-disable max-statements, complexity */\n  updateAggregationState(opts) {\n    const {props, oldProps} = opts;\n    const {cellSize, coordinateSystem} = props;\n    const {viewport} = this.context;\n    const cellSizeChanged = oldProps.cellSize !== cellSize;\n    let gpuAggregation = props.gpuAggregation;\n    if (this.state.gpuAggregation !== props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n\n    const {dimensions} = this.state;\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    const {data, weights} = dimensions;\n\n    let {boundingBox} = this.state;\n    if (positionsChanged) {\n      boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n      this.setState({boundingBox});\n    }\n    if (positionsChanged || cellSizeChanged) {\n      const {gridOffset, translation, width, height, numCol, numRow} = getGridParams(\n        boundingBox,\n        cellSize,\n        viewport,\n        coordinateSystem\n      );\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        gridOffset,\n        boundingBox,\n        translation,\n        posOffset: translation.slice(), // Used for CPU aggregation, to offset points\n        gridOrigin: [-1 * translation[0], -1 * translation[1]],\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    const aggregationDataDirty =\n      positionsChanged ||\n      gpuAggregationChanged ||\n      this.isAggregationDirty(opts, {\n        dimension: data,\n        compareAll: gpuAggregation // check for all (including extentions props) when using gpu aggregation\n      });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {\n      dimension: weights\n    });\n\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n  }\n  /* eslint-enable max-statements, complexity */\n\n  // Private (Aggregation)\n\n  private _updateAccessors(opts) {\n    const {getWeight, aggregation, data} = opts.props;\n    const {count} = this.state.weights;\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n    this.setState({getValue: getValueFunc(aggregation, getWeight, {data})});\n  }\n\n  private _resetResults() {\n    const {count} = this.state.weights;\n    if (count) {\n      count.aggregationData = null;\n    }\n  }\n\n  // Private (Contours)\n\n  private _generateContours() {\n    const {numCol, numRow, gridOrigin, gridOffset, thresholdData} = this.state;\n    const {count} = this.state.weights;\n    let {aggregationData} = count;\n    if (!aggregationData) {\n      aggregationData = count.aggregationBuffer.getData();\n      count.aggregationData = aggregationData;\n    }\n\n    const {cellWeights} = GPUGridAggregator.getCellData({countsData: aggregationData});\n    const contourData = generateContours({\n      thresholdData,\n      cellWeights,\n      gridSize: [numCol, numRow],\n      gridOrigin,\n      cellSize: [gridOffset.xOffset, gridOffset.yOffset]\n    });\n\n    // contourData contains both iso-lines and iso-bands if requested.\n    this.setState({contourData});\n  }\n\n  private _updateThresholdData(props) {\n    const {contours, zOffset} = props;\n    const count = contours.length;\n    const thresholdData = new Array(count);\n    for (let i = 0; i < count; i++) {\n      const contour = contours[i];\n      thresholdData[i] = {\n        contour,\n        zIndex: contour.zIndex || i,\n        zOffset\n      };\n    }\n    this.setState({thresholdData});\n  }\n}\n","import {getCode, getVertices, CONTOUR_TYPE} from './marching-squares';\n\n// Given all the cell weights, generates contours for each threshold.\n/* eslint-disable max-depth */\nexport function generateContours({\n  thresholdData,\n  cellWeights,\n  gridSize,\n  gridOrigin,\n  cellSize\n}: {\n  thresholdData: any;\n  cellWeights: Float32Array;\n  gridSize: number[];\n  gridOrigin: number[];\n  cellSize: number[];\n}) {\n  const contourSegments: {start: number[]; end: number[]; contour: any}[] = [];\n  const contourPolygons: {vertices: number[][]; contour: any}[] = [];\n  const width = gridSize[0];\n  const height = gridSize[1];\n  let segmentIndex = 0;\n  let polygonIndex = 0;\n\n  for (const data of thresholdData) {\n    const {contour} = data;\n    const {threshold} = contour;\n    for (let x = -1; x < width; x++) {\n      for (let y = -1; y < height; y++) {\n        // Get the MarchingSquares code based on neighbor cell weights.\n        const {code, meanCode} = getCode({\n          cellWeights,\n          threshold,\n          x,\n          y,\n          width,\n          height\n        });\n        const opts = {\n          type: CONTOUR_TYPE.ISO_BANDS,\n          gridOrigin,\n          cellSize,\n          x,\n          y,\n          width,\n          height,\n          code,\n          meanCode,\n          thresholdData: data\n        };\n        if (Array.isArray(threshold)) {\n          opts.type = CONTOUR_TYPE.ISO_BANDS;\n          const polygons = getVertices(opts) as number[][][];\n          for (const polygon of polygons) {\n            contourPolygons[polygonIndex++] = {\n              vertices: polygon,\n              contour\n            };\n          }\n        } else {\n          // Get the intersection vertices based on MarchingSquares code.\n          opts.type = CONTOUR_TYPE.ISO_LINES;\n          const vertices = getVertices(opts) as number[][];\n          for (let i = 0; i < vertices.length; i += 2) {\n            contourSegments[segmentIndex++] = {\n              start: vertices[i],\n              end: vertices[i + 1],\n              contour\n            };\n          }\n        }\n      }\n    }\n  }\n  return {contourSegments, contourPolygons};\n}\n/* eslint-enable max-depth */\n"],"names":["defaultProps","getSourcePosition","type","value","x","sourcePosition","getTargetPosition","targetPosition","getColor","getWidth","widthUnits","widthScale","min","widthMinPixels","widthMaxPixels","Number","MAX_SAFE_INTEGER","LineLayer","Layer","getBounds","_this$getAttributeMan","this","getAttributeManager","getShaders","super","vs","fs","modules","project32","picking","wrapLongitude","initializeState","addInstanced","instanceSourcePositions","size","fp64","use64bitPositions","transition","accessor","instanceTargetPositions","instanceColors","props","colorFormat","length","normalized","defaultValue","instanceWidths","updateState","params","changeFlags","extensionsChanged","_this$state$model","gl","context","state","model","delete","_getModel","invalidateAll","draw","uniforms","setUniforms","UNIT","useShortestPath","Model","id","geometry","Geometry","drawMode","attributes","positions","Float32Array","isInstanced","HALF","ONE6TH","OFFSET","N","E","S","W","NE","NW","SE","SW","SW_TRIANGLE","SE_TRIANGLE","NE_TRIANGLE","NW_TRIANGLE","SW_TRAPEZOID","SE_TRAPEZOID","NE_TRAPEZOID","NW_TRAPEZOID","S_RECTANGLE","E_RECTANGLE","N_RECTANGLE","W_RECTANGLE","EW_RECTANGEL","SN_RECTANGEL","SQUARE","SW_PENTAGON","SE_PENTAGON","NE_PENTAGON","NW_PENTAGON","NW_N_PENTAGON","NE_E_PENTAGON","SE_S_PENTAGON","SW_W_PENTAGON","NW_W_PENTAGON","NE_N_PENTAGON","SE_E_PENTAGON","SW_S_PENTAGON","S_HEXAGON","E_HEXAGON","N_HEXAGON","W_HEXAGON","SW_NE_HEXAGON","NW_SE_HEXAGON","NE_HEPTAGON","SW_HEPTAGON","NW_HEPTAGON","SE_HEPTAGON","OCTAGON","ISOLINES_CODE_OFFSET_MAP","ternaryToIndex","ternary","parseInt","ISOBANDS_CODE_OFFSET_MAP","CONTOUR_TYPE","ISO_LINES","ISO_BANDS","DEFAULT_THRESHOLD_DATA","zIndex","zOffset","getVertexCode","weight","threshold","Array","isArray","getCode","opts","cellWeights","y","width","height","thresholdValue","log","deprecated","isLeftBoundary","isRightBoundary","isBottomBoundary","isTopBoundary","isBoundary","weights","codes","top","topRight","right","current","code","isFinite","meanCode","getVertices","gridOrigin","cellSize","thresholdData","offsets","vZ","rX","rY","refVertexX","refVertexY","polygons","forEach","polygonOffsets","polygon","xyOffset","vX","vY","push","lines","xyOffsets","offset","DEFAULT_COLOR","POSITION_ATTRIBUTE_NAME","DIMENSIONS","data","accessors","ContourLayer","GridAggregationLayer","initializeAggregationLayer","dimensions","setState","contourData","projectPoints","count","operation","AGGREGATION_OPERATION","SUM","add","contoursChanged","oldProps","aggregationDirty","contours","_updateThresholdData","getNumInstances","_generateContours","renderLayers","contourSegments","contourPolygons","LinesSubLayerClass","getSubLayerClass","BandsSubLayerClass","SolidPolygonLayer","getSubLayerProps","d","start","end","contour","color","strokeWidth","getPolygon","vertices","getFillColor","updateAggregationState","coordinateSystem","viewport","cellSizeChanged","gpuAggregation","GPUGridAggregator","isSupported","warn","gpuAggregationChanged","positionsChanged","isAttributeChanged","boundingBox","getBoundingBox","getAttributes","gridOffset","translation","numCol","numRow","getGridParams","allocateResources","posOffset","slice","aggregationDataDirty","isAggregationDirty","dimension","compareAll","aggregationWeightsDirty","_updateAccessors","_resetResults","getWeight","aggregation","getValue","getValueFunc","aggregationData","aggregationBuffer","getData","getCellData","countsData","gridSize","segmentIndex","polygonIndex","i","generateContours","xOffset","yOffset","max","getPosition","position","optional","compare"],"sourceRoot":""}