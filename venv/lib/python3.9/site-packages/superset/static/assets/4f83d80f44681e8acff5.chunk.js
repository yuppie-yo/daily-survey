"use strict";(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[1609,3348],{371609:(e,t,o)=>{o.r(t),o.d(t,{default:()=>w});var n=o(618446),a=o.n(n),i=o(667294),r=o(431069),s=o(785716),l=o(334634),c=o(354998),u=o.n(c);function d(e,t,o=!0,n={}){if(!e.datasource)return;const a=new(u())("/"),i=function(e="base"){let t="/explore/";return["json","csv","query","results","samples"].includes(e)&&(t="/superset/explore_json/"),t}(t),r=a.search(!0);Object.keys(n).forEach((e=>{r[e]=n[e]})),r.form_data=function(e){const t=new Set;return JSON.stringify(e,((e,o)=>{if("object"==typeof o&&null!==o){if(t.has(o))try{return JSON.parse(JSON.stringify(o))}catch(e){return}t.add(o)}return o}))}(e),"standalone"===t&&(r.standalone="true");const s=a.directory(i).search(r).toString();return!o&&s.length>8e3?d({datasource:e.datasource,viz_type:e.viz_type},t,!1,{URL_IS_TOO_LONG_TO_SHARE:null}):s}var g=o(172502),p=o(442932),h=o(97874),m=o(58125),f=o(761778),v=o(1262),x=o(909503),_=o(161563),y=o(602429),S=o(573348);const b={deck_grid:g.getLayer,deck_screengrid:p.getLayer,deck_path:h.getLayer,deck_hex:m.getLayer,deck_scatter:f.getLayer,deck_geojson:v.getLayer,deck_arc:x.getLayer,deck_polygon:_.getLayer,deck_heatmap:y.getLayer,deck_contour:S.getLayer};var C=o(135944);const P=e=>{const t=(0,i.useRef)(),[o,n]=(0,i.useState)(),[c,u]=(0,i.useState)({}),g=(0,i.useCallback)((e=>{const{current:o}=t;o&&o.setTooltip(e)}),[]),p=(0,i.useCallback)(((t,o,a)=>{n(a),u({}),o.data.slices.forEach((o=>{const n=[...o.form_data.filters||[],...t.filters||[],...t.extra_filters||[]],a={...o,form_data:{...o.form_data,filters:n}},i=d(a.form_data,"json");i&&r.Z.get({endpoint:i}).then((({json:t})=>{const o=b[a.form_data.viz_type](a.form_data,t,e.onAddFilter,g,e.datasource,[],e.onSelect);u((e=>({...e,[a.slice_id]:o})))})).catch((()=>{}))}))}),[e.datasource,e.onAddFilter,e.onSelect,g]),h=(0,s.D)(e.formData.deck_slices);(0,i.useEffect)((()=>{const{formData:t,payload:o}=e;!a()(h,t.deck_slices)&&p(t,o)}),[p,h,e]);const{payload:m,formData:f,setControlValue:v,height:x,width:_}=e,y=Object.values(c);return(0,C.tZ)(l.F,{ref:t,mapboxApiAccessToken:m.data.mapboxApiKey,viewport:o||e.viewport,layers:y,mapStyle:f.mapbox_style,setControlValue:v,onViewportChange:n,height:x,width:_})},w=(0,i.memo)(P)},909503:(e,t,o)=>{o.r(t),o.d(t,{default:()=>_,getLayer:()=>x});var n=o(204942),a=o(905259),i=o(537832),r=o(113717),s=o(733321),l=o(339769),c=o(453982);const u=[0,0,0,255],d={getSourcePosition:{type:"accessor",value:e=>e.sourcePosition},getTargetPosition:{type:"accessor",value:e=>e.targetPosition},getSourceColor:{type:"accessor",value:u},getTargetColor:{type:"accessor",value:u},getWidth:{type:"accessor",value:1},getHeight:{type:"accessor",value:1},getTilt:{type:"accessor",value:0},greatCircle:!1,widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0}};class g extends a.Z{constructor(...e){super(...e),(0,n.Z)(this,"state",void 0)}getBounds(){var e;return null===(e=this.getAttributeManager())||void 0===e?void 0:e.getBounds(["instanceSourcePositions","instanceTargetPositions"])}getShaders(){return super.getShaders({vs:"#define SHADER_NAME arc-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\nattribute float instanceHeights;\nattribute float instanceTilts;\n\nuniform bool greatCircle;\nuniform bool useShortestPath;\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform int widthUnits;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nfloat paraboloid(float distance, float sourceZ, float targetZ, float ratio) {\n\n  float deltaZ = targetZ - sourceZ;\n  float dh = distance * instanceHeights;\n  if (dh == 0.0) {\n    return sourceZ + deltaZ * ratio;\n  }\n  float unitZ = deltaZ / dh;\n  float p2 = unitZ * unitZ + 1.0;\n  float dir = step(deltaZ, 0.0);\n  float z0 = mix(sourceZ, targetZ, dir);\n  float r = mix(ratio, 1.0 - ratio, dir);\n  return sqrt(r * (p2 - r)) * dh + z0;\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {\n  float distance = length(source.xy - target.xy);\n  float z = paraboloid(distance, source.z, target.z, segmentRatio);\n\n  float tiltAngle = radians(instanceTilts);\n  vec2 tiltDirection = normalize(target.xy - source.xy);\n  vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\n\n  return vec3(\n    mix(source.xy, target.xy, segmentRatio) + tilt,\n    z * cos(tiltAngle)\n  );\n}\nfloat getAngularDist (vec2 source, vec2 target) {\n  vec2 sourceRadians = radians(source);\n  vec2 targetRadians = radians(target);\n  vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);\n  vec2 shd_sq = sin_half_delta * sin_half_delta;\n\n  float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;\n  return 2.0 * asin(sqrt(a));\n}\n\nvec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {\n  vec2 lngLat;\n  if(abs(angularDist - PI) < 0.001) {\n    lngLat = (1.0 - t) * source.xy + t * target.xy;\n  } else {\n    float a = sin((1.0 - t) * angularDist);\n    float b = sin(t * angularDist);\n    vec3 p = source3D.yxz * a + target3D.yxz * b;\n    lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));\n  }\n\n  float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);\n\n  return vec3(lngLat, z);\n}\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));\n  float nextSegmentRatio = getSegmentRatio(min(numSegments - 1.0, segmentIndex + 1.0));\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  isValid = 1.0;\n\n  uv = vec2(segmentRatio, positions.y);\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n\n  vec4 curr;\n  vec4 next;\n  vec3 source;\n  vec3 target;\n\n  if ((greatCircle || project_uProjectionMode == PROJECTION_MODE_GLOBE) && project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n    source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));\n    target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));\n    float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);\n\n    vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);\n    vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);\n    vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);\n\n    if (abs(currPos.x - prevPos.x) > 180.0) {\n      indexDir = -1.0;\n      isValid = 0.0;\n    } else if (abs(currPos.x - nextPos.x) > 180.0) {\n      indexDir = 1.0;\n      isValid = 0.0;\n    }\n    nextPos = indexDir < 0.0 ? prevPos : nextPos;\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n\n    if (isValid == 0.0) {\n      nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;\n      float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);\n      currPos = mix(currPos, nextPos, t);\n      segmentRatio = mix(segmentRatio, nextSegmentRatio, t);\n    }\n\n    vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);\n    vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);\n  \n    curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);\n    next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));\n  \n  } else {\n    vec3 source_world = instanceSourcePositions;\n    vec3 target_world = instanceTargetPositions;\n    if (useShortestPath) {\n      source_world.x = mod(source_world.x + 180., 360.0) - 180.;\n      target_world.x = mod(target_world.x + 180., 360.0) - 180.;\n\n      float deltaLng = target_world.x - source_world.x;\n      if (deltaLng > 180.) target_world.x -= 360.;\n      if (deltaLng < -180.) source_world.x -= 360.;\n    }\n    source = project_position(source_world, instanceSourcePositions64Low);\n    target = project_position(target_world, instanceTargetPositions64Low);\n    float antiMeridianX = 0.0;\n\n    if (useShortestPath) {\n      if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n        antiMeridianX = -(project_uCoordinateOrigin.x + 180.) / 360. * TILE_SIZE;\n      }\n      float thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);\n\n      if (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {\n        isValid = 0.0;\n        indexDir = sign(segmentRatio - thresholdRatio);\n        segmentRatio = thresholdRatio;\n      }\n    }\n\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n    vec3 currPos = interpolateFlat(source, target, segmentRatio);\n    vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);\n\n    if (useShortestPath) {\n      if (nextPos.x < antiMeridianX) {\n        currPos.x += TILE_SIZE;\n        nextPos.x += TILE_SIZE;\n      }\n    }\n\n    curr = project_common_position_to_clipspace(vec4(currPos, 1.0));\n    next = project_common_position_to_clipspace(vec4(nextPos, 1.0));\n    geometry.position = vec4(currPos, 1.0);\n  }\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels\n  );\n  vec3 offset = vec3(\n    getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  DECKGL_FILTER_GL_POSITION(curr, geometry);\n  gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);\n  vColor = vec4(color.rgb, color.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME arc-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nvoid main(void) {\n  if (isValid == 0.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  geometry.uv = uv;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[i.Z,r.Z]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({instanceSourcePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getSourcePosition"},instanceTargetPositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getTargetPosition"},instanceSourceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getSourceColor",defaultValue:u},instanceTargetColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getTargetColor",defaultValue:u},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1},instanceHeights:{size:1,transition:!0,accessor:"getHeight",defaultValue:1},instanceTilts:{size:1,transition:!0,accessor:"getTilt",defaultValue:0}})}updateState(e){if(super.updateState(e),e.changeFlags.extensionsChanged){var t;const{gl:e}=this.context;null===(t=this.state.model)||void 0===t||t.delete(),this.state.model=this._getModel(e),this.getAttributeManager().invalidateAll()}}draw({uniforms:e}){const{widthUnits:t,widthScale:o,widthMinPixels:n,widthMaxPixels:a,greatCircle:i,wrapLongitude:r}=this.props;this.state.model.setUniforms(e).setUniforms({greatCircle:i,widthUnits:s.iI[t],widthScale:o,widthMinPixels:n,widthMaxPixels:a,useShortestPath:r}).draw()}_getModel(e){let t=[];for(let e=0;e<50;e++)t=t.concat([e,1,0,e,-1,0]);const o=new l.Z(e,{...this.getShaders(),id:this.props.id,geometry:new c.Z({drawMode:5,attributes:{positions:new Float32Array(t)}}),isInstanced:!0});return o.setUniforms({numSegments:50}),o}}(0,n.Z)(g,"layerName","ArcLayer"),(0,n.Z)(g,"defaultProps",d);var p=o(61988),h=o(58371),m=o(589691),f=o(51805),v=o(135944);function x(e,t,o,n){const a=t.data.features,i=e.color_picker,r=e.target_color_picker;return new g({data:a,getSourceColor:e=>e.sourceColor||e.color||[i.r,i.g,i.b,255*i.a],getTargetColor:e=>e.targetColor||e.color||[r.r,r.g,r.b,255*r.a],id:`path-layer-${e.slice_id}`,strokeWidth:e.stroke_width?e.stroke_width:3,...(0,h.N)(e,n,(s=e,e=>{var t,o,n,a,i,r,l,c,u;return(0,v.BX)("div",{className:"deckgl-tooltip",children:[(0,v.tZ)(f.Z,{label:(0,p.t)("Start (Longitude, Latitude): "),value:`${null==(t=e.object)||null==(o=t.sourcePosition)?void 0:o[0]}, ${null==(n=e.object)||null==(a=n.sourcePosition)?void 0:a[1]}`}),(0,v.tZ)(f.Z,{label:(0,p.t)("End (Longitude, Latitude): "),value:`${null==(i=e.object)||null==(r=i.targetPosition)?void 0:r[0]}, ${null==(l=e.object)||null==(c=l.targetPosition)?void 0:c[1]}`}),s.dimension&&(0,v.tZ)(f.Z,{label:`${null==s?void 0:s.dimension}: `,value:`${null==(u=e.object)?void 0:u.cat_color}`})]})}))});var s}const _=(0,m.B)(x,(function(e){const t=[];return e.forEach((e=>{t.push(e.sourcePosition),t.push(e.targetPosition)})),t}))},573348:(e,t,o)=>{o.r(t),o.d(t,{default:()=>g,getLayer:()=>d});var n=o(492219),a=o(61988),i=o(58371),r=o(363241),s=o(589691),l=o(51805),c=o(135944);function u(e){var t,o;return(0,c.BX)("div",{className:"deckgl-tooltip",children:[(0,c.tZ)(l.Z,{label:(0,a.t)("Centroid (Longitude and Latitude): "),value:`(${null==e?void 0:e.coordinate[0]}, ${null==e?void 0:e.coordinate[1]})`}),(0,c.tZ)(l.Z,{label:(0,a.t)("Threshold: "),value:`${null==e||null==(t=e.object)||null==(o=t.contour)?void 0:o.threshold}`})]})}const d=function(e,t,o,a){const s=e,{aggregation:l="SUM",js_data_mutator:c,contours:d,cellSize:g="200"}=s;let p=t.data.features;const h=null==d?void 0:d.map((e=>{const{lowerThreshold:t,upperThreshold:o,color:n,strokeWidth:a}=e;return o?{threshold:[t,o],color:[n.r,n.g,n.b]}:{threshold:t,color:[n.r,n.g,n.b],strokeWidth:a}}));return c&&(p=(0,r.Z)(s.js_data_mutator)(p)),new n.Z({id:`contourLayer-${s.slice_id}`,data:p,contours:h,cellSize:Number(g||"200"),aggregation:l.toUpperCase(),getPosition:e=>e.position,getWeight:e=>e.weight||0,...(0,i.N)(s,a,u)})},g=(0,s.G)(d,(function(e){return e.map((e=>e.position))}))},1262:(e,t,o)=>{o.r(t),o.d(t,{default:()=>C,getLayer:()=>S});var n=o(667294),a=o(763521),i=o(629319),r=o.n(i),s=o(334634),l=o(889503),c=o(363241),u=o(58371),d=o(51805),g=o(340461),p=o(135944);const h={fillColor:"fillColor",color:"fillColor",fill:"fillColor","fill-color":"fillColor",strokeColor:"strokeColor","stroke-color":"strokeColor","stroke-width":"strokeWidth"},m=(e,t)=>{const o={};return Object.keys(e).forEach((t=>{t in h?o[h[t]]=e[t]:o[t]=e[t]})),"string"==typeof e.fillColor&&(o.fillColor=(0,l.hexToRGB)(e.fillColor)),"string"==typeof e.strokeColor&&(o.strokeColor=(0,l.hexToRGB)(e.strokeColor)),{...o,...t}};let f;const v=(e,t,o)=>{if(null!=e&&e.features&&e.features.forEach((n=>{v(n,t,e.extraProps||o)})),null!=e&&e.geometry){const n={...e,properties:m(e.properties,t)};n.extraProps||(n.extraProps=o),f.push(n)}};function x(e){var t;return(null==(t=e.object)?void 0:t.extraProps)&&(0,p.tZ)("div",{className:"deckgl-tooltip",children:Object.keys(e.object.extraProps).map(((t,o)=>{var n;return(0,p.tZ)(d.Z,{label:`${t}: `,value:`${null==(n=e.object.extraProps)?void 0:n[t]}`},`prop-${o}`)}))})}const _=e=>{var t;return null==e||null==(t=e.properties)?void 0:t.fillColor},y=e=>{var t;return null==e||null==(t=e.properties)?void 0:t.strokeColor};function S(e,t,o,n){const i=e,r=i.fill_color_picker,s=i.stroke_color_picker,l=[r.r,r.g,r.b,255*r.a],d=[s.r,s.g,s.b,255*s.a],g={};let p;return l[3]>0&&(g.fillColor=l),d[3]>0&&(g.strokeColor=d),f=[],v(t.data,g),i.js_data_mutator&&(p=(0,c.Z)(i.js_data_mutator),f=p(f)),new a.Z({id:`geojson-layer-${i.slice_id}`,data:f,extruded:i.extruded,filled:i.filled,stroked:i.stroked,getFillColor:_,getLineColor:y,getLineWidth:i.line_width||1,pointRadiusScale:i.point_radius_scale,lineWidthUnits:i.line_width_unit,...(0,u.N)(i,n,x)})}const b=e=>{var t;const o=(0,n.useRef)(),a=(0,n.useCallback)((e=>{const{current:t}=o;t&&t.setTooltip(e)}),[]),{formData:i,payload:l,setControlValue:c,onAddFilter:u,height:d,width:h}=e,m=(0,n.useMemo)((()=>{if(i.autozoom){var t,o;const n=(null==l||null==(t=l.data)||null==(o=t.features)||null==o.reduce?void 0:o.reduce(((e,t)=>{const o=r()(t);return o?[...e,[o[0],o[1]],[o[2],o[3]]]:e}),[]))||[];if(n.length)return(0,g.Z)(e.viewport,{width:h,height:d,points:n})}return e.viewport}),[i.autozoom,d,null==l||null==(t=l.data)?void 0:t.features,e.viewport,h]),f=S(i,l,0,a);return(0,p.tZ)(s.F,{ref:o,mapboxApiAccessToken:l.data.mapboxApiKey,viewport:m,layers:[f],mapStyle:i.mapbox_style,setControlValue:c,height:d,width:h})},C=(0,n.memo)(b)},172502:(e,t,o)=>{o.r(t),o.d(t,{default:()=>h,getLayer:()=>p});var n=o(851047),a=o(61988),i=o(328062),r=o(58371),s=o(363241),l=o(889503),c=o(589691),u=o(51805),d=o(135944);function g(e){return(0,d.BX)("div",{className:"deckgl-tooltip",children:[(0,d.tZ)(u.Z,{label:(0,a.t)("Longitude and Latitude")+": ",value:`${e.coordinate[0]}, ${e.coordinate[1]}`}),(0,d.tZ)(u.Z,{label:(0,a.t)("Height")+": ",value:`${e.object.elevationValue}`})]})}function p(e,t,o,a){const c=e,u=c.color_scheme,d=i.getScale(u).range().map((e=>(0,l.hexToRGB)(e)));let p=t.data.features;c.js_data_mutator&&(p=(0,s.Z)(c.js_data_mutator)(p));const h=(0,r.Z)(c.js_agg_function,(e=>e.weight));return new n.Z({id:`grid-layer-${c.slice_id}`,data:p,cellSize:c.grid_size,extruded:c.extruded,colorRange:d,outline:!1,getElevationValue:h,getColorValue:h,...(0,r.N)(c,a,g)})}const h=(0,c.G)(p,(function(e){return e.map((e=>e.position))}))},602429:(e,t,o)=>{o.r(t),o.d(t,{default:()=>h,getLayer:()=>p});var n=o(185672),a=o(61988),i=o(45511),r=o(58371),s=o(363241),l=o(889503),c=o(589691),u=o(51805),d=o(135944);function g(e){return(0,d.tZ)("div",{className:"deckgl-tooltip",children:(0,d.tZ)(u.Z,{label:(0,a.t)("Centroid (Longitude and Latitude): "),value:`(${null==e?void 0:e.coordinate[0]}, ${null==e?void 0:e.coordinate[1]})`})})}const p=(e,t,o,a)=>{var c,u,d,p;const h=e,{intensity:m=1,radius_pixels:f=30,aggregation:v="SUM",js_data_mutator:x,linear_color_scheme:_}=h;let y=t.data.features;x&&(y=(0,s.Z)(h.js_data_mutator)(y));const S=null==(c=(0,i.Z)())||null==(u=c.get(_))?void 0:u.createLinearScale([0,6]),b=null==S||null==(d=S.range())||null==(p=d.map((e=>(0,l.hexToRGB)(e))))?void 0:p.reverse();return new n.Z({id:`heatmp-layer-${h.slice_id}`,data:y,intensity:m,radiusPixels:f,colorRange:b,aggregation:v.toUpperCase(),getPosition:e=>e.position,getWeight:e=>e.weight?e.weight:1,...(0,r.N)(h,a,g)})},h=(0,c.G)(p,(function(e){return e.map((e=>e.position))}))},58125:(e,t,o)=>{o.r(t),o.d(t,{default:()=>Z,getLayer:()=>L});var n=o(204942),a=o(541576),i=o(643444),r=o(579543),s=Math.PI/3,l=[0,s,2*s,3*s,4*s,5*s];function c(e){return e[0]}function u(e){return e[1]}var d=o(260930),g=o(311959),p=o(389033);function h(){}const m={colorDomain:null,colorRange:r.K,getColorValue:{type:"accessor",value:null},getColorWeight:{type:"accessor",value:1},colorAggregation:"SUM",lowerPercentile:{type:"number",value:0,min:0,max:100},upperPercentile:{type:"number",value:100,min:0,max:100},colorScaleType:"quantize",onSetColorDomain:h,elevationDomain:null,elevationRange:[0,1e3],getElevationValue:{type:"accessor",value:null},getElevationWeight:{type:"accessor",value:1},elevationAggregation:"SUM",elevationLowerPercentile:{type:"number",value:0,min:0,max:100},elevationUpperPercentile:{type:"number",value:100,min:0,max:100},elevationScale:{type:"number",min:0,value:1},elevationScaleType:"linear",onSetElevationDomain:h,radius:{type:"number",value:1e3,min:1},coverage:{type:"number",min:0,max:1,value:1},extruded:!1,hexagonAggregator:function(e,t){const{data:o,radius:n}=e,{viewport:i,attributes:r}=t,g=o.length?function(e,t){const{attributes:o}=t,n=o.positions.value,{size:a}=o.positions.getAccessor();let i,r=1/0,s=1/0,l=-1/0,c=-1/0;for(i=0;i<a*e.length;i+=a){const e=n[i],t=n[i+1];Number.isFinite(e)&&Number.isFinite(t)&&(r=Math.min(e,r),l=Math.max(e,l),s=Math.min(t,s),c=Math.max(t,c))}return[r,s,l,c].every(Number.isFinite)?[(r+l)/2,(s+c)/2]:null}(o,t):null,p=function(e,t,o){const{unitsPerMeter:n}=t.getDistanceScales(o);return e*n[0]}(n,i,g),h=[],{iterable:m,objectInfo:f}=(0,d.jB)(o),v=r.positions.value,{size:x}=r.positions.getAccessor();for(const e of m){f.index++;const t=f.index*x,o=[v[t],v[t+1]];Number.isFinite(o[0])&&Number.isFinite(o[1])?h.push({screenCoord:i.projectFlat(o),source:e,index:f.index}):a.Z.warn("HexagonLayer: invalid position")()}const _=function(){var e,t,o,n=0,a=0,i=1,r=1,d=c,g=u;function p(e){var n,a={},i=[],r=e.length;for(n=0;n<r;++n)if(!isNaN(l=+d.call(null,s=e[n],n,e))&&!isNaN(c=+g.call(null,s,n,e))){var s,l,c,u=Math.round(c/=o),p=Math.round(l=l/t-(1&u)/2),h=c-u;if(3*Math.abs(h)>1){var m=l-p,f=p+(l<p?-1:1)/2,v=u+(c<u?-1:1),x=l-f,_=c-v;m*m+h*h>x*x+_*_&&(p=f+(1&u?1:-1)/2,u=v)}var y=p+"-"+u,S=a[y];S?S.push(s):(i.push(S=a[y]=[s]),S.x=(p+(1&u)/2)*t,S.y=u*o)}return i}function h(e){var t=0,o=0;return l.map((function(n){var a=Math.sin(n)*e,i=-Math.cos(n)*e,r=a-t,s=i-o;return t=a,o=i,[r,s]}))}return p.hexagon=function(t){return"m"+h(null==t?e:+t).join("l")+"z"},p.centers=function(){for(var s=[],l=Math.round(a/o),c=Math.round(n/t),u=l*o;u<r+e;u+=o,++l)for(var d=c*t+(1&l)*t/2;d<i+t/2;d+=t)s.push([d,u]);return s},p.mesh=function(){var t=h(e).slice(0,4).join("l");return p.centers().map((function(e){return"M"+e+"m"+t})).join("")},p.x=function(e){return arguments.length?(d=e,p):d},p.y=function(e){return arguments.length?(g=e,p):g},p.radius=function(n){return arguments.length?(t=2*(e=+n)*Math.sin(s),o=1.5*e,p):e},p.size=function(e){return arguments.length?(n=a=0,i=+e[0],r=+e[1],p):[i-n,r-a]},p.extent=function(e){return arguments.length?(n=+e[0][0],a=+e[0][1],i=+e[1][0],r=+e[1][1],p):[[n,a],[i,r]]},p.radius(1)}().radius(p).x((e=>e.screenCoord[0])).y((e=>e.screenCoord[1]));return{hexagons:_(h).map(((e,t)=>({position:i.unprojectFlat([e.x,e.y]),points:e,index:t}))),radiusCommon:p}},getPosition:{type:"accessor",value:e=>e.position},material:!0,_filterData:{type:"function",value:null,optional:!0}};class f extends p.Z{constructor(...e){super(...e),(0,n.Z)(this,"state",void 0)}initializeState(){const e=new g.Z({getAggregator:e=>e.hexagonAggregator,getCellSize:e=>e.radius});this.state={cpuAggregator:e,aggregatorState:e.state,vertices:null},this.getAttributeManager().add({positions:{size:3,type:5130,accessor:"getPosition"}})}updateState(e){if(super.updateState(e),e.changeFlags.propsOrDataChanged){const t=this.state.cpuAggregator.updateState(e,{viewport:this.context.viewport,attributes:this.getAttributes()});if(this.state.aggregatorState.layerData!==t.layerData){const{hexagonVertices:e}=t.layerData||{};this.setState({vertices:e&&this.convertLatLngToMeterOffset(e)})}this.setState({aggregatorState:t})}}convertLatLngToMeterOffset(e){const{viewport:t}=this.context;if(Array.isArray(e)&&6===e.length){const o=e[0],n=e[3],a=[(o[0]+n[0])/2,(o[1]+n[1])/2],i=t.projectFlat(a),{metersPerUnit:r}=t.getDistanceScales(a);return e.map((e=>{const o=t.projectFlat(e);return[(o[0]-i[0])*r[0],(o[1]-i[1])*r[1]]}))}return a.Z.error("HexagonLayer: hexagonVertices needs to be an array of 6 points")(),null}getPickingInfo({info:e}){return this.state.cpuAggregator.getPickingInfo({info:e})}_onGetSublayerColor(e){return this.state.cpuAggregator.getAccessor("fillColor")(e)}_onGetSublayerElevation(e){return this.state.cpuAggregator.getAccessor("elevation")(e)}_getSublayerUpdateTriggers(){return this.state.cpuAggregator.getUpdateTriggers(this.props)}renderLayers(){const{elevationScale:e,extruded:t,coverage:o,material:n,transitions:a}=this.props,{aggregatorState:r,vertices:s}=this.state,l=this.getSubLayerClass("hexagon-cell",i.Z),c=this._getSublayerUpdateTriggers();return new l({...s?{vertices:s,radius:1}:{radius:r.layerData.radiusCommon||1,radiusUnits:"common",angle:90},diskResolution:6,elevationScale:e,extruded:t,coverage:o,material:n,getFillColor:this._onGetSublayerColor.bind(this),getElevation:this._onGetSublayerElevation.bind(this),transitions:a&&{getFillColor:a.getColorValue||a.getColorWeight,getElevation:a.getElevationValue||a.getElevationWeight}},this.getSubLayerProps({id:"hexagon-cell",updateTriggers:c}),{data:r.layerData.data})}}(0,n.Z)(f,"layerName","HexagonLayer"),(0,n.Z)(f,"defaultProps",m);var v=o(61988),x=o(328062),_=o(58371),y=o(363241),S=o(889503),b=o(589691),C=o(51805),P=o(135944);function w(e){return(0,P.BX)("div",{className:"deckgl-tooltip",children:[(0,P.tZ)(C.Z,{label:(0,v.t)("Centroid (Longitude and Latitude): "),value:`(${e.coordinate[0]}, ${e.coordinate[1]})`}),(0,P.tZ)(C.Z,{label:(0,v.t)("Height")+": ",value:`${e.object.elevationValue}`})]})}function L(e,t,o,n){const a=e,i=a.color_scheme,r=x.getScale(i).range().map((e=>(0,S.hexToRGB)(e)));let s=t.data.features;a.js_data_mutator&&(s=(0,y.Z)(a.js_data_mutator)(s));const l=(0,_.Z)(a.js_agg_function,(e=>null==e?void 0:e.weight));return new f({id:`hex-layer-${a.slice_id}`,data:s,radius:a.grid_size,extruded:a.extruded,colorRange:r,outline:!1,getElevationValue:l,getColorValue:l,...(0,_.N)(a,n,w)})}const Z=(0,b.G)(L,(function(e){return e.map((e=>e.position))}))},97874:(e,t,o)=>{o.r(t),o.d(t,{default:()=>d,getLayer:()=>u});var n=o(248897),a=o(58371),i=o(363241),r=o(589691),s=o(51805),l=o(135944);function c(e){var t;return(null==(t=e.object)?void 0:t.extraProps)&&(0,l.tZ)("div",{className:"deckgl-tooltip",children:Object.keys(e.object.extraProps).map(((t,o)=>(0,l.tZ)(s.Z,{label:`${t}: `,value:`${e.object.extraProps[t]}`},`prop-${o}`)))})}function u(e,t,o,r){const s=e,l=s.color_picker,u=[l.r,l.g,l.b,255*l.a];let d=t.data.features.map((e=>({...e,path:e.path,width:s.line_width,color:u})));return s.js_data_mutator&&(d=(0,i.Z)(s.js_data_mutator)(d)),new n.Z({id:`path-layer-${s.slice_id}`,getColor:e=>e.color,getPath:e=>e.path,getWidth:e=>e.width,data:d,rounded:!0,widthScale:1,widthUnits:s.line_width_unit,...(0,a.N)(s,r,c)})}const d=(0,r.G)(u,(function(e){let t=[];return e.forEach((e=>{t=t.concat(e.path)})),t}))},161563:(e,t,o)=>{o.r(t),o.d(t,{default:()=>E,getLayer:()=>j});var n=o(667294),a=o(61988),i=o(204942),r=o(336750),s=o(541576),l=o(260930),c=o(491567),u=o(248897),d=o(140245),g=o(367186);const p=[0,0,0,255],h={stroked:!0,filled:!0,extruded:!1,elevationScale:1,wireframe:!1,_normalize:!0,_windingOrder:"CW",lineWidthUnits:"meters",lineWidthScale:1,lineWidthMinPixels:0,lineWidthMaxPixels:Number.MAX_SAFE_INTEGER,lineJointRounded:!1,lineMiterLimit:4,getPolygon:{type:"accessor",value:e=>e.polygon},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:p},getLineWidth:{type:"accessor",value:1},getElevation:{type:"accessor",value:1e3},material:!0};class m extends r.Z{initializeState(){this.state={paths:[]},this.props.getLineDashArray&&s.Z.removed("getLineDashArray","PathStyleExtension")()}updateState({changeFlags:e}){const t=e.dataChanged||e.updateTriggersChanged&&(e.updateTriggersChanged.all||e.updateTriggersChanged.getPolygon);if(t&&Array.isArray(e.dataChanged)){const t=this.state.paths.slice(),o=e.dataChanged.map((e=>(0,g.b)({data:t,getIndex:e=>e.__source.index,dataRange:e,replace:this._getPaths(e)})));this.setState({paths:t,pathsDiff:o})}else t&&this.setState({paths:this._getPaths(),pathsDiff:null})}_getPaths(e={}){const{data:t,getPolygon:o,positionFormat:n,_normalize:a}=this.props,i=[],r="XY"===n?2:3,{startRow:s,endRow:c}=e,{iterable:u,objectInfo:g}=(0,l.jB)(t,s,c);for(const e of u){g.index++;let t=o(e,g);a&&(t=d.Fv(t,r));const{holeIndices:n}=t,s=t.positions||t;if(n)for(let t=0;t<=n.length;t++){const o=s.slice(n[t-1]||0,n[t]||s.length);i.push(this.getSubLayerRow({path:o},e,g.index))}else i.push(this.getSubLayerRow({path:s},e,g.index))}return i}renderLayers(){const{data:e,_dataDiff:t,stroked:o,filled:n,extruded:a,wireframe:i,_normalize:r,_windingOrder:s,elevationScale:l,transitions:d,positionFormat:g}=this.props,{lineWidthUnits:h,lineWidthScale:m,lineWidthMinPixels:f,lineWidthMaxPixels:v,lineJointRounded:x,lineMiterLimit:_,lineDashJustified:y}=this.props,{getFillColor:S,getLineColor:b,getLineWidth:C,getLineDashArray:P,getElevation:w,getPolygon:L,updateTriggers:Z,material:R}=this.props,{paths:M,pathsDiff:A}=this.state,D=this.getSubLayerClass("fill",c.Z),T=this.getSubLayerClass("stroke",u.Z),k=this.shouldRenderSubLayer("fill",M)&&new D({_dataDiff:t,extruded:a,elevationScale:l,filled:n,wireframe:i,_normalize:r,_windingOrder:s,getElevation:w,getFillColor:S,getLineColor:a&&i?b:p,material:R,transitions:d},this.getSubLayerProps({id:"fill",updateTriggers:Z&&{getPolygon:Z.getPolygon,getElevation:Z.getElevation,getFillColor:Z.getFillColor,lineColors:a&&i,getLineColor:Z.getLineColor}}),{data:e,positionFormat:g,getPolygon:L});return[!a&&k,!a&&o&&this.shouldRenderSubLayer("stroke",M)&&new T({_dataDiff:A&&(()=>A),widthUnits:h,widthScale:m,widthMinPixels:f,widthMaxPixels:v,jointRounded:x,miterLimit:_,dashJustified:y,_pathType:"loop",transitions:d&&{getWidth:d.getLineWidth,getColor:d.getLineColor,getPath:d.getPolygon},getColor:this.getSubLayerAccessor(b),getWidth:this.getSubLayerAccessor(C),getDashArray:this.getSubLayerAccessor(P)},this.getSubLayerProps({id:"stroke",updateTriggers:Z&&{getWidth:Z.getLineWidth,getColor:Z.getLineColor,getDashArray:Z.getLineDashArray}}),{data:M,positionFormat:g,getPath:e=>e.path}),a&&k]}}(0,i.Z)(m,"layerName","PolygonLayer"),(0,i.Z)(m,"defaultProps",h);var f=o(570325),v=o(51805),x=o(281763),_=o.n(x),y=o(804065),S=o(539828),b=o(902995),C=o(45511),P=o(889503);const w=10;function L({break_points:e,num_buckets:t},o,n){if(!o)return[];if(void 0===e||0===e.length){const e=t?parseInt(t,10):w,[a,i]=(0,y.extent)(o,n).map((e=>"string"==typeof e?parseFloat(e):e));if(void 0===a||void 0===i)return[];const r=(i-a)/e,s=0===r?0:Math.max(0,Math.ceil(Math.log10(1/r))),l=i>parseFloat(i.toFixed(s))?1:0,c=a<parseFloat(a.toFixed(s))?a-1:a;return new Array(e+1+l).fill(0).map(((e,t)=>(c+t*r).toFixed(s)))}return e.sort(((e,t)=>parseFloat(e)-parseFloat(t)))}function Z({break_points:e,num_buckets:t,linear_color_scheme:o,opacity:n},a,i){const r=e||t?L({break_points:e,num_buckets:t},a,i):null,s=Array.isArray(o)?new b.Z({colors:o,id:"custom"}):(0,C.Z)().get(o);if(!s)return null;let l,c;if(null!==r){const e=r.length-1,t=e>1?s.getColors(e):[s.colors[s.colors.length-1]],o=t[0],n=t[t.length-1];t.unshift(o),t.push(n);const a=r.map(parseFloat);l=(0,S.Z)().domain(a).range(t),c=t=>!!t&&(t>a[e]||t<a[0])}else{const e=(0,y.extent)(a,i);l=e.some(_())?s.createLinearScale((0,y.extent)(a,i)):s.createLinearScale(),c=()=>!1}return e=>{const t=i(e);if(!t)return[0,0,0,0];const o=(0,P.hexToRGB)(l(t));return c(t)?o[3]=0:o[3]=n/100*255,o}}var R=o(58371),M=o(363241);function A(e){return"geometry"in e.polygon?e.polygon.geometry.coordinates[0]:e.polygon}var D=o(340461),T=o(334634),k=o(135944);function j(e,t,o,n,i,r){const s=e,l=s.fill_color_picker,c=s.stroke_color_picker;let u=[...t.data.features];s.js_data_mutator&&(u=(0,M.Z)(s.js_data_mutator)(u));const d=s.metric?s.metric.label||s.metric:null,g=null===s.metric?()=>[l.r,l.g,l.b,255*l.a]:Z(s,u,(e=>e[d])),p=e=>{const t=(null==g?void 0:g(e))||[0,0,0,0];return i.length>0&&!i.includes(e[s.line_column])&&(t[3]/=2),t},h=s.line_column&&s.metric&&["json","geohash","zipcode"].includes(s.line_type)?function(e){return t=>{var o,n,i,r;const s=(null==e||null==(o=e.metric)?void 0:o.label)||(null==e?void 0:e.metric);return(0,k.BX)("div",{className:"deckgl-tooltip",children:[(null==(n=t.object)?void 0:n.name)&&(0,k.tZ)(v.Z,{label:(0,a.t)("name")+": ",value:`${t.object.name}`}),(null==(i=t.object)?void 0:i[null==e?void 0:e.line_column])&&(0,k.tZ)(v.Z,{label:`${e.line_column}: `,value:`${t.object[e.line_column]}`}),(null==e?void 0:e.metric)&&(0,k.tZ)(v.Z,{label:`${s}: `,value:`${null==(r=t.object)?void 0:r[s]}`})]})}}(s):()=>null;return new m({id:`path-layer-${s.slice_id}`,data:u,filled:s.filled,stroked:s.stroked,getPolygon:A,getFillColor:p,getLineColor:[c.r,c.g,c.b,255*c.a],getLineWidth:s.line_width,extruded:s.extruded,lineWidthUnits:s.line_width_unit,getElevation:e=>function(e,t){return 0===t(e)[3]?0:e.elevation}(e,p),elevationScale:s.multiplier,fp64:!0,...(0,R.N)(s,n,h,r)})}const z=e=>{const t=(0,n.useRef)(),o=(0,n.useCallback)((()=>{let t={...e.viewport};if(e.formData.autozoom){const o=e.payload.data.features||[];t=(0,D.Z)(t,{width:e.width,height:e.height,points:o.flatMap(A)})}return t.zoom<0&&(t.zoom=0),t}),[e]),[a,i]=(0,n.useState)(0),[r,s]=(0,n.useState)(o()),[l,c]=(0,n.useState)(e.payload.form_data),[u,d]=(0,n.useState)([]);(0,n.useEffect)((()=>{const{payload:t}=e;t.form_data!==l&&(s(o()),d([]),i(0),c(t.form_data))}),[o,e,l,r]);const g=(0,n.useCallback)((e=>{const{current:o}=t;o&&o.setTooltip(e)}),[]),p=(0,n.useCallback)((t=>{const{formData:o,onAddFilter:n}=e,r=(new Date).getDate(),s=r-a<=250,l=[...u];if(s)l.splice(0,l.length,t);else if(o.toggle_polygons){const e=l.indexOf(t);-1===e?l.push(t):l.splice(e,1)}else l.splice(0,1,t);d(l),i(r),o.table_filter&&n(o.line_column,u,!1,!0)}),[a,e,u]),h=(0,n.useCallback)((()=>void 0===e.payload.data.features?[]:[j(e.formData,e.payload,e.onAddFilter,g,u,p)]),[p,e.formData,e.onAddFilter,e.payload,u,g]),{payload:m,formData:v,setControlValue:x}=e,_=v.metric?v.metric.label||v.metric:null,y=function(e,t,o){const n=L(e,t,o),a=Z(e,t,o),i={};return n.slice(1).forEach(((t,o)=>{const r=`${n[o]} - ${n[o+1]}`,s=.5*(parseFloat(n[o])+parseFloat(n[o+1])),l=e.metric?e.metric.label||e.metric:null;i[r]={color:null==a?void 0:a({[l||e.metric]:s}),enabled:!0}})),i}(v,m.data.features,(e=>e[_]));return(0,k.BX)("div",{style:{position:"relative"},children:[(0,k.tZ)(T.F,{ref:t,viewport:r,layers:h(),setControlValue:x,mapStyle:v.mapbox_style,mapboxApiAccessToken:m.data.mapboxApiKey,width:e.width,height:e.height}),null!==v.metric&&(0,k.tZ)(f.Z,{categories:y,position:v.legend_position,format:v.legend_format})]})},E=(0,n.memo)(z)},761778:(e,t,o)=>{o.r(t),o.d(t,{default:()=>p,getLayer:()=>g});var n=o(573715),a=o(956652),i=o(61988),r=o(58371),s=o(589691),l=o(51805);const c=1609.34;var u=o(135944);function d(e,t){return o=>{var n,r,s,c,d,g,p,h,m;const f=(null==t?void 0:t[e.point_radius_fixed.value])||(0,a.Z)(null==(n=e.point_radius_fixed)?void 0:n.value);return(0,u.BX)("div",{className:"deckgl-tooltip",children:[(0,u.tZ)(l.Z,{label:(0,i.t)("Longitude and Latitude")+": ",value:`${null==(r=o.object)||null==(s=r.position)?void 0:s[0]}, ${null==(c=o.object)||null==(d=c.position)?void 0:d[1]}`}),(null==(g=o.object)?void 0:g.cat_color)&&(0,u.tZ)(l.Z,{label:(0,i.t)("Category")+": ",value:`${null==(p=o.object)?void 0:p.cat_color}`}),(null==(h=o.object)?void 0:h.metric)&&(0,u.tZ)(l.Z,{label:`${f}: `,value:`${null==(m=o.object)?void 0:m.metric}`})]})}}function g(e,t,o,a,i){const s=e,l=t.data.features.map((e=>{let t=(o=s.point_unit,n=e.radius,("square_m"===o?Math.sqrt(n/Math.PI):"radius_m"===o?n:"radius_km"===o?1e3*n:"radius_miles"===o?n*c:"square_km"===o?1e3*Math.sqrt(n/Math.PI):"square_miles"===o?Math.sqrt(n/Math.PI)*c:null)||10);var o,n;if(s.multiplier&&(t*=s.multiplier),e.color)return{...e,radius:t};const a=s.color_picker||{r:0,g:0,b:0,a:1},i=[a.r,a.g,a.b,255*a.a];return{...e,radius:t,color:i}}));return new n.Z({id:`scatter-layer-${s.slice_id}`,data:l,fp64:!0,getFillColor:e=>e.color,getRadius:e=>e.radius,radiusMinPixels:Number(s.min_radius)||void 0,radiusMaxPixels:Number(s.max_radius)||void 0,stroked:!1,...(0,r.N)(s,a,d(s,null==i?void 0:i.verboseMap))})}const p=(0,s.B)(g,(function(e){return e.map((e=>e.position))}))},442932:(e,t,o)=>{o.r(t),o.d(t,{default:()=>N,getLayer:()=>E});var n=o(850308),a=o.n(n),i=o(667294),r=o(204942),s=o(541576),l=o(772958),c=o(844059),u=o(844211),d=o(106948),g=o(339769),p=o(453982),h=o(905259),m=o(113717),f=o(579543);const v=[0,0,0,0],x=[0,255,0,255],_=["minColor","maxColor","colorRange","colorDomain"],y={cellSizePixels:{value:100,min:1},cellMarginPixels:{value:2,min:0,max:5},colorDomain:null,colorRange:f.K};class S extends h.Z{constructor(...e){super(...e),(0,r.Z)(this,"state",void 0)}static isSupported(e){return(0,u.ag)(e,[d.h.TEXTURE_FLOAT])}getShaders(){return{vs:"#define SHADER_NAME screen-grid-layer-vertex-shader\n#define RANGE_COUNT 6\n\nattribute vec3 positions;\nattribute vec3 instancePositions;\nattribute vec4 instanceCounts;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform vec3 cellScale;\nuniform vec4 minColor;\nuniform vec4 maxColor;\nuniform vec4 colorRange[RANGE_COUNT];\nuniform vec2 colorDomain;\nuniform bool shouldUseMinMax;\nuniform sampler2D maxTexture;\n\nvarying vec4 vColor;\nvarying float vSampleCount;\n\nvec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {\n  vec4 outColor = vec4(0., 0., 0., 0.);\n  if (value >= domain.x && value <= domain.y) {\n    float domainRange = domain.y - domain.x;\n    if (domainRange <= 0.) {\n      outColor = colorRange[0];\n    } else {\n      float rangeCount = float(RANGE_COUNT);\n      float rangeStep = domainRange / rangeCount;\n      float idx = floor((value - domain.x) / rangeStep);\n      idx = clamp(idx, 0., rangeCount - 1.);\n      int intIdx = int(idx);\n      outColor = colorRange[intIdx];\n    }\n  }\n  outColor = outColor / 255.;\n  return outColor;\n}\n\nvoid main(void) {\n  vSampleCount = instanceCounts.a;\n\n  float weight = instanceCounts.r;\n  float maxWeight = texture2D(maxTexture, vec2(0.5)).r;\n\n  float step = weight / maxWeight;\n  vec4 minMaxColor = mix(minColor, maxColor, step) / 255.;\n\n  vec2 domain = colorDomain;\n  float domainMaxValid = float(colorDomain.y != 0.);\n  domain.y = mix(maxWeight, colorDomain.y, domainMaxValid);\n  vec4 rangeColor = quantizeScale(domain, colorRange, weight);\n\n  float rangeMinMax = float(shouldUseMinMax);\n  vec4 color = mix(rangeColor, minMaxColor, rangeMinMax);\n  vColor = vec4(color.rgb, color.a * opacity);\n  picking_setPickingColor(instancePickingColors);\n\n  gl_Position = vec4(instancePositions + positions * cellScale, 1.);\n}\n",fs:"#define SHADER_NAME screen-grid-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying float vSampleCount;\n\nvoid main(void) {\n  if (vSampleCount <= 0.0) {\n    discard;\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[m.Z]}}initializeState(){const{gl:e}=this.context;this.getAttributeManager().addInstanced({instancePositions:{size:3,update:this.calculateInstancePositions},instanceCounts:{size:4,noAlloc:!0}}),this.setState({model:this._getModel(e)})}shouldUpdateState({changeFlags:e}){return e.somethingChanged}updateState(e){super.updateState(e);const{oldProps:t,props:o,changeFlags:n}=e,a=this.getAttributeManager();o.numInstances!==t.numInstances?a.invalidateAll():t.cellSizePixels!==o.cellSizePixels&&a.invalidate("instancePositions"),this._updateUniforms(t,o,n)}draw({uniforms:e}){const{parameters:t,maxTexture:o}=this.props,n=this.props.minColor||v,a=this.props.maxColor||x,i=this.props.colorDomain||[1,0],{model:r}=this.state;r.setUniforms(e).setUniforms({minColor:n,maxColor:a,maxTexture:o,colorDomain:i}).draw({parameters:{depthTest:!1,depthMask:!1,...t}})}calculateInstancePositions(e,{numInstances:t}){const{width:o,height:n}=this.context.viewport,{cellSizePixels:a}=this.props,i=Math.ceil(o/a),{value:r,size:s}=e;for(let e=0;e<t;e++){const t=e%i,l=Math.floor(e/i);r[e*s+0]=t*a/o*2-1,r[e*s+1]=1-l*a/n*2,r[e*s+2]=0}}_getModel(e){return new g.Z(e,{...this.getShaders(),id:this.props.id,geometry:new p.Z({drawMode:6,attributes:{positions:new Float32Array([0,0,0,1,0,0,1,1,0,0,1,0])}}),isInstanced:!0})}_shouldUseMinMax(){const{minColor:e,maxColor:t,colorDomain:o,colorRange:n}=this.props;return e||t?(s.Z.deprecated("ScreenGridLayer props: minColor and maxColor","colorRange, colorDomain")(),!0):!o&&!n}_updateUniforms(e,t,o){const{model:n}=this.state;if(_.some((o=>e[o]!==t[o]))&&n.setUniforms({shouldUseMinMax:this._shouldUseMinMax()}),e.colorRange!==t.colorRange&&n.setUniforms({colorRange:(0,f.P)(t.colorRange)}),e.cellMarginPixels!==t.cellMarginPixels||e.cellSizePixels!==t.cellSizePixels||o.viewportChanged){const{width:e,height:t}=this.context.viewport,{cellSizePixels:o,cellMarginPixels:a}=this.props,i=o>a?a:0,r=new Float32Array([(o-i)/e*2,-(o-i)/t*2,1]);n.setUniforms({cellScale:r})}}}(0,r.Z)(S,"layerName","ScreenGridCellLayer"),(0,r.Z)(S,"defaultProps",y);var b=o(392026),C=o(421900);const P={...S.defaultProps,getPosition:{type:"accessor",value:e=>e.position},getWeight:{type:"accessor",value:1},gpuAggregation:!0,aggregation:"SUM"},w="positions",L={data:{props:["cellSizePixels"]},weights:{props:["aggregation"],accessors:["getWeight"]}};class Z extends b.Z{constructor(...e){super(...e),(0,r.Z)(this,"state",void 0)}initializeState(){const{gl:e}=this.context;if(!S.isSupported(e))return this.setState({supported:!1}),void s.Z.error("ScreenGridLayer: ".concat(this.id," is not supported on this browser"))();super.initializeAggregationLayer({dimensions:L,getCellSize:e=>e.cellSizePixels});const t={count:{size:1,operation:c.KM.SUM,needMax:!0,maxTexture:(0,C.hq)(e,{id:"".concat(this.id,"-max-texture")})}};this.setState({supported:!0,projectPoints:!0,weights:t,subLayerData:{attributes:{}},maxTexture:t.count.maxTexture,positionAttributeName:"positions",posOffset:[0,0],translation:[1,-1]}),this.getAttributeManager().add({[w]:{size:3,accessor:"getPosition",type:5130,fp64:this.use64bitPositions()},count:{size:3,accessor:"getWeight"}})}shouldUpdateState({changeFlags:e}){return this.state.supported&&e.somethingChanged}updateState(e){super.updateState(e)}renderLayers(){if(!this.state.supported)return[];const{maxTexture:e,numRow:t,numCol:o,weights:n}=this.state,{updateTriggers:a}=this.props,{aggregationBuffer:i}=n.count;return new(this.getSubLayerClass("cells",S))(this.props,this.getSubLayerProps({id:"cell-layer",updateTriggers:a}),{data:{attributes:{instanceCounts:i}},maxTexture:e,numInstances:t*o})}finalizeState(e){super.finalizeState(e);const{aggregationBuffer:t,maxBuffer:o,maxTexture:n}=this.state;null==t||t.delete(),null==o||o.delete(),null==n||n.delete()}getPickingInfo({info:e}){const{index:t}=e;if(t>=0){const{gpuGridAggregator:o,gpuAggregation:n,weights:a}=this.state,i=n?o.getData("count"):a.count;e.object=l.Z.getAggregationData({pixelIndex:t,...i})}return e}updateResults({aggregationData:e,maxData:t}){const{count:o}=this.state.weights;o.aggregationData=e,o.aggregationBuffer.setData({data:e}),o.maxData=t,o.maxTexture.setImageData({data:t})}updateAggregationState(e){const t=e.props.cellSizePixels,o=e.oldProps.cellSizePixels!==t,{viewportChanged:n}=e.changeFlags;let a=e.props.gpuAggregation;this.state.gpuAggregation!==e.props.gpuAggregation&&a&&!l.Z.isSupported(this.context.gl)&&(s.Z.warn("GPU Grid Aggregation not supported, falling back to CPU")(),a=!1);const i=a!==this.state.gpuAggregation;this.setState({gpuAggregation:a});const r=this.isAttributeChanged(w),{dimensions:c}=this.state,{data:u,weights:d}=c,g=r||i||n||this.isAggregationDirty(e,{compareAll:a,dimension:u}),p=this.isAggregationDirty(e,{dimension:d});this.setState({aggregationDataDirty:g,aggregationWeightsDirty:p});const{viewport:h}=this.context;if(n||o){const{width:e,height:o}=h,n=Math.ceil(e/t),a=Math.ceil(o/t);this.allocateResources(a,n),this.setState({scaling:[e/2,-o/2,1],gridOffset:{xOffset:t,yOffset:t},width:e,height:o,numCol:n,numRow:a})}p&&this._updateAccessors(e),(g||p)&&this._resetResults()}_updateAccessors(e){const{getWeight:t,aggregation:o,data:n}=e.props,{count:a}=this.state.weights;a&&(a.getWeight=t,a.operation=c.KM[o]),this.setState({getValue:(0,c._D)(o,t,{data:n})})}_resetResults(){const{count:e}=this.state.weights;e&&(e.aggregationData=null)}}(0,r.Z)(Z,"layerName","ScreenGridLayer"),(0,r.Z)(Z,"defaultProps",P);var R=o(61988),M=o(363241),A=o(58371),D=o(51805),T=o(340461),k=o(334634),j=o(135944);function z(e){var t,o,n;return(0,j.BX)("div",{className:"deckgl-tooltip",children:[(0,j.tZ)(D.Z,{label:(0,R.t)("Longitude and Latitude")+": ",value:`${null==e||null==(t=e.coordinate)?void 0:t[0]}, ${null==e||null==(o=e.coordinate)?void 0:o[1]}`}),(0,j.tZ)(D.Z,{label:(0,R.t)("Weight")+": ",value:`${null==(n=e.object)?void 0:n.cellWeight}`})]})}function E(e,t,o,n){const a=e,i=a.color_picker;let r=t.data.features.map((e=>({...e,color:[i.r,i.g,i.b,255*i.a]})));return a.js_data_mutator&&(r=(0,M.Z)(a.js_data_mutator)(r)),new Z({id:`screengrid-layer-${a.slice_id}`,data:r,cellSizePixels:a.grid_size,minColor:[i.r,i.g,i.b,0],maxColor:[i.r,i.g,i.b,255*i.a],outline:!1,getWeight:e=>e.weight||0,...(0,A.N)(a,n,z)})}const F=e=>{const t=(0,i.useRef)(),o=(0,i.useCallback)((()=>{const t=e.payload.data.features||[],{width:o,height:n,formData:a}=e;return a.autozoom?(0,T.Z)(e.viewport,{width:o,height:n,points:(i=t,i.map((e=>e.position)))}):e.viewport;var i}),[e]),[n,r]=(0,i.useState)(e.payload.form_data),[s,l]=(0,i.useState)(o());(0,i.useEffect)((()=>{e.payload.form_data!==n&&(l(o()),r(e.payload.form_data))}),[o,e.payload.form_data,n]);const c=(0,i.useCallback)((e=>{const{current:o}=t;o&&o.setTooltip(e)}),[]),u=(0,i.useCallback)((()=>[E(e.formData,e.payload,a(),c)]),[e.formData,e.payload,c]),{formData:d,payload:g,setControlValue:p}=e;return(0,j.tZ)("div",{children:(0,j.tZ)(k.F,{ref:t,viewport:s,layers:u(),setControlValue:p,mapStyle:d.mapbox_style,mapboxApiAccessToken:g.data.mapboxApiKey,width:e.width,height:e.height})})},N=(0,i.memo)(F)}}]);
//# sourceMappingURL=4f83d80f44681e8acff5.chunk.js.map