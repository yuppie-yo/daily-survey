{"version":3,"file":"edc450424737a7a5c013.chunk.js","mappings":"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","sources":["webpack://superset/./plugins/legacy-plugin-chart-map-box/src/utils/roundDecimal.js","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/utils/geo.js","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/ScatterPlotGlowOverlay.jsx","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/utils/luminanceFromRGB.js","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/MapBox.jsx","webpack://superset/./node_modules/supercluster/node_modules/kdbush/src/sort.js","webpack://superset/./node_modules/supercluster/node_modules/kdbush/src/within.js","webpack://superset/./node_modules/supercluster/node_modules/kdbush/src/index.js","webpack://superset/./node_modules/supercluster/index.js","webpack://superset/./node_modules/supercluster/node_modules/kdbush/src/range.js","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/transformProps.js"],"sourcesContent":["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nexport default function roundDecimal(number, precision) {\n  let roundedNumber;\n  let p = precision;\n  if (precision) {\n    roundedNumber = Math.round(number * (p = 10 ** p)) / p;\n  } else {\n    roundedNumber = Math.round(number);\n  }\n\n  return roundedNumber;\n}\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport roundDecimal from './roundDecimal';\n\nexport const EARTH_CIRCUMFERENCE_KM = 40075.16;\nexport const MILES_PER_KM = 1.60934;\n\nexport function kmToPixels(kilometers, latitude, zoomLevel) {\n  // Algorithm from: http://wiki.openstreetmap.org/wiki/Zoom_levels\n  const latitudeRad = latitude * (Math.PI / 180);\n  // Seems like the zoomLevel is off by one\n  const kmPerPixel =\n    (EARTH_CIRCUMFERENCE_KM * Math.cos(latitudeRad)) / 2 ** (zoomLevel + 9);\n\n  return roundDecimal(kilometers / kmPerPixel, 2);\n}\n","/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/require-default-props */\nimport PropTypes from 'prop-types';\nimport { PureComponent } from 'react';\nimport { CanvasOverlay } from 'react-map-gl';\nimport { kmToPixels, MILES_PER_KM } from './utils/geo';\nimport roundDecimal from './utils/roundDecimal';\nimport luminanceFromRGB from './utils/luminanceFromRGB';\nimport 'mapbox-gl/dist/mapbox-gl.css';\n\nconst propTypes = {\n  aggregation: PropTypes.string,\n  compositeOperation: PropTypes.string,\n  dotRadius: PropTypes.number,\n  lngLatAccessor: PropTypes.func,\n  locations: PropTypes.arrayOf(PropTypes.object).isRequired,\n  pointRadiusUnit: PropTypes.string,\n  renderWhileDragging: PropTypes.bool,\n  rgb: PropTypes.arrayOf(\n    PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  ),\n  zoom: PropTypes.number,\n};\n\nconst defaultProps = {\n  // Same as browser default.\n  compositeOperation: 'source-over',\n  dotRadius: 4,\n  lngLatAccessor: location => [location[0], location[1]],\n  renderWhileDragging: true,\n};\n\nconst computeClusterLabel = (properties, aggregation) => {\n  const count = properties.point_count;\n  if (!aggregation) {\n    return count;\n  }\n  if (aggregation === 'sum' || aggregation === 'min' || aggregation === 'max') {\n    return properties[aggregation];\n  }\n  const { sum } = properties;\n  const mean = sum / count;\n  if (aggregation === 'mean') {\n    return Math.round(100 * mean) / 100;\n  }\n  const { squaredSum } = properties;\n  const variance = squaredSum / count - (sum / count) ** 2;\n  if (aggregation === 'var') {\n    return Math.round(100 * variance) / 100;\n  }\n  if (aggregation === 'stdev') {\n    return Math.round(100 * Math.sqrt(variance)) / 100;\n  }\n\n  // fallback to point_count, this really shouldn't happen\n  return count;\n};\n\nclass ScatterPlotGlowOverlay extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.redraw = this.redraw.bind(this);\n  }\n\n  drawText(ctx, pixel, options = {}) {\n    const IS_DARK_THRESHOLD = 110;\n    const {\n      fontHeight = 0,\n      label = '',\n      radius = 0,\n      rgb = [0, 0, 0],\n      shadow = false,\n    } = options;\n    const maxWidth = radius * 1.8;\n    const luminance = luminanceFromRGB(rgb[1], rgb[2], rgb[3]);\n\n    ctx.globalCompositeOperation = 'source-over';\n    ctx.fillStyle = luminance <= IS_DARK_THRESHOLD ? 'white' : 'black';\n    ctx.font = `${fontHeight}px sans-serif`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    if (shadow) {\n      ctx.shadowBlur = 15;\n      ctx.shadowColor = luminance <= IS_DARK_THRESHOLD ? 'black' : '';\n    }\n\n    const textWidth = ctx.measureText(label).width;\n    if (textWidth > maxWidth) {\n      const scale = fontHeight / textWidth;\n      ctx.font = `${scale * maxWidth}px sans-serif`;\n    }\n\n    const { compositeOperation } = this.props;\n\n    ctx.fillText(label, pixel[0], pixel[1]);\n    ctx.globalCompositeOperation = compositeOperation;\n    ctx.shadowBlur = 0;\n    ctx.shadowColor = '';\n  }\n\n  // Modified: https://github.com/uber/react-map-gl/blob/master/overlays/scatterplot.react.js\n  redraw({ width, height, ctx, isDragging, project }) {\n    const {\n      aggregation,\n      compositeOperation,\n      dotRadius,\n      lngLatAccessor,\n      locations,\n      pointRadiusUnit,\n      renderWhileDragging,\n      rgb,\n      zoom,\n    } = this.props;\n\n    const radius = dotRadius;\n    const clusterLabelMap = [];\n\n    locations.forEach((location, i) => {\n      if (location.properties.cluster) {\n        clusterLabelMap[i] = computeClusterLabel(\n          location.properties,\n          aggregation,\n        );\n      }\n    }, this);\n\n    const maxLabel = Math.max(...clusterLabelMap.filter(v => !Number.isNaN(v)));\n\n    ctx.clearRect(0, 0, width, height);\n    ctx.globalCompositeOperation = compositeOperation;\n\n    if ((renderWhileDragging || !isDragging) && locations) {\n      locations.forEach(function _forEach(location, i) {\n        const pixel = project(lngLatAccessor(location));\n        const pixelRounded = [\n          roundDecimal(pixel[0], 1),\n          roundDecimal(pixel[1], 1),\n        ];\n\n        if (\n          pixelRounded[0] + radius >= 0 &&\n          pixelRounded[0] - radius < width &&\n          pixelRounded[1] + radius >= 0 &&\n          pixelRounded[1] - radius < height\n        ) {\n          ctx.beginPath();\n          if (location.properties.cluster) {\n            let clusterLabel = clusterLabelMap[i];\n            const scaledRadius = roundDecimal(\n              (clusterLabel / maxLabel) ** 0.5 * radius,\n              1,\n            );\n            const fontHeight = roundDecimal(scaledRadius * 0.5, 1);\n            const [x, y] = pixelRounded;\n            const gradient = ctx.createRadialGradient(\n              x,\n              y,\n              scaledRadius,\n              x,\n              y,\n              0,\n            );\n\n            gradient.addColorStop(\n              1,\n              `rgba(${rgb[1]}, ${rgb[2]}, ${rgb[3]}, 0.8)`,\n            );\n            gradient.addColorStop(\n              0,\n              `rgba(${rgb[1]}, ${rgb[2]}, ${rgb[3]}, 0)`,\n            );\n            ctx.arc(\n              pixelRounded[0],\n              pixelRounded[1],\n              scaledRadius,\n              0,\n              Math.PI * 2,\n            );\n            ctx.fillStyle = gradient;\n            ctx.fill();\n\n            if (Number.isFinite(parseFloat(clusterLabel))) {\n              if (clusterLabel >= 10000) {\n                clusterLabel = `${Math.round(clusterLabel / 1000)}k`;\n              } else if (clusterLabel >= 1000) {\n                clusterLabel = `${Math.round(clusterLabel / 100) / 10}k`;\n              }\n              this.drawText(ctx, pixelRounded, {\n                fontHeight,\n                label: clusterLabel,\n                radius: scaledRadius,\n                rgb,\n                shadow: true,\n              });\n            }\n          } else {\n            const defaultRadius = radius / 6;\n            const radiusProperty = location.properties.radius;\n            const pointMetric = location.properties.metric;\n            let pointRadius =\n              radiusProperty === null ? defaultRadius : radiusProperty;\n            let pointLabel;\n\n            if (radiusProperty !== null) {\n              const pointLatitude = lngLatAccessor(location)[1];\n              if (pointRadiusUnit === 'Kilometers') {\n                pointLabel = `${roundDecimal(pointRadius, 2)}km`;\n                pointRadius = kmToPixels(pointRadius, pointLatitude, zoom);\n              } else if (pointRadiusUnit === 'Miles') {\n                pointLabel = `${roundDecimal(pointRadius, 2)}mi`;\n                pointRadius = kmToPixels(\n                  pointRadius * MILES_PER_KM,\n                  pointLatitude,\n                  zoom,\n                );\n              }\n            }\n\n            if (pointMetric !== null) {\n              pointLabel = Number.isFinite(parseFloat(pointMetric))\n                ? roundDecimal(pointMetric, 2)\n                : pointMetric;\n            }\n\n            // Fall back to default points if pointRadius wasn't a numerical column\n            if (!pointRadius) {\n              pointRadius = defaultRadius;\n            }\n\n            ctx.arc(\n              pixelRounded[0],\n              pixelRounded[1],\n              roundDecimal(pointRadius, 1),\n              0,\n              Math.PI * 2,\n            );\n            ctx.fillStyle = `rgb(${rgb[1]}, ${rgb[2]}, ${rgb[3]})`;\n            ctx.fill();\n\n            if (pointLabel !== undefined) {\n              this.drawText(ctx, pixelRounded, {\n                fontHeight: roundDecimal(pointRadius, 1),\n                label: pointLabel,\n                radius: pointRadius,\n                rgb,\n                shadow: false,\n              });\n            }\n          }\n        }\n      }, this);\n    }\n  }\n\n  render() {\n    return <CanvasOverlay redraw={this.redraw} />;\n  }\n}\n\nScatterPlotGlowOverlay.propTypes = propTypes;\nScatterPlotGlowOverlay.defaultProps = defaultProps;\n\nexport default ScatterPlotGlowOverlay;\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nexport const LUMINANCE_RED_WEIGHT = 0.2126;\nexport const LUMINANCE_GREEN_WEIGHT = 0.7152;\nexport const LUMINANCE_BLUE_WEIGHT = 0.0722;\n\nexport default function luminanceFromRGB(r, g, b) {\n  // Formula: https://en.wikipedia.org/wiki/Relative_luminance\n  return (\n    LUMINANCE_RED_WEIGHT * r +\n    LUMINANCE_GREEN_WEIGHT * g +\n    LUMINANCE_BLUE_WEIGHT * b\n  );\n}\n","/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/jsx-sort-default-props, react/sort-prop-types */\n/* eslint-disable react/forbid-prop-types, react/require-default-props */\nimport { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport MapGL from 'react-map-gl';\nimport ViewportMercator from 'viewport-mercator-project';\nimport ScatterPlotGlowOverlay from './ScatterPlotGlowOverlay';\nimport './MapBox.css';\n\nconst NOOP = () => {};\nexport const DEFAULT_MAX_ZOOM = 16;\nexport const DEFAULT_POINT_RADIUS = 60;\n\nconst propTypes = {\n  width: PropTypes.number,\n  height: PropTypes.number,\n  aggregatorName: PropTypes.string,\n  clusterer: PropTypes.object,\n  globalOpacity: PropTypes.number,\n  hasCustomMetric: PropTypes.bool,\n  mapStyle: PropTypes.string,\n  mapboxApiKey: PropTypes.string.isRequired,\n  onViewportChange: PropTypes.func,\n  pointRadius: PropTypes.number,\n  pointRadiusUnit: PropTypes.string,\n  renderWhileDragging: PropTypes.bool,\n  rgb: PropTypes.array,\n  bounds: PropTypes.array,\n};\n\nconst defaultProps = {\n  width: 400,\n  height: 400,\n  globalOpacity: 1,\n  onViewportChange: NOOP,\n  pointRadius: DEFAULT_POINT_RADIUS,\n  pointRadiusUnit: 'Pixels',\n};\n\nclass MapBox extends Component {\n  constructor(props) {\n    super(props);\n\n    const { width, height, bounds } = this.props;\n    // Get a viewport that fits the given bounds, which all marks to be clustered.\n    // Derive lat, lon and zoom from this viewport. This is only done on initial\n    // render as the bounds don't update as we pan/zoom in the current design.\n    const mercator = new ViewportMercator({\n      width,\n      height,\n    }).fitBounds(bounds);\n    const { latitude, longitude, zoom } = mercator;\n\n    this.state = {\n      viewport: {\n        longitude,\n        latitude,\n        zoom,\n      },\n    };\n    this.handleViewportChange = this.handleViewportChange.bind(this);\n  }\n\n  handleViewportChange(viewport) {\n    this.setState({ viewport });\n    const { onViewportChange } = this.props;\n    onViewportChange(viewport);\n  }\n\n  render() {\n    const {\n      width,\n      height,\n      aggregatorName,\n      clusterer,\n      globalOpacity,\n      mapStyle,\n      mapboxApiKey,\n      pointRadius,\n      pointRadiusUnit,\n      renderWhileDragging,\n      rgb,\n      hasCustomMetric,\n      bounds,\n    } = this.props;\n    const { viewport } = this.state;\n    const isDragging =\n      viewport.isDragging === undefined ? false : viewport.isDragging;\n\n    // Compute the clusters based on the original bounds and current zoom level. Note when zoom/pan\n    // to an area outside of the original bounds, no additional queries are made to the backend to\n    // retrieve additional data.\n    // add this variable to widen the visible area\n    const offsetHorizontal = (width * 0.5) / 100;\n    const offsetVertical = (height * 0.5) / 100;\n    const bbox = [\n      bounds[0][0] - offsetHorizontal,\n      bounds[0][1] - offsetVertical,\n      bounds[1][0] + offsetHorizontal,\n      bounds[1][1] + offsetVertical,\n    ];\n    const clusters = clusterer.getClusters(bbox, Math.round(viewport.zoom));\n\n    return (\n      <MapGL\n        {...viewport}\n        mapStyle={mapStyle}\n        width={width}\n        height={height}\n        mapboxApiAccessToken={mapboxApiKey}\n        onViewportChange={this.handleViewportChange}\n        preserveDrawingBuffer\n      >\n        <ScatterPlotGlowOverlay\n          {...viewport}\n          isDragging={isDragging}\n          locations={clusters}\n          dotRadius={pointRadius}\n          pointRadiusUnit={pointRadiusUnit}\n          rgb={rgb}\n          globalOpacity={globalOpacity}\n          compositeOperation=\"screen\"\n          renderWhileDragging={renderWhileDragging}\n          aggregation={hasCustomMetric ? aggregatorName : null}\n          lngLatAccessor={location => {\n            const { coordinates } = location.geometry;\n\n            return [coordinates[0], coordinates[1]];\n          }}\n        />\n      </MapGL>\n    );\n  }\n}\n\nMapBox.propTypes = propTypes;\nMapBox.defaultProps = defaultProps;\n\nexport default MapBox;\n","\nexport default function sortKD(ids, coords, nodeSize, left, right, depth) {\n    if (right - left <= nodeSize) return;\n\n    var m = Math.floor((left + right) / 2);\n\n    select(ids, coords, m, left, right, depth % 2);\n\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\n}\n\nfunction select(ids, coords, k, left, right, inc) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, inc);\n        }\n\n        var t = coords[2 * k + inc];\n        var i = left;\n        var j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + inc] < t) i++;\n            while (coords[2 * j + inc] > t) j--;\n        }\n\n        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n","\nexport default function within(ids, coords, qx, qy, r, nodeSize) {\n    var stack = [0, ids.length - 1, 0];\n    var result = [];\n    var r2 = r * r;\n\n    while (stack.length) {\n        var axis = stack.pop();\n        var right = stack.pop();\n        var left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (var i = left; i <= right; i++) {\n                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        var m = Math.floor((left + right) / 2);\n\n        var x = coords[2 * m];\n        var y = coords[2 * m + 1];\n\n        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n        var nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? qx - r <= x : qy - r <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? qx + r >= x : qy + r >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\nfunction sqDist(ax, ay, bx, by) {\n    var dx = ax - bx;\n    var dy = ay - by;\n    return dx * dx + dy * dy;\n}\n","\nimport sort from './sort';\nimport range from './range';\nimport within from './within';\n\nexport default function kdbush(points, getX, getY, nodeSize, ArrayType) {\n    return new KDBush(points, getX, getY, nodeSize, ArrayType);\n}\n\nfunction KDBush(points, getX, getY, nodeSize, ArrayType) {\n    getX = getX || defaultGetX;\n    getY = getY || defaultGetY;\n    ArrayType = ArrayType || Array;\n\n    this.nodeSize = nodeSize || 64;\n    this.points = points;\n\n    this.ids = new ArrayType(points.length);\n    this.coords = new ArrayType(points.length * 2);\n\n    for (var i = 0; i < points.length; i++) {\n        this.ids[i] = i;\n        this.coords[2 * i] = getX(points[i]);\n        this.coords[2 * i + 1] = getY(points[i]);\n    }\n\n    sort(this.ids, this.coords, this.nodeSize, 0, this.ids.length - 1, 0);\n}\n\nKDBush.prototype = {\n    range: function (minX, minY, maxX, maxY) {\n        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\n    },\n\n    within: function (x, y, r) {\n        return within(this.ids, this.coords, x, y, r, this.nodeSize);\n    }\n};\n\nfunction defaultGetX(p) { return p[0]; }\nfunction defaultGetY(p) { return p[1]; }\n","\nimport kdbush from 'kdbush';\n\nexport default function supercluster(options) {\n    return new SuperCluster(options);\n}\n\nfunction SuperCluster(options) {\n    this.options = extend(Object.create(this.options), options);\n    this.trees = new Array(this.options.maxZoom + 1);\n}\n\nSuperCluster.prototype = {\n    options: {\n        minZoom: 0,   // min zoom to generate clusters on\n        maxZoom: 16,  // max zoom level to cluster the points on\n        radius: 40,   // cluster radius in pixels\n        extent: 512,  // tile extent (radius is calculated relative to it)\n        nodeSize: 64, // size of the KD-tree leaf node, affects performance\n        log: false,   // whether to log timing info\n\n        // a reduce function for calculating custom cluster properties\n        reduce: null, // function (accumulated, props) { accumulated.sum += props.sum; }\n\n        // initial properties of a cluster (before running the reducer)\n        initial: function () { return {}; }, // function () { return {sum: 0}; },\n\n        // properties to use for individual points when running the reducer\n        map: function (props) { return props; } // function (props) { return {sum: props.my_value}; },\n    },\n\n    load: function (points) {\n        var log = this.options.log;\n\n        if (log) console.time('total time');\n\n        var timerId = 'prepare ' + points.length + ' points';\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        var clusters = [];\n        for (var i = 0; i < points.length; i++) {\n            if (!points[i].geometry) {\n                continue;\n            }\n            clusters.push(createPointCluster(points[i], i));\n        }\n        this.trees[this.options.maxZoom + 1] = kdbush(clusters, getX, getY, this.options.nodeSize, Float32Array);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (var z = this.options.maxZoom; z >= this.options.minZoom; z--) {\n            var now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            clusters = this._cluster(clusters, z);\n            this.trees[z] = kdbush(clusters, getX, getY, this.options.nodeSize, Float32Array);\n\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    },\n\n    getClusters: function (bbox, zoom) {\n        var minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        var minLat = Math.max(-90, Math.min(90, bbox[1]));\n        var maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        var maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            var easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            var westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        var tree = this.trees[this._limitZoom(zoom)];\n        var ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        var clusters = [];\n        for (var i = 0; i < ids.length; i++) {\n            var c = tree.points[ids[i]];\n            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n        return clusters;\n    },\n\n    getChildren: function (clusterId) {\n        var originId = clusterId >> 5;\n        var originZoom = clusterId % 32;\n        var errorMsg = 'No cluster with the specified id.';\n\n        var index = this.trees[originZoom];\n        if (!index) throw new Error(errorMsg);\n\n        var origin = index.points[originId];\n        if (!origin) throw new Error(errorMsg);\n\n        var r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        var ids = index.within(origin.x, origin.y, r);\n        var children = [];\n        for (var i = 0; i < ids.length; i++) {\n            var c = index.points[ids[i]];\n            if (c.parentId === clusterId) {\n                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    },\n\n    getLeaves: function (clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        var leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    },\n\n    getTile: function (z, x, y) {\n        var tree = this.trees[this._limitZoom(z)];\n        var z2 = Math.pow(2, z);\n        var extent = this.options.extent;\n        var r = this.options.radius;\n        var p = r / extent;\n        var top = (y - p) / z2;\n        var bottom = (y + 1 + p) / z2;\n\n        var tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.points, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.points, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.points, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    },\n\n    getClusterExpansionZoom: function (clusterId) {\n        var clusterZoom = (clusterId % 32) - 1;\n        while (clusterZoom < this.options.maxZoom) {\n            var children = this.getChildren(clusterId);\n            clusterZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return clusterZoom;\n    },\n\n    _appendLeaves: function (result, clusterId, limit, offset, skipped) {\n        var children = this.getChildren(clusterId);\n\n        for (var i = 0; i < children.length; i++) {\n            var props = children[i].properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(children[i]);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    },\n\n    _addTileFeatures: function (ids, points, x, y, z2, tile) {\n        for (var i = 0; i < ids.length; i++) {\n            var c = points[ids[i]];\n            var f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (c.x * z2 - x)),\n                    Math.round(this.options.extent * (c.y * z2 - y))\n                ]],\n                tags: c.numPoints ? getClusterProperties(c) : this.points[c.index].properties\n            };\n            var id = c.numPoints ? c.id : this.points[c.index].id;\n            if (id !== undefined) {\n                f.id = id;\n            }\n            tile.features.push(f);\n        }\n    },\n\n    _limitZoom: function (z) {\n        return Math.max(this.options.minZoom, Math.min(z, this.options.maxZoom + 1));\n    },\n\n    _cluster: function (points, zoom) {\n        var clusters = [];\n        var r = this.options.radius / (this.options.extent * Math.pow(2, zoom));\n\n        // loop through each point\n        for (var i = 0; i < points.length; i++) {\n            var p = points[i];\n            // if we've already visited the point at this zoom level, skip it\n            if (p.zoom <= zoom) continue;\n            p.zoom = zoom;\n\n            // find all nearby points\n            var tree = this.trees[zoom + 1];\n            var neighborIds = tree.within(p.x, p.y, r);\n\n            var numPoints = p.numPoints || 1;\n            var wx = p.x * numPoints;\n            var wy = p.y * numPoints;\n\n            var clusterProperties = null;\n\n            if (this.options.reduce) {\n                clusterProperties = this.options.initial();\n                this._accumulate(clusterProperties, p);\n            }\n\n            // encode both zoom and point index on which the cluster originated\n            var id = (i << 5) + (zoom + 1);\n\n            for (var j = 0; j < neighborIds.length; j++) {\n                var b = tree.points[neighborIds[j]];\n                // filter out neighbors that are already processed\n                if (b.zoom <= zoom) continue;\n                b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n                var numPoints2 = b.numPoints || 1;\n                wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n                wy += b.y * numPoints2;\n\n                numPoints += numPoints2;\n                b.parentId = id;\n\n                if (this.options.reduce) {\n                    this._accumulate(clusterProperties, b);\n                }\n            }\n\n            if (numPoints === 1) {\n                clusters.push(p);\n            } else {\n                p.parentId = id;\n                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n            }\n        }\n\n        return clusters;\n    },\n\n    _accumulate: function (clusterProperties, point) {\n        var properties = point.numPoints ?\n            point.properties :\n            this.options.map(this.points[point.index].properties);\n\n        this.options.reduce(clusterProperties, properties);\n    }\n};\n\nfunction createCluster(x, y, id, numPoints, properties) {\n    return {\n        x: x, // weighted cluster center\n        y: y,\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id: id, // encodes index of the first child of the cluster and its zoom level\n        parentId: -1, // parent cluster id\n        numPoints: numPoints,\n        properties: properties\n    };\n}\n\nfunction createPointCluster(p, id) {\n    var coords = p.geometry.coordinates;\n    return {\n        x: lngX(coords[0]), // projected point coordinates\n        y: latY(coords[1]),\n        zoom: Infinity, // the last zoom the point was processed at\n        index: id, // index of the source feature in the original input array,\n        parentId: -1 // parent cluster id\n    };\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        id: cluster.id,\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    var count = cluster.numPoints;\n    var abbrev =\n        count >= 10000 ? Math.round(count / 1000) + 'k' :\n        count >= 1000 ? (Math.round(count / 100) / 10) + 'k' : count;\n    return extend(extend({}, cluster.properties), {\n        cluster: true,\n        cluster_id: cluster.id,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    var sin = Math.sin(lat * Math.PI / 180),\n        y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    var y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (var id in src) dest[id] = src[id];\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n","\nexport default function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\n    var stack = [0, ids.length - 1, 0];\n    var result = [];\n    var x, y;\n\n    while (stack.length) {\n        var axis = stack.pop();\n        var right = stack.pop();\n        var left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (var i = left; i <= right; i++) {\n                x = coords[2 * i];\n                y = coords[2 * i + 1];\n                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        var m = Math.floor((left + right) / 2);\n\n        x = coords[2 * m];\n        y = coords[2 * m + 1];\n\n        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n        var nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? minX <= x : minY <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? maxX >= x : maxY >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n","/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport supercluster from 'supercluster';\nimport { DEFAULT_POINT_RADIUS, DEFAULT_MAX_ZOOM } from './MapBox';\n\nconst NOOP = () => {};\n\nexport default function transformProps(chartProps) {\n  const { width, height, formData, hooks, queriesData } = chartProps;\n  const { onError = NOOP, setControlValue = NOOP } = hooks;\n  const { bounds, geoJSON, hasCustomMetric, mapboxApiKey } =\n    queriesData[0].data;\n  const {\n    clusteringRadius,\n    globalOpacity,\n    mapboxColor,\n    mapboxStyle,\n    pandasAggfunc,\n    pointRadius,\n    pointRadiusUnit,\n    renderWhileDragging,\n  } = formData;\n\n  // Validate mapbox color\n  const rgb = /^rgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)$/.exec(mapboxColor);\n  if (rgb === null) {\n    onError(\"Color field must be of form 'rgb(%d, %d, %d)'\");\n\n    return {};\n  }\n\n  const opts = {\n    maxZoom: DEFAULT_MAX_ZOOM,\n    radius: clusteringRadius,\n  };\n  if (hasCustomMetric) {\n    opts.initial = () => ({\n      sum: 0,\n      squaredSum: 0,\n      min: Infinity,\n      max: -Infinity,\n    });\n    opts.map = prop => ({\n      sum: prop.metric,\n      squaredSum: prop.metric ** 2,\n      min: prop.metric,\n      max: prop.metric,\n    });\n    opts.reduce = (accu, prop) => {\n      // Temporarily disable param-reassignment linting to work with supercluster's api\n      /* eslint-disable no-param-reassign */\n      accu.sum += prop.sum;\n      accu.squaredSum += prop.squaredSum;\n      accu.min = Math.min(accu.min, prop.min);\n      accu.max = Math.max(accu.max, prop.max);\n      /* eslint-enable no-param-reassign */\n    };\n  }\n  const clusterer = supercluster(opts);\n  clusterer.load(geoJSON.features);\n\n  return {\n    width,\n    height,\n    aggregatorName: pandasAggfunc,\n    bounds,\n    clusterer,\n    globalOpacity,\n    hasCustomMetric,\n    mapboxApiKey,\n    mapStyle: mapboxStyle,\n    onViewportChange({ latitude, longitude, zoom }) {\n      setControlValue('viewport_longitude', longitude);\n      setControlValue('viewport_latitude', latitude);\n      setControlValue('viewport_zoom', zoom);\n    },\n    pointRadius: pointRadius === 'Auto' ? DEFAULT_POINT_RADIUS : pointRadius,\n    pointRadiusUnit,\n    renderWhileDragging,\n    rgb,\n  };\n}\n"],"names":["roundDecimal","number","precision","roundedNumber","p","Math","round","kmToPixels","kilometers","latitude","zoomLevel","latitudeRad","PI","cos","propTypes","aggregation","PropTypes","compositeOperation","dotRadius","lngLatAccessor","locations","isRequired","pointRadiusUnit","renderWhileDragging","rgb","zoom","ScatterPlotGlowOverlay","PureComponent","constructor","props","super","this","redraw","bind","drawText","ctx","pixel","options","fontHeight","label","radius","shadow","maxWidth","luminance","globalCompositeOperation","fillStyle","font","textAlign","textBaseline","shadowBlur","shadowColor","textWidth","measureText","width","scale","fillText","height","isDragging","project","clusterLabelMap","forEach","location","i","properties","cluster","computeClusterLabel","count","point_count","sum","mean","squaredSum","variance","sqrt","maxLabel","max","filter","v","Number","isNaN","clearRect","pixelRounded","beginPath","clusterLabel","scaledRadius","x","y","gradient","createRadialGradient","addColorStop","arc","fill","isFinite","parseFloat","defaultRadius","radiusProperty","pointMetric","metric","pointLabel","pointRadius","pointLatitude","undefined","render","_jsx","CanvasOverlay","defaultProps","DEFAULT_MAX_ZOOM","DEFAULT_POINT_RADIUS","aggregatorName","clusterer","globalOpacity","hasCustomMetric","mapStyle","mapboxApiKey","onViewportChange","bounds","NOOP","MapBox","Component","mercator","ViewportMercator","fitBounds","longitude","state","viewport","handleViewportChange","setState","offsetHorizontal","offsetVertical","bbox","clusters","getClusters","MapGL","mapboxApiAccessToken","preserveDrawingBuffer","children","coordinates","geometry","sortKD","ids","coords","nodeSize","left","right","depth","m","floor","k","inc","n","z","log","s","exp","sd","min","t","j","swapItem","swap","arr","tmp","sqDist","ax","ay","bx","by","dx","dy","kdbush","points","getX","getY","ArrayType","KDBush","defaultGetX","defaultGetY","Array","length","SuperCluster","extend","Object","create","trees","maxZoom","createCluster","id","numPoints","Infinity","parentId","getClusterJSON","type","getClusterProperties","y2","atan","abbrev","cluster_id","point_count_abbreviated","lngX","lng","latY","lat","sin","dest","src","prototype","range","minX","minY","maxX","maxY","stack","result","axis","pop","push","nextAxis","within","r","qx","qy","r2","minZoom","extent","reduce","initial","map","load","console","time","timerId","index","Float32Array","timeEnd","now","Date","_cluster","minLng","minLat","maxLng","maxLat","easternHem","westernHem","concat","tree","_limitZoom","c","getChildren","clusterId","originId","originZoom","errorMsg","Error","origin","pow","getLeaves","limit","offset","leaves","_appendLeaves","getTile","z2","top","bottom","tile","features","_addTileFeatures","getClusterExpansionZoom","clusterZoom","skipped","f","tags","neighborIds","wx","wy","clusterProperties","_accumulate","b","numPoints2","point","transformProps","chartProps","formData","hooks","queriesData","onError","setControlValue","geoJSON","data","clusteringRadius","mapboxColor","mapboxStyle","pandasAggfunc","exec","opts","prop","accu"],"sourceRoot":""}