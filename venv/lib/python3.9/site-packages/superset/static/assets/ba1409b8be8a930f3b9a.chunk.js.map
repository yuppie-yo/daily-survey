{"version":3,"file":"ba1409b8be8a930f3b9a.chunk.js","mappings":"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","sources":["webpack://superset/./node_modules/@luma.gl/engine/dist/esm/geometries/cube-geometry.js","webpack://superset/../../../src/gpu-grid-layer/gpu-grid-cell-layer-vertex.glsl.ts","webpack://superset/../../../src/gpu-grid-layer/gpu-grid-cell-layer.ts","webpack://superset/../../../src/gpu-grid-layer/gpu-grid-cell-layer-fragment.glsl.ts","webpack://superset/../../../src/gpu-grid-layer/gpu-grid-layer.ts","webpack://superset/../../../src/column-layer/grid-cell-layer.ts","webpack://superset/../../../src/cpu-grid-layer/cpu-grid-layer.ts","webpack://superset/../../../src/grid-layer/grid-layer.ts"],"sourcesContent":["import Geometry from '../geometry/geometry';\nimport { uid } from '@luma.gl/webgl';\nconst CUBE_INDICES = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]);\nconst CUBE_POSITIONS = new Float32Array([-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1]);\nconst CUBE_NORMALS = new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0]);\nconst CUBE_TEX_COORDS = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1]);\nconst ATTRIBUTES = {\n  POSITION: {\n    size: 3,\n    value: new Float32Array(CUBE_POSITIONS)\n  },\n  NORMAL: {\n    size: 3,\n    value: new Float32Array(CUBE_NORMALS)\n  },\n  TEXCOORD_0: {\n    size: 2,\n    value: new Float32Array(CUBE_TEX_COORDS)\n  }\n};\nexport default class CubeGeometry extends Geometry {\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      id = uid('cube-geometry')\n    } = props;\n    super({ ...props,\n      id,\n      indices: {\n        size: 1,\n        value: new Uint16Array(CUBE_INDICES)\n      },\n      attributes: { ...ATTRIBUTES,\n        ...props.attributes\n      }\n    });\n  }\n\n}\n//# sourceMappingURL=cube-geometry.js.map","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Inspired by screen-grid-layer vertex shader in deck.gl\n\nexport default `\\\n#version 300 es\n#define SHADER_NAME gpu-grid-cell-layer-vertex-shader\n#define RANGE_COUNT 6\n\nin vec3 positions;\nin vec3 normals;\n\nin vec4 colors;\nin vec4 elevations;\nin vec3 instancePickingColors;\n\n// Custom uniforms\nuniform vec2 offset;\nuniform bool extruded;\nuniform float cellSize;\nuniform float coverage;\nuniform float opacity;\nuniform float elevationScale;\n\nuniform ivec2 gridSize;\nuniform vec2 gridOrigin;\nuniform vec2 gridOriginLow;\nuniform vec2 gridOffset;\nuniform vec2 gridOffsetLow;\nuniform vec4 colorRange[RANGE_COUNT];\nuniform vec2 elevationRange;\n\n// Domain uniforms\nuniform vec2 colorDomain;\nuniform bool colorDomainValid;\nuniform vec2 elevationDomain;\nuniform bool elevationDomainValid;\n\nlayout(std140) uniform;\nuniform ColorData\n{\n  vec4 maxMinCount;\n} colorData;\nuniform ElevationData\n{\n  vec4 maxMinCount;\n} elevationData;\n\n#define EPSILON 0.00001\n\n// Result\nout vec4 vColor;\n\nvec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {\n  vec4 outColor = vec4(0., 0., 0., 0.);\n  if (value >= (domain.x - EPSILON) && value <= (domain.y + EPSILON)) {\n    float domainRange = domain.y - domain.x;\n    if (domainRange <= 0.) {\n      outColor = colorRange[0];\n    } else {\n      float rangeCount = float(RANGE_COUNT);\n      float rangeStep = domainRange / rangeCount;\n      float idx = floor((value - domain.x) / rangeStep);\n      idx = clamp(idx, 0., rangeCount - 1.);\n      int intIdx = int(idx);\n      outColor = colorRange[intIdx];\n    }\n  }\n  return outColor;\n}\n\nfloat linearScale(vec2 domain, vec2 range, float value) {\n  if (value >= (domain.x - EPSILON) && value <= (domain.y + EPSILON)) {\n    return ((value - domain.x) / (domain.y - domain.x)) * (range.y - range.x) + range.x;\n  }\n  return -1.;\n}\n\nvoid main(void) {\n  vec2 clrDomain = colorDomainValid ? colorDomain : vec2(colorData.maxMinCount.a, colorData.maxMinCount.r);\n  vec4 color = quantizeScale(clrDomain, colorRange, colors.r);\n\n  float elevation = 0.0;\n\n  if (extruded) {\n    vec2 elvDomain = elevationDomainValid ? elevationDomain : vec2(elevationData.maxMinCount.a, elevationData.maxMinCount.r);\n    elevation = linearScale(elvDomain, elevationRange, elevations.r);\n    elevation = elevation  * (positions.z + 1.0) / 2.0 * elevationScale;\n  }\n\n  // if aggregated color or elevation is 0 do not render\n  float shouldRender = float(color.r > 0.0 && elevations.r >= 0.0);\n  float dotRadius = cellSize / 2. * coverage * shouldRender;\n\n  int yIndex = (gl_InstanceID / gridSize[0]);\n  int xIndex = gl_InstanceID - (yIndex * gridSize[0]);\n\n  vec2 instancePositionXFP64 = mul_fp64(vec2(gridOffset[0], gridOffsetLow[0]), vec2(float(xIndex), 0.));\n  instancePositionXFP64 = sum_fp64(instancePositionXFP64, vec2(gridOrigin[0], gridOriginLow[0]));\n  vec2 instancePositionYFP64 = mul_fp64(vec2(gridOffset[1], gridOffsetLow[1]), vec2(float(yIndex), 0.));\n  instancePositionYFP64 = sum_fp64(instancePositionYFP64, vec2(gridOrigin[1], gridOriginLow[1]));\n\n  vec3 centroidPosition = vec3(instancePositionXFP64[0], instancePositionYFP64[0], elevation);\n  vec3 centroidPosition64Low = vec3(instancePositionXFP64[1], instancePositionYFP64[1], 0.0);\n  geometry.worldPosition = centroidPosition;\n  vec3 pos = vec3(project_size(positions.xy + offset) * dotRadius, 0.);\n\n  // Set color to be rendered to picking fbo (also used to check for selection highlight).\n  picking_setPickingColor(instancePickingColors);\n\n  gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);\n\n  // Light calculations\n  // Worldspace is the linear space after Mercator projection\n\n  vec3 normals_commonspace = project_normal(normals);\n\n   if (extruded) {\n    vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, normals_commonspace);\n    vColor = vec4(lightColor, color.a * opacity) / 255.;\n  } else {\n    vColor = vec4(color.rgb, color.a * opacity) / 255.;\n  }\n}\n`;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Layer,\n  fp64LowPart,\n  project32,\n  gouraudLighting,\n  picking,\n  LayerContext,\n  LayerProps,\n  DefaultProps\n} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, CubeGeometry, Buffer} from '@luma.gl/core';\nimport {fp64arithmetic} from '@luma.gl/shadertools';\nimport {defaultColorRange, colorRangeToFlatArray} from '../utils/color-utils';\nimport type {_GPUGridLayerProps} from './gpu-grid-layer';\nimport vs from './gpu-grid-cell-layer-vertex.glsl';\nimport fs from './gpu-grid-cell-layer-fragment.glsl';\n\nconst COLOR_DATA_UBO_INDEX = 0;\nconst ELEVATION_DATA_UBO_INDEX = 1;\n\nconst defaultProps: DefaultProps<_GPUGridCellLayerProps & LayerProps> = {\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  elevationScale: {type: 'number', min: 0, value: 1},\n\n  // grid\n  gridSize: {type: 'array', value: [1, 1]},\n  gridOrigin: {type: 'array', value: [0, 0]},\n  gridOffset: {type: 'array', value: [0, 0]},\n\n  cellSize: {type: 'number', min: 0, max: 1000, value: 1000},\n  offset: {type: 'array', value: [1, 1]},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  extruded: true,\n\n  material: true // Use lighting module defaults\n};\n\ntype _GPUGridCellLayerProps = _GPUGridLayerProps<any> & {\n  offset: number[];\n  gridSize: number[];\n  gridOrigin: number[];\n  gridOffset: number[];\n  colorMaxMinBuffer: Buffer;\n  elevationMaxMinBuffer: Buffer;\n};\n\nexport default class GPUGridCellLayer extends Layer<_GPUGridCellLayerProps> {\n  static layerName = 'GPUGridCellLayer';\n  static defaultProps = defaultProps;\n\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, gouraudLighting, picking, fp64arithmetic]\n    });\n  }\n\n  initializeState({gl}: LayerContext) {\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.addInstanced({\n      colors: {\n        size: 4,\n        noAlloc: true\n      },\n      elevations: {\n        size: 4,\n        noAlloc: true\n      }\n    });\n    const model = this._getModel(gl);\n    this._setupUniformBuffer(model);\n    this.setState({model});\n  }\n\n  _getModel(gl: WebGLRenderingContext): Model {\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new CubeGeometry(),\n      isInstanced: true\n    });\n  }\n\n  draw({uniforms}) {\n    const {\n      cellSize,\n      offset,\n      extruded,\n      elevationScale,\n      coverage,\n      gridSize,\n      gridOrigin,\n      gridOffset,\n      elevationRange,\n      colorMaxMinBuffer,\n      elevationMaxMinBuffer\n    } = this.props;\n\n    const gridOriginLow = [fp64LowPart(gridOrigin[0]), fp64LowPart(gridOrigin[1])];\n    const gridOffsetLow = [fp64LowPart(gridOffset[0]), fp64LowPart(gridOffset[1])];\n    const domainUniforms = this.getDomainUniforms();\n    const colorRange = colorRangeToFlatArray(this.props.colorRange);\n    this.bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);\n    this.state.model\n      .setUniforms(uniforms)\n      .setUniforms(domainUniforms)\n      .setUniforms({\n        cellSize,\n        offset,\n        extruded,\n        elevationScale,\n        coverage,\n        gridSize,\n        gridOrigin,\n        gridOriginLow,\n        gridOffset,\n        gridOffsetLow,\n        colorRange,\n        elevationRange\n      })\n      .draw();\n    this.unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);\n  }\n\n  bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {\n    colorMaxMinBuffer.bind({target: GL.UNIFORM_BUFFER, index: COLOR_DATA_UBO_INDEX});\n    elevationMaxMinBuffer.bind({target: GL.UNIFORM_BUFFER, index: ELEVATION_DATA_UBO_INDEX});\n  }\n\n  unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {\n    colorMaxMinBuffer.unbind({target: GL.UNIFORM_BUFFER, index: COLOR_DATA_UBO_INDEX});\n    elevationMaxMinBuffer.unbind({target: GL.UNIFORM_BUFFER, index: ELEVATION_DATA_UBO_INDEX});\n  }\n\n  getDomainUniforms() {\n    const {colorDomain, elevationDomain} = this.props;\n    const domainUniforms: Record<string, any> = {};\n    if (colorDomain !== null) {\n      domainUniforms.colorDomainValid = true;\n      domainUniforms.colorDomain = colorDomain;\n    } else {\n      domainUniforms.colorDomainValid = false;\n    }\n    if (elevationDomain !== null) {\n      domainUniforms.elevationDomainValid = true;\n      domainUniforms.elevationDomain = elevationDomain;\n    } else {\n      domainUniforms.elevationDomainValid = false;\n    }\n    return domainUniforms;\n  }\n\n  private _setupUniformBuffer(model: Model): void {\n    const gl = this.context.gl as WebGL2RenderingContext;\n    const programHandle = model.program.handle;\n\n    const colorIndex = gl.getUniformBlockIndex(programHandle, 'ColorData');\n    const elevationIndex = gl.getUniformBlockIndex(programHandle, 'ElevationData');\n    gl.uniformBlockBinding(programHandle, colorIndex, COLOR_DATA_UBO_INDEX);\n    gl.uniformBlockBinding(programHandle, elevationIndex, ELEVATION_DATA_UBO_INDEX);\n  }\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#version 300 es\n#define SHADER_NAME gpu-grid-cell-layer-fragment-shader\n\nprecision highp float;\n\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  fragColor = vColor;\n  fragColor = picking_filterColor(fragColor);\n}\n`;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Buffer} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport {\n  Accessor,\n  AccessorFunction,\n  Color,\n  Material,\n  GetPickingInfoParams,\n  LayerContext,\n  log,\n  PickingInfo,\n  Position,\n  DefaultProps\n} from '@deck.gl/core';\n\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {AGGREGATION_OPERATION} from '../utils/aggregation-operation-utils';\nimport {defaultColorRange, colorRangeToFlatArray} from '../utils/color-utils';\nimport GPUGridCellLayer from './gpu-grid-cell-layer';\nimport {pointToDensityGridDataCPU} from './../cpu-grid-layer/grid-aggregator';\nimport GridAggregationLayer, {GridAggregationLayerProps} from '../grid-aggregation-layer';\nimport {getBoundingBox, getGridParams} from '../utils/grid-aggregation-utils';\n\nconst defaultProps: DefaultProps<GPUGridLayerProps> = {\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorWeight: {type: 'accessor', value: 1},\n  colorAggregation: 'SUM',\n\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationWeight: {type: 'accessor', value: 1},\n  elevationAggregation: 'SUM',\n  elevationScale: {type: 'number', min: 0, value: 1},\n\n  // grid\n  cellSize: {type: 'number', min: 1, max: 1000, value: 1000},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  getPosition: {type: 'accessor', value: x => x.position},\n  extruded: false,\n\n  // Optional material for 'lighting' shader module\n  material: true\n};\n\n// This layer only perform GPU aggregation, no need to seperate data and weight props\n// aggregation will be dirty when any of the props are changed.\n\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSize', 'colorAggregation', 'elevationAggregation']\n  }\n  // rest of the changes are detected by `state.attributesChanged`\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\n\n/** All properties supported by GPUGridLayer. */\nexport type GPUGridLayerProps<DataT = any> = _GPUGridLayerProps<DataT> &\n  GridAggregationLayerProps<DataT>;\n\n/** Properties added by GPUGridLayer. */\nexport type _GPUGridLayerProps<DataT> = {\n  /**\n   * Size of each cell in meters.\n   * @default 1000\n   */\n  cellSize?: number;\n\n  /**\n   * Color scale domain, default is set to the extent of aggregated weights in each cell.\n   * @default [min(colorWeight), max(colorWeight)]\n   */\n  colorDomain?: [number, number] | null;\n\n  /**\n   * Default: [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6) `6-class YlOrRd`\n   */\n  colorRange?: Color[];\n\n  /**\n   * Cell size multiplier, clamped between 0 - 1.\n   * @default 1\n   */\n  coverage?: number;\n\n  /**\n   * Elevation scale input domain, default is set to between 0 and the max of aggregated weights in each cell.\n   * @default [0, max(elevationWeight)]\n   */\n  elevationDomain?: [number, number] | null;\n\n  /**\n   * Elevation scale output range.\n   * @default [0, 1000]\n   */\n  elevationRange?: [number, number];\n\n  /**\n   * Cell elevation multiplier.\n   * @default 1\n   */\n  elevationScale?: number;\n\n  /**\n   * Whether to enable cell elevation. If set to false, all cell will be flat.\n   * @default true\n   */\n  extruded?: boolean;\n\n  /**\n   * Material settings for lighting effect. Applies if `extruded: true`.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's color value.\n   * @default 'SUM'\n   */\n  colorAggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's elevation value.\n   * @default 'SUM'\n   */\n  elevationAggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n\n  /**\n   * Method called to retrieve the position of each object.\n   * @default object => object.position\n   */\n  getPosition?: AccessorFunction<DataT, Position>;\n\n  /**\n   * The weight of a data object used to calculate the color value for a cell.\n   * @default 1\n   */\n  getColorWeight?: Accessor<DataT, number>;\n\n  /**\n   * The weight of a data object used to calculate the elevation value for a cell.\n   * @default 1\n   */\n  getElevationWeight?: Accessor<DataT, number>;\n};\n\n/** Aggregate data into a grid-based heatmap. Aggregation is performed on GPU (WebGL2 only). */\nexport default class GPUGridLayer<\n  DataT = any,\n  ExtraPropsT extends {} = {}\n> extends GridAggregationLayer<DataT, ExtraPropsT & Required<_GPUGridLayerProps<DataT>>> {\n  static layerName = 'GPUGridLayer';\n  static defaultProps = defaultProps;\n\n  initializeState({gl}: LayerContext): void {\n    const isSupported = GPUGridAggregator.isSupported(gl);\n    if (!isSupported) {\n      log.error('GPUGridLayer is not supported on this browser, use GridLayer instead')();\n    }\n    super.initializeAggregationLayer({\n      dimensions: DIMENSIONS\n    });\n    this.setState({\n      gpuAggregation: true,\n      projectPoints: false, // aggregation in world space\n      isSupported,\n      weights: {\n        color: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {size: 4, type: GL.FLOAT, divisor: 1}\n          })\n        },\n        elevation: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {size: 4, type: GL.FLOAT, divisor: 1}\n          })\n        }\n      },\n      positionAttributeName: 'positions'\n    });\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions()\n      },\n      color: {size: 3, accessor: 'getColorWeight'},\n      elevation: {size: 3, accessor: 'getElevationWeight'}\n    });\n  }\n\n  updateState(opts) {\n    if (this.state.isSupported === false) {\n      // Skip update, layer not supported\n      return;\n    }\n    super.updateState(opts);\n    const {aggregationDirty} = this.state;\n    if (aggregationDirty) {\n      // reset cached CPU Aggregation results (used for picking)\n      this.setState({\n        gridHash: null\n      });\n    }\n  }\n\n  getHashKeyForIndex(index: number): string {\n    const {numRow, numCol, boundingBox, gridOffset} = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    // This will match the index to the hash-key to access aggregation data from CPU aggregation results.\n    const latIdx = Math.floor(\n      (yIndex * cellSize[1] + gridOrigin[1] + 90 + cellSize[1] / 2) / cellSize[1]\n    );\n    const lonIdx = Math.floor(\n      (xIndex * cellSize[0] + gridOrigin[0] + 180 + cellSize[0] / 2) / cellSize[0]\n    );\n    return `${latIdx}-${lonIdx}`;\n  }\n\n  getPositionForIndex(index: number): Position {\n    const {numRow, numCol, boundingBox, gridOffset} = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    const yPos = yIndex * cellSize[1] + gridOrigin[1];\n    const xPos = xIndex * cellSize[0] + gridOrigin[0];\n    return [xPos, yPos];\n  }\n\n  getPickingInfo({info, mode}: GetPickingInfoParams): PickingInfo {\n    const {index} = info;\n    let object: any = null;\n    if (index >= 0) {\n      const {gpuGridAggregator} = this.state;\n      const position = this.getPositionForIndex(index);\n      const colorInfo = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...gpuGridAggregator.getData('color')\n      });\n      const elevationInfo = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...gpuGridAggregator.getData('elevation')\n      });\n\n      object = {\n        colorValue: colorInfo.cellWeight,\n        elevationValue: elevationInfo.cellWeight,\n        count: colorInfo.cellCount || elevationInfo.cellCount,\n        position,\n        totalCount: colorInfo.totalCount || elevationInfo.totalCount\n      };\n      if (mode !== 'hover') {\n        // perform CPU aggregation for full list of points for each cell\n        const {props} = this;\n        let {gridHash} = this.state;\n        if (!gridHash) {\n          const {gridOffset, translation, boundingBox} = this.state;\n          const {viewport} = this.context;\n          const attributes = this.getAttributes();\n          const cpuAggregation = pointToDensityGridDataCPU(props as any, {\n            gridOffset,\n            attributes,\n            viewport,\n            translation,\n            boundingBox\n          });\n          gridHash = cpuAggregation.gridHash;\n          this.setState({gridHash});\n        }\n        const key = this.getHashKeyForIndex(index);\n        const cpuAggregationData = gridHash[key];\n        Object.assign(object, cpuAggregationData);\n      }\n    }\n\n    // override object with picked cell\n    info.picked = Boolean(object);\n    info.object = object;\n\n    return info;\n  }\n\n  renderLayers() {\n    if (!this.state.isSupported) {\n      return null;\n    }\n    const {\n      elevationScale,\n      extruded,\n      cellSize: cellSizeMeters,\n      coverage,\n      material,\n      elevationRange,\n      colorDomain,\n      elevationDomain\n    } = this.props;\n\n    const {weights, numRow, numCol, gridOrigin, gridOffset} = this.state;\n    const {color, elevation} = weights;\n    const colorRange = colorRangeToFlatArray(this.props.colorRange);\n\n    const SubLayerClass = this.getSubLayerClass('gpu-grid-cell', GPUGridCellLayer);\n\n    return new SubLayerClass(\n      {\n        gridSize: [numCol, numRow],\n        gridOrigin,\n        gridOffset: [gridOffset.xOffset, gridOffset.yOffset],\n        colorRange,\n        elevationRange,\n        colorDomain,\n        elevationDomain,\n\n        cellSize: cellSizeMeters,\n        coverage,\n        material,\n        elevationScale,\n        extruded\n      },\n      this.getSubLayerProps({\n        id: 'gpu-grid-cell'\n      }),\n      {\n        data: {\n          attributes: {\n            colors: color.aggregationBuffer,\n            elevations: elevation.aggregationBuffer\n          }\n        },\n        colorMaxMinBuffer: color.maxMinBuffer,\n        elevationMaxMinBuffer: elevation.maxMinBuffer,\n        numInstances: numCol * numRow\n      }\n    );\n  }\n\n  finalizeState(context: LayerContext) {\n    const {color, elevation} = this.state.weights;\n    [color, elevation].forEach(weight => {\n      const {aggregationBuffer, maxMinBuffer} = weight;\n      maxMinBuffer.delete();\n      aggregationBuffer?.delete();\n    });\n    super.finalizeState(context);\n  }\n\n  // Aggregation Overrides\n\n  updateAggregationState(opts) {\n    const {props, oldProps} = opts;\n    const {cellSize, coordinateSystem} = props;\n    const {viewport} = this.context;\n    const cellSizeChanged = oldProps.cellSize !== cellSize;\n    const {dimensions} = this.state;\n\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    // any attribute changed\n    const attributesChanged = positionsChanged || this.isAttributeChanged();\n\n    let {boundingBox} = this.state;\n    if (positionsChanged) {\n      boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n      this.setState({boundingBox});\n    }\n    if (positionsChanged || cellSizeChanged) {\n      const {gridOffset, translation, width, height, numCol, numRow} = getGridParams(\n        boundingBox,\n        cellSize,\n        viewport,\n        coordinateSystem\n      );\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        gridOffset,\n        translation,\n        gridOrigin: [-1 * translation[0], -1 * translation[1]],\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    const aggregationDataDirty =\n      attributesChanged ||\n      this.isAggregationDirty(opts, {\n        dimension: dimensions.data,\n        compareAll: true\n      });\n\n    if (aggregationDataDirty) {\n      this._updateAccessors(opts);\n    }\n    this.setState({\n      aggregationDataDirty\n    });\n  }\n\n  // Private\n\n  _updateAccessors(opts) {\n    const {colorAggregation, elevationAggregation} = opts.props;\n    const {color, elevation} = this.state.weights;\n    color.operation = AGGREGATION_OPERATION[colorAggregation];\n    elevation.operation = AGGREGATION_OPERATION[elevationAggregation];\n  }\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {CubeGeometry} from '@luma.gl/core';\nimport {UNIT} from '@deck.gl/core';\nimport ColumnLayer, {ColumnLayerProps} from './column-layer';\n\nimport type {DefaultProps} from '@deck.gl/core';\n\nconst defaultProps: DefaultProps<GridCellLayerProps> = {\n  cellSize: {type: 'number', min: 0, value: 1000},\n  offset: {type: 'array', value: [1, 1]}\n};\n\n/** All properties supported by GridCellLayer. */\nexport type GridCellLayerProps<DataT = any> = _GridCellLayerProps & ColumnLayerProps<DataT>;\n\n/** Properties added by GridCellLayer. */\ntype _GridCellLayerProps = {\n  /**\n   * @default 1000\n   */\n  cellSize?: number;\n};\n\nexport default class GridCellLayer<DataT = any, ExtraPropsT extends {} = {}> extends ColumnLayer<\n  DataT,\n  ExtraPropsT & Required<_GridCellLayerProps>\n> {\n  static layerName = 'GridCellLayer';\n  static defaultProps = defaultProps;\n\n  getGeometry(diskResolution) {\n    return new CubeGeometry();\n  }\n\n  draw({uniforms}) {\n    const {elevationScale, extruded, offset, coverage, cellSize, angle, radiusUnits} = this.props;\n    this.state.model\n      .setUniforms(uniforms)\n      .setUniforms({\n        radius: cellSize / 2,\n        radiusUnits: UNIT[radiusUnits],\n        angle,\n        offset,\n        extruded,\n        coverage,\n        elevationScale,\n        edgeDistance: 1,\n        isWireframe: false\n      })\n      .draw();\n  }\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {GridCellLayer} from '@deck.gl/layers';\nimport {Accessor, AccessorFunction, Color, Position, Material, DefaultProps} from '@deck.gl/core';\n\nimport {defaultColorRange} from '../utils/color-utils';\nimport {pointToDensityGridDataCPU} from './grid-aggregator';\nimport CPUAggregator from '../utils/cpu-aggregator';\nimport AggregationLayer, {AggregationLayerProps} from '../aggregation-layer';\n\nimport {Layer, UpdateParameters, GetPickingInfoParams, PickingInfo} from '@deck.gl/core';\nimport {AggregateAccessor} from '../types';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction nop() {}\n\nconst defaultProps: DefaultProps<CPUGridLayerProps> = {\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorValue: {type: 'accessor', value: null}, // default value is calculated from `getColorWeight` and `colorAggregation`\n  getColorWeight: {type: 'accessor', value: 1},\n  colorAggregation: 'SUM',\n  lowerPercentile: {type: 'number', min: 0, max: 100, value: 0},\n  upperPercentile: {type: 'number', min: 0, max: 100, value: 100},\n  colorScaleType: 'quantize',\n  onSetColorDomain: nop,\n\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationValue: {type: 'accessor', value: null}, // default value is calculated from `getElevationWeight` and `elevationAggregation`\n  getElevationWeight: {type: 'accessor', value: 1},\n  elevationAggregation: 'SUM',\n  elevationLowerPercentile: {type: 'number', min: 0, max: 100, value: 0},\n  elevationUpperPercentile: {type: 'number', min: 0, max: 100, value: 100},\n  elevationScale: {type: 'number', min: 0, value: 1},\n  elevationScaleType: 'linear',\n  onSetElevationDomain: nop,\n\n  gridAggregator: pointToDensityGridDataCPU,\n\n  // grid\n  cellSize: {type: 'number', min: 0, max: 1000, value: 1000},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  getPosition: {type: 'accessor', value: x => x.position},\n  extruded: false,\n\n  // Optional material for 'lighting' shader module\n  material: true,\n\n  // data filter\n  _filterData: {type: 'function', value: null, optional: true}\n};\n\n/** All properties supported by CPUGridLayer. */\nexport type CPUGridLayerProps<DataT = any> = _CPUGridLayerProps<DataT> &\n  AggregationLayerProps<DataT>;\n\n/** Properties added by CPUGridLayer. */\ntype _CPUGridLayerProps<DataT> = {\n  /**\n   * Size of each cell in meters.\n   * @default 1000\n   */\n  cellSize?: number;\n\n  /**\n   * Color scale domain, default is set to the extent of aggregated weights in each cell.\n   * @default [min(colorWeight), max(colorWeight)]\n   */\n  colorDomain?: [number, number] | null;\n\n  /**\n   * Default: [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6) `6-class YlOrRd`\n   */\n  colorRange?: Color[];\n\n  /**\n   * Cell size multiplier, clamped between 0 - 1.\n   * @default 1\n   */\n  coverage?: number;\n\n  /**\n   * Elevation scale input domain, default is set to between 0 and the max of aggregated weights in each cell.\n   * @default [0, max(elevationWeight)]\n   */\n  elevationDomain?: [number, number] | null;\n\n  /**\n   * Elevation scale output range.\n   * @default [0, 1000]\n   */\n  elevationRange?: [number, number];\n\n  /**\n   * Cell elevation multiplier.\n   * @default 1\n   */\n  elevationScale?: number;\n\n  /**\n   * Whether to enable cell elevation. If set to false, all cell will be flat.\n   * @default true\n   */\n  extruded?: boolean;\n\n  /**\n   * Filter cells and re-calculate color by `upperPercentile`.\n   * Cells with value arger than the upperPercentile will be hidden.\n   * @default 100\n   */\n  upperPercentile?: number;\n\n  /**\n   * Filter cells and re-calculate color by `lowerPercentile`.\n   * Cells with value smaller than the lowerPercentile will be hidden.\n   * @default 0\n   */\n  lowerPercentile?: number;\n\n  /**\n   * Filter cells and re-calculate elevation by `elevationUpperPercentile`.\n   * Cells with elevation value larger than the `elevationUpperPercentile` will be hidden.\n   * @default 100\n   */\n  elevationUpperPercentile?: number;\n\n  /**\n   * Filter cells and re-calculate elevation by `elevationLowerPercentile`.\n   * Cells with elevation value larger than the `elevationLowerPercentile` will be hidden.\n   * @default 0\n   */\n  elevationLowerPercentile?: number;\n\n  /**\n   * Scaling function used to determine the color of the grid cell, default value is 'quantize'.\n   * Supported Values are 'quantize', 'linear', 'quantile' and 'ordinal'.\n   * @default 'quantize'\n   */\n  colorScaleType?: 'quantize' | 'linear' | 'quantile' | 'ordinal';\n\n  /**\n   * Scaling function used to determine the elevation of the grid cell, only supports 'linear'.\n   */\n  elevationScaleType?: 'linear';\n\n  // TODO - document\n  gridAggregator?: (props: any, params: any) => any;\n\n  /**\n   * Material settings for lighting effect. Applies if `extruded: true`.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's color value.\n   * @default 'SUM'\n   */\n  colorAggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's elevation value.\n   * @default 'SUM'\n   */\n  elevationAggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n\n  /**\n   * Method called to retrieve the position of each object.\n   * @default object => object.position\n   */\n  getPosition?: AccessorFunction<DataT, Position>;\n\n  /**\n   * The weight of a data object used to calculate the color value for a cell.\n   * @default 1\n   */\n  getColorWeight?: Accessor<DataT, number>;\n\n  /**\n   * After data objects are aggregated into cells, this accessor is called on each cell to get the value that its color is based on.\n   * @default null\n   */\n  getColorValue?: AggregateAccessor<DataT> | null;\n\n  /**\n   * The weight of a data object used to calculate the elevation value for a cell.\n   * @default 1\n   */\n  getElevationWeight?: Accessor<DataT, number>;\n\n  /**\n   * After data objects are aggregated into cells, this accessor is called on each cell to get the value that its elevation is based on.\n   * @default null\n   */\n  getElevationValue?: AggregateAccessor<DataT> | null;\n\n  /**\n   * This callback will be called when bin color domain has been calculated.\n   * @default () => {}\n   */\n  onSetColorDomain?: (minMax: [number, number]) => void;\n\n  /**\n   * This callback will be called when bin elevation domain has been calculated.\n   * @default () => {}\n   */\n  onSetElevationDomain?: (minMax: [number, number]) => void;\n\n  /**\n   * (Experimental) Filter data objects\n   */\n  _filterData: null | ((d: DataT) => boolean);\n};\n\n/** Aggregate data into a grid-based heatmap. Aggregation is performed on CPU. */\nexport default class CPUGridLayer<\n  DataT = any,\n  ExtraPropsT extends {} = {}\n> extends AggregationLayer<DataT, ExtraPropsT & Required<_CPUGridLayerProps<DataT>>> {\n  static layerName = 'CPUGridLayer';\n  static defaultProps = defaultProps;\n\n  initializeState(): void {\n    const cpuAggregator = new CPUAggregator({\n      getAggregator: props => props.gridAggregator,\n      getCellSize: props => props.cellSize\n    });\n\n    this.state = {\n      cpuAggregator,\n      aggregatorState: cpuAggregator.state\n    };\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      positions: {size: 3, type: GL.DOUBLE, accessor: 'getPosition'}\n    });\n    // color and elevation attributes can't be added as attributes\n    // they are calcualted using 'getValue' accessor that takes an array of pints.\n  }\n\n  updateState(opts: UpdateParameters<this>) {\n    super.updateState(opts);\n    this.setState({\n      // make a copy of the internal state of cpuAggregator for testing\n      aggregatorState: this.state.cpuAggregator.updateState(opts, {\n        viewport: this.context.viewport,\n        attributes: this.getAttributes(),\n        numInstances: this.getNumInstances()\n      })\n    });\n  }\n\n  getPickingInfo({info}: GetPickingInfoParams): PickingInfo {\n    return this.state.cpuAggregator.getPickingInfo({info});\n  }\n\n  // create a method for testing\n  _onGetSublayerColor(cell) {\n    return this.state.cpuAggregator.getAccessor('fillColor')(cell);\n  }\n\n  // create a method for testing\n  _onGetSublayerElevation(cell) {\n    return this.state.cpuAggregator.getAccessor('elevation')(cell);\n  }\n\n  _getSublayerUpdateTriggers() {\n    return this.state.cpuAggregator.getUpdateTriggers(this.props);\n  }\n\n  renderLayers(): Layer {\n    const {elevationScale, extruded, cellSize, coverage, material, transitions} = this.props;\n    const {cpuAggregator} = this.state;\n    const SubLayerClass = this.getSubLayerClass('grid-cell', GridCellLayer);\n    const updateTriggers = this._getSublayerUpdateTriggers();\n\n    return new SubLayerClass(\n      {\n        cellSize,\n        coverage,\n        material,\n        elevationScale,\n        extruded,\n\n        getFillColor: this._onGetSublayerColor.bind(this),\n        getElevation: this._onGetSublayerElevation.bind(this),\n        transitions: transitions && {\n          getFillColor: transitions.getColorValue || transitions.getColorWeight,\n          getElevation: transitions.getElevationValue || transitions.getElevationWeight\n        }\n      },\n      this.getSubLayerProps({\n        id: 'grid-cell',\n        updateTriggers\n      }),\n      {\n        data: cpuAggregator.state.layerData.data\n      }\n    );\n  }\n}\n","import {\n  CompositeLayer,\n  CompositeLayerProps,\n  Layer,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport GPUGridLayer, {GPUGridLayerProps} from '../gpu-grid-layer/gpu-grid-layer';\nimport CPUGridLayer, {CPUGridLayerProps} from '../cpu-grid-layer/cpu-grid-layer';\n\nconst defaultProps: DefaultProps<GridLayerProps> = {\n  ...GPUGridLayer.defaultProps,\n  ...CPUGridLayer.defaultProps,\n  gpuAggregation: false\n};\n\n/** All properties supported by GridLayer. */\nexport type GridLayerProps<DataT = any> = _GridLayerProps<DataT> & CompositeLayerProps;\n\n/** Properties added by GridLayer. */\ntype _GridLayerProps<DataT> = CPUGridLayerProps<DataT> &\n  GPUGridLayerProps<DataT> & {\n    /**\n     * Whether the aggregation should be performed in high-precision 64-bit mode.\n     * @default false\n     */\n    fp64?: boolean;\n\n    /**\n     * When set to true, aggregation is performed on GPU, provided other conditions are met.\n     * @default false\n     */\n    gpuAggregation?: boolean;\n  };\n\n/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */\nexport default class GridLayer<DataT = any, ExtraPropsT extends {} = {}> extends CompositeLayer<\n  ExtraPropsT & Required<_GridLayerProps<DataT>>\n> {\n  static layerName = 'GridLayer';\n  static defaultProps = defaultProps;\n\n  state!: CompositeLayer['state'] & {\n    useGPUAggregation: boolean;\n  };\n\n  initializeState() {\n    this.state = {\n      useGPUAggregation: true\n    };\n  }\n\n  updateState({props}: UpdateParameters<this>) {\n    this.setState({\n      useGPUAggregation: this.canUseGPUAggregation(props)\n    });\n  }\n\n  renderLayers(): Layer {\n    const {data, updateTriggers} = this.props;\n    const id = this.state.useGPUAggregation ? 'GPU' : 'CPU';\n    const LayerType = this.state.useGPUAggregation\n      ? this.getSubLayerClass('GPU', GPUGridLayer)\n      : this.getSubLayerClass('CPU', CPUGridLayer);\n    return new LayerType(\n      this.props,\n      this.getSubLayerProps({\n        id,\n        updateTriggers\n      }),\n      {\n        data\n      }\n    );\n  }\n\n  // Private methods\n\n  canUseGPUAggregation(props: GridLayer['props']) {\n    const {\n      gpuAggregation,\n      lowerPercentile,\n      upperPercentile,\n      getColorValue,\n      getElevationValue,\n      colorScaleType\n    } = props;\n    if (!gpuAggregation) {\n      // cpu aggregation is requested\n      return false;\n    }\n    if (!GPUGridAggregator.isSupported(this.context.gl)) {\n      return false;\n    }\n    if (lowerPercentile !== 0 || upperPercentile !== 100) {\n      // percentile calculations requires sorting not supported on GPU\n      return false;\n    }\n    if (getColorValue !== null || getElevationValue !== null) {\n      // accessor for custom color or elevation calculation is specified\n      return false;\n    }\n    if (colorScaleType === 'quantile' || colorScaleType === 'ordinal') {\n      // quantile and ordinal scales are not supported on GPU\n      return false;\n    }\n    return true;\n  }\n}\n"],"names":["CUBE_INDICES","Uint16Array","CUBE_POSITIONS","Float32Array","CUBE_NORMALS","CUBE_TEX_COORDS","ATTRIBUTES","POSITION","size","value","NORMAL","TEXCOORD_0","CubeGeometry","constructor","props","arguments","length","undefined","id","super","indices","attributes","defaultProps","colorDomain","colorRange","defaultColorRange","elevationDomain","elevationRange","elevationScale","type","min","gridSize","gridOrigin","gridOffset","cellSize","max","offset","coverage","extruded","material","GPUGridCellLayer","Layer","getShaders","vs","fs","modules","project32","gouraudLighting","picking","fp64arithmetic","initializeState","gl","this","getAttributeManager","addInstanced","colors","noAlloc","elevations","model","_getModel","_setupUniformBuffer","setState","Model","geometry","isInstanced","draw","uniforms","colorMaxMinBuffer","elevationMaxMinBuffer","gridOriginLow","fp64LowPart","gridOffsetLow","domainUniforms","getDomainUniforms","colorRangeToFlatArray","bindUniformBuffers","state","setUniforms","unbindUniformBuffers","bind","target","index","unbind","colorDomainValid","elevationDomainValid","context","programHandle","program","handle","colorIndex","getUniformBlockIndex","elevationIndex","uniformBlockBinding","getColorWeight","colorAggregation","getElevationWeight","elevationAggregation","getPosition","x","position","DIMENSIONS","data","POSITION_ATTRIBUTE_NAME","GPUGridLayer","GridAggregationLayer","isSupported","GPUGridAggregator","log","error","initializeAggregationLayer","dimensions","gpuAggregation","projectPoints","weights","color","needMin","needMax","combineMaxMin","maxMinBuffer","Buffer","byteLength","accessor","divisor","elevation","positionAttributeName","add","fp64","use64bitPositions","updateState","opts","aggregationDirty","gridHash","getHashKeyForIndex","numRow","numCol","boundingBox","xMin","yMin","xOffset","yOffset","yIndex","Math","floor","xIndex","latIdx","lonIdx","concat","getPositionForIndex","getPickingInfo","info","mode","object","gpuGridAggregator","colorInfo","getAggregationData","pixelIndex","getData","elevationInfo","colorValue","cellWeight","elevationValue","count","cellCount","totalCount","translation","viewport","getAttributes","pointToDensityGridDataCPU","cpuAggregationData","Object","assign","picked","Boolean","renderLayers","cellSizeMeters","getSubLayerClass","getSubLayerProps","aggregationBuffer","numInstances","finalizeState","forEach","weight","delete","updateAggregationState","oldProps","coordinateSystem","cellSizeChanged","positionsChanged","isAttributeChanged","attributesChanged","getBoundingBox","getNumInstances","width","height","getGridParams","allocateResources","aggregationDataDirty","isAggregationDirty","dimension","compareAll","_updateAccessors","operation","AGGREGATION_OPERATION","GridCellLayer","ColumnLayer","getGeometry","diskResolution","angle","radiusUnits","radius","UNIT","edgeDistance","isWireframe","nop","getColorValue","lowerPercentile","upperPercentile","colorScaleType","onSetColorDomain","getElevationValue","elevationLowerPercentile","elevationUpperPercentile","elevationScaleType","onSetElevationDomain","gridAggregator","_filterData","optional","CPUGridLayer","AggregationLayer","cpuAggregator","CPUAggregator","getAggregator","getCellSize","aggregatorState","positions","_onGetSublayerColor","cell","getAccessor","_onGetSublayerElevation","_getSublayerUpdateTriggers","getUpdateTriggers","transitions","SubLayerClass","updateTriggers","getFillColor","getElevation","layerData","GridLayer","CompositeLayer","args","_defineProperty","useGPUAggregation","canUseGPUAggregation"],"sourceRoot":""}