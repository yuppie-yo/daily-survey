{"version":3,"file":"64a9ae3a1e1b779ca201.chunk.js","mappings":"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","sources":["webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js","webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js","webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js","webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js","webpack://superset/./plugins/legacy-preset-chart-deckgl/src/layers/Grid/Grid.tsx"],"sourcesContent":["export default \"#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\\n\\nstruct AmbientLight {\\n vec3 color;\\n};\\n\\nstruct PointLight {\\n vec3 color;\\n vec3 position;\\n vec3 attenuation;\\n};\\n\\nstruct DirectionalLight {\\n  vec3 color;\\n  vec3 direction;\\n};\\n\\nuniform AmbientLight lighting_uAmbientLight;\\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\\nuniform int lighting_uPointLightCount;\\nuniform int lighting_uDirectionalLightCount;\\n\\nuniform bool lighting_uEnabled;\\n\\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\\n  return pointLight.attenuation.x\\n       + pointLight.attenuation.y * distance\\n       + pointLight.attenuation.z * distance * distance;\\n}\\n\\n#endif\\n\";\n//# sourceMappingURL=lights.glsl.js.map","import lightingShader from './lights.glsl';\nconst INITIAL_MODULE_OPTIONS = {\n  lightSources: {}\n};\n\nfunction convertColor() {\n  let {\n    color = [0, 0, 0],\n    intensity = 1.0\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return color.map(component => component * intensity / 255.0);\n}\n\nfunction getLightSourceUniforms(_ref) {\n  let {\n    ambientLight,\n    pointLights = [],\n    directionalLights = []\n  } = _ref;\n  const lightSourceUniforms = {};\n\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n\n  pointLights.forEach((pointLight, index) => {\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].color\")] = convertColor(pointLight);\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].position\")] = pointLight.position;\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].attenuation\")] = pointLight.attenuation || [1, 0, 0];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n  directionalLights.forEach((directionalLight, index) => {\n    lightSourceUniforms[\"lighting_uDirectionalLight[\".concat(index, \"].color\")] = convertColor(directionalLight);\n    lightSourceUniforms[\"lighting_uDirectionalLight[\".concat(index, \"].direction\")] = directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n  return lightSourceUniforms;\n}\n\nfunction getUniforms() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;\n\n  if ('lightSources' in opts) {\n    const {\n      ambientLight,\n      pointLights,\n      directionalLights\n    } = opts.lightSources || {};\n    const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;\n\n    if (!hasLights) {\n      return {\n        lighting_uEnabled: false\n      };\n    }\n\n    return Object.assign({}, getLightSourceUniforms({\n      ambientLight,\n      pointLights,\n      directionalLights\n    }), {\n      lighting_uEnabled: true\n    });\n  }\n\n  if ('lights' in opts) {\n    const lightSources = {\n      pointLights: [],\n      directionalLights: []\n    };\n\n    for (const light of opts.lights || []) {\n      switch (light.type) {\n        case 'ambient':\n          lightSources.ambientLight = light;\n          break;\n\n        case 'directional':\n          lightSources.directionalLights.push(light);\n          break;\n\n        case 'point':\n          lightSources.pointLights.push(light);\n          break;\n\n        default:\n      }\n    }\n\n    return getUniforms({\n      lightSources\n    });\n  }\n\n  return {};\n}\n\nexport const lights = {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};\n//# sourceMappingURL=lights.js.map","export default \"\\nuniform float lighting_uAmbient;\\nuniform float lighting_uDiffuse;\\nuniform float lighting_uShininess;\\nuniform vec3  lighting_uSpecularColor;\\n\\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\\n    vec3 halfway_direction = normalize(light_direction + view_direction);\\n    float lambertian = dot(light_direction, normal_worldspace);\\n    float specular = 0.0;\\n    if (lambertian > 0.0) {\\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\\n      specular = pow(specular_angle, lighting_uShininess);\\n    }\\n    lambertian = max(lambertian, 0.0);\\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\\n}\\n\\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\\n  vec3 lightColor = surfaceColor;\\n\\n  if (lighting_uEnabled) {\\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uPointLightCount) {\\n        break;\\n      }\\n      PointLight pointLight = lighting_uPointLight[i];\\n      vec3 light_position_worldspace = pointLight.position;\\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\\n    }\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uDirectionalLightCount) {\\n        break;\\n      }\\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\\n    }\\n  }\\n  return lightColor;\\n}\\n\\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\\n  vec3 lightColor = vec3(0, 0, 0);\\n  vec3 surfaceColor = vec3(0, 0, 0);\\n\\n  if (lighting_uEnabled) {\\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uPointLightCount) {\\n        break;\\n      }\\n      PointLight pointLight = lighting_uPointLight[i];\\n      vec3 light_position_worldspace = pointLight.position;\\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\\n    }\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uDirectionalLightCount) {\\n        break;\\n      }\\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\\n    }\\n  }\\n  return lightColor;\\n}\\n\";\n//# sourceMappingURL=phong-lighting.glsl.js.map","import { lights } from '../lights/lights';\nimport lightingShader from './phong-lighting.glsl';\nconst INITIAL_MODULE_OPTIONS = {};\n\nfunction getMaterialUniforms(material) {\n  const {\n    ambient = 0.35,\n    diffuse = 0.6,\n    shininess = 32,\n    specularColor = [30, 30, 30]\n  } = material;\n  return {\n    lighting_uAmbient: ambient,\n    lighting_uDiffuse: diffuse,\n    lighting_uShininess: shininess,\n    lighting_uSpecularColor: specularColor.map(x => x / 255)\n  };\n}\n\nfunction getUniforms() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;\n\n  if (!('material' in opts)) {\n    return {};\n  }\n\n  const {\n    material\n  } = opts;\n\n  if (!material) {\n    return {\n      lighting_uEnabled: false\n    };\n  }\n\n  return getMaterialUniforms(material);\n}\n\nexport const gouraudLighting = {\n  name: 'gouraud-lighting',\n  dependencies: [lights],\n  vs: lightingShader,\n  defines: {\n    LIGHTING_VERTEX: 1\n  },\n  getUniforms\n};\nexport const phongLighting = {\n  name: 'phong-lighting',\n  dependencies: [lights],\n  fs: lightingShader,\n  defines: {\n    LIGHTING_FRAGMENT: 1\n  },\n  getUniforms\n};\n//# sourceMappingURL=phong-lighting.js.map","/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { Color, GridLayer } from 'deck.gl/typed';\nimport {\n  t,\n  CategoricalColorNamespace,\n  JsonObject,\n  QueryFormData,\n} from '@superset-ui/core';\n\nimport { commonLayerProps, getAggFunc } from '../common';\nimport sandboxedEval from '../../utils/sandbox';\nimport { hexToRGB } from '../../utils/colors';\nimport { createDeckGLComponent } from '../../factory';\nimport TooltipRow from '../../TooltipRow';\nimport { TooltipProps } from '../../components/Tooltip';\n\nfunction setTooltipContent(o: JsonObject) {\n  return (\n    <div className=\"deckgl-tooltip\">\n      <TooltipRow\n        // eslint-disable-next-line prefer-template\n        label={t('Longitude and Latitude') + ': '}\n        value={`${o.coordinate[0]}, ${o.coordinate[1]}`}\n      />\n      <TooltipRow\n        // eslint-disable-next-line prefer-template\n        label={t('Height') + ': '}\n        value={`${o.object.elevationValue}`}\n      />\n    </div>\n  );\n}\n\nexport function getLayer(\n  formData: QueryFormData,\n  payload: JsonObject,\n  onAddFilter: () => void,\n  setTooltip: (tooltip: TooltipProps['tooltip']) => void,\n) {\n  const fd = formData;\n  const appliedScheme = fd.color_scheme;\n  const colorScale = CategoricalColorNamespace.getScale(appliedScheme);\n  const colorRange = colorScale\n    .range()\n    .map(color => hexToRGB(color)) as Color[];\n  let data = payload.data.features;\n\n  if (fd.js_data_mutator) {\n    // Applying user defined data mutator if defined\n    const jsFnMutator = sandboxedEval(fd.js_data_mutator);\n    data = jsFnMutator(data);\n  }\n\n  const aggFunc = getAggFunc(fd.js_agg_function, p => p.weight);\n\n  return new GridLayer({\n    id: `grid-layer-${fd.slice_id}` as const,\n    data,\n    cellSize: fd.grid_size,\n    extruded: fd.extruded,\n    colorRange,\n    outline: false,\n    // @ts-ignore\n    getElevationValue: aggFunc,\n    // @ts-ignore\n    getColorValue: aggFunc,\n    ...commonLayerProps(fd, setTooltip, setTooltipContent),\n  });\n}\n\nfunction getPoints(data: JsonObject[]) {\n  return data.map(d => d.position);\n}\n\nexport default createDeckGLComponent(getLayer, getPoints);\n"],"names":["INITIAL_MODULE_OPTIONS","lightSources","convertColor","color","intensity","arguments","length","undefined","map","component","lights","name","vs","fs","getUniforms","opts","ambientLight","pointLights","directionalLights","Object","assign","_ref","lightSourceUniforms","forEach","pointLight","index","concat","position","attenuation","lighting_uPointLightCount","directionalLight","direction","lighting_uDirectionalLightCount","getLightSourceUniforms","lighting_uEnabled","light","type","push","defines","MAX_LIGHTS","material","ambient","diffuse","shininess","specularColor","lighting_uAmbient","lighting_uDiffuse","lighting_uShininess","lighting_uSpecularColor","x","getMaterialUniforms","gouraudLighting","dependencies","LIGHTING_VERTEX","phongLighting","LIGHTING_FRAGMENT","setTooltipContent","o","_jsxs","className","children","_jsx","TooltipRow","label","t","value","coordinate","object","elevationValue","getLayer","formData","payload","onAddFilter","setTooltip","fd","appliedScheme","color_scheme","colorRange","CategoricalColorNamespace","range","hexToRGB","data","features","js_data_mutator","sandboxedEval","jsFnMutator","aggFunc","getAggFunc","js_agg_function","p","weight","GridLayer","id","slice_id","cellSize","grid_size","extruded","outline","getElevationValue","getColorValue","commonLayerProps","createDeckGLComponent","d"],"sourceRoot":""}